
SD Card.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000034f8  00002000  00002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  000054f8  000054f8  000054f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  00005500  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000006b0  2000043c  0000593c  0001043c  2**2
                  ALLOC
  4 .stack        00002004  20000aec  00005fec  0001043c  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  0001043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00010464  2**0
                  CONTENTS, READONLY
  7 .debug_info   000115ab  00000000  00000000  000104bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000011f5  00000000  00000000  00021a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000056c6  00000000  00000000  00022c5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000003a8  00000000  00000000  00028323  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000320  00000000  00000000  000286cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013643  00000000  00000000  000289eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00004caf  00000000  00000000  0003c02e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000749fe  00000000  00000000  00040cdd  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000c68  00000000  00000000  000b56dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00002000 <exception_table>:
    2000:	f0 2a 00 20 51 24 00 00 4d 24 00 00 4d 24 00 00     .*. Q$..M$..M$..
	...
    202c:	4d 24 00 00 00 00 00 00 00 00 00 00 4d 24 00 00     M$..........M$..
    203c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    204c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    205c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    206c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    207c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    208c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    209c:	4d 24 00 00 4d 24 00 00 4d 24 00 00 4d 24 00 00     M$..M$..M$..M$..
    20ac:	4d 24 00 00 00 00 00 00                             M$......

000020b4 <__do_global_dtors_aux>:
    20b4:	b510      	push	{r4, lr}
    20b6:	4c06      	ldr	r4, [pc, #24]	; (20d0 <__do_global_dtors_aux+0x1c>)
    20b8:	7823      	ldrb	r3, [r4, #0]
    20ba:	2b00      	cmp	r3, #0
    20bc:	d107      	bne.n	20ce <__do_global_dtors_aux+0x1a>
    20be:	4b05      	ldr	r3, [pc, #20]	; (20d4 <__do_global_dtors_aux+0x20>)
    20c0:	2b00      	cmp	r3, #0
    20c2:	d002      	beq.n	20ca <__do_global_dtors_aux+0x16>
    20c4:	4804      	ldr	r0, [pc, #16]	; (20d8 <__do_global_dtors_aux+0x24>)
    20c6:	e000      	b.n	20ca <__do_global_dtors_aux+0x16>
    20c8:	bf00      	nop
    20ca:	2301      	movs	r3, #1
    20cc:	7023      	strb	r3, [r4, #0]
    20ce:	bd10      	pop	{r4, pc}
    20d0:	2000043c 	.word	0x2000043c
    20d4:	00000000 	.word	0x00000000
    20d8:	00005500 	.word	0x00005500

000020dc <frame_dummy>:
    20dc:	4b08      	ldr	r3, [pc, #32]	; (2100 <frame_dummy+0x24>)
    20de:	b510      	push	{r4, lr}
    20e0:	2b00      	cmp	r3, #0
    20e2:	d003      	beq.n	20ec <frame_dummy+0x10>
    20e4:	4907      	ldr	r1, [pc, #28]	; (2104 <frame_dummy+0x28>)
    20e6:	4808      	ldr	r0, [pc, #32]	; (2108 <frame_dummy+0x2c>)
    20e8:	e000      	b.n	20ec <frame_dummy+0x10>
    20ea:	bf00      	nop
    20ec:	4807      	ldr	r0, [pc, #28]	; (210c <frame_dummy+0x30>)
    20ee:	6803      	ldr	r3, [r0, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d100      	bne.n	20f6 <frame_dummy+0x1a>
    20f4:	bd10      	pop	{r4, pc}
    20f6:	4b06      	ldr	r3, [pc, #24]	; (2110 <frame_dummy+0x34>)
    20f8:	2b00      	cmp	r3, #0
    20fa:	d0fb      	beq.n	20f4 <frame_dummy+0x18>
    20fc:	4798      	blx	r3
    20fe:	e7f9      	b.n	20f4 <frame_dummy+0x18>
    2100:	00000000 	.word	0x00000000
    2104:	20000440 	.word	0x20000440
    2108:	00005500 	.word	0x00005500
    210c:	00005500 	.word	0x00005500
    2110:	00000000 	.word	0x00000000

00002114 <AppInit>:

/*-----------------------------------------------------------------------*/
/* Application Initialization                                            */
/*-----------------------------------------------------------------------*/
void AppInit(void)
{
    2114:	b510      	push	{r4, lr}
	// Initialize clocks
	ClocksInit();
    2116:	4b10      	ldr	r3, [pc, #64]	; (2158 <AppInit+0x44>)
    2118:	4798      	blx	r3

	// Assign SS as OUTPUT
	REG_PORT_DIR0 |= PORT_PA13;
    211a:	4910      	ldr	r1, [pc, #64]	; (215c <AppInit+0x48>)
    211c:	680b      	ldr	r3, [r1, #0]
    211e:	2280      	movs	r2, #128	; 0x80
    2120:	0192      	lsls	r2, r2, #6
    2122:	4313      	orrs	r3, r2
    2124:	600b      	str	r3, [r1, #0]

	// Set SS OFF
	REG_PORT_OUTSET0 = PORT_PA13;
    2126:	4b0e      	ldr	r3, [pc, #56]	; (2160 <AppInit+0x4c>)
    2128:	601a      	str	r2, [r3, #0]

	// Initialize UART3 for debugging
	UART3_Init(9600);
    212a:	2096      	movs	r0, #150	; 0x96
    212c:	0180      	lsls	r0, r0, #6
    212e:	4b0d      	ldr	r3, [pc, #52]	; (2164 <AppInit+0x50>)
    2130:	4798      	blx	r3
	UART3_Write_Text("UART3 Initialized\r\n");
    2132:	480d      	ldr	r0, [pc, #52]	; (2168 <AppInit+0x54>)
    2134:	4c0d      	ldr	r4, [pc, #52]	; (216c <AppInit+0x58>)
    2136:	47a0      	blx	r4

	// Initialize SPI
	SPI_Initialize_Slow();
    2138:	4b0d      	ldr	r3, [pc, #52]	; (2170 <AppInit+0x5c>)
    213a:	4798      	blx	r3
	UART3_Write_Text("SPI Initialized (Slow)\r\n");
    213c:	480d      	ldr	r0, [pc, #52]	; (2174 <AppInit+0x60>)
    213e:	47a0      	blx	r4

	// Initialize SD card
	if (SDCard_Init() == 0)
    2140:	4b0d      	ldr	r3, [pc, #52]	; (2178 <AppInit+0x64>)
    2142:	4798      	blx	r3
    2144:	2800      	cmp	r0, #0
    2146:	d103      	bne.n	2150 <AppInit+0x3c>
	{
		UART3_Write_Text("SD Card Initialized Successfully\r\n");
    2148:	480c      	ldr	r0, [pc, #48]	; (217c <AppInit+0x68>)
    214a:	4b08      	ldr	r3, [pc, #32]	; (216c <AppInit+0x58>)
    214c:	4798      	blx	r3
	else
	{
		UART3_Write_Text("SD Card Initialization Failed\r\n");
		while (1);
	}
}
    214e:	bd10      	pop	{r4, pc}
		UART3_Write_Text("SD Card Initialization Failed\r\n");
    2150:	480b      	ldr	r0, [pc, #44]	; (2180 <AppInit+0x6c>)
    2152:	4b06      	ldr	r3, [pc, #24]	; (216c <AppInit+0x58>)
    2154:	4798      	blx	r3
    2156:	e7fe      	b.n	2156 <AppInit+0x42>
    2158:	000022d1 	.word	0x000022d1
    215c:	41004400 	.word	0x41004400
    2160:	41004418 	.word	0x41004418
    2164:	000046ad 	.word	0x000046ad
    2168:	00004e2c 	.word	0x00004e2c
    216c:	00004771 	.word	0x00004771
    2170:	0000458d 	.word	0x0000458d
    2174:	00004e40 	.word	0x00004e40
    2178:	00003f01 	.word	0x00003f01
    217c:	00004e5c 	.word	0x00004e5c
    2180:	00004e80 	.word	0x00004e80

00002184 <AppRun>:

/*-----------------------------------------------------------------------*/
/* Application Run Loop                                                  */
/*-----------------------------------------------------------------------*/
void AppRun(void)
{
    2184:	b510      	push	{r4, lr}
    2186:	b09a      	sub	sp, #104	; 0x68
	// Mount the SD card
	UART3_Write_Text("Mounting SD card...\r\n");
    2188:	4836      	ldr	r0, [pc, #216]	; (2264 <AppRun+0xe0>)
    218a:	4b37      	ldr	r3, [pc, #220]	; (2268 <AppRun+0xe4>)
    218c:	4798      	blx	r3
	FR = f_mount(&fs, "", 0);
    218e:	2200      	movs	r2, #0
    2190:	4936      	ldr	r1, [pc, #216]	; (226c <AppRun+0xe8>)
    2192:	4837      	ldr	r0, [pc, #220]	; (2270 <AppRun+0xec>)
    2194:	4b37      	ldr	r3, [pc, #220]	; (2274 <AppRun+0xf0>)
    2196:	4798      	blx	r3
    2198:	4b37      	ldr	r3, [pc, #220]	; (2278 <AppRun+0xf4>)
    219a:	7018      	strb	r0, [r3, #0]
	if (FR)
    219c:	2800      	cmp	r0, #0
    219e:	d003      	beq.n	21a8 <AppRun+0x24>
	{
		UART3_Write_Text("Error mounting file system\r\n");
    21a0:	4836      	ldr	r0, [pc, #216]	; (227c <AppRun+0xf8>)
    21a2:	4b31      	ldr	r3, [pc, #196]	; (2268 <AppRun+0xe4>)
    21a4:	4798      	blx	r3
    21a6:	e7fe      	b.n	21a6 <AppRun+0x22>
		while (1);
	}
	UART3_Write_Text("SD card mounted successfully\r\n");
    21a8:	4835      	ldr	r0, [pc, #212]	; (2280 <AppRun+0xfc>)
    21aa:	4c2f      	ldr	r4, [pc, #188]	; (2268 <AppRun+0xe4>)
    21ac:	47a0      	blx	r4

	// Open the SD Card for writing
	UART3_Write_Text("Opening file for writing...\r\n");
    21ae:	4835      	ldr	r0, [pc, #212]	; (2284 <AppRun+0x100>)
    21b0:	47a0      	blx	r4
	FR = f_open(&fil, data_file, FA_WRITE | FA_CREATE_ALWAYS);
    21b2:	220a      	movs	r2, #10
    21b4:	4934      	ldr	r1, [pc, #208]	; (2288 <AppRun+0x104>)
    21b6:	4835      	ldr	r0, [pc, #212]	; (228c <AppRun+0x108>)
    21b8:	4b35      	ldr	r3, [pc, #212]	; (2290 <AppRun+0x10c>)
    21ba:	4798      	blx	r3
    21bc:	4b2e      	ldr	r3, [pc, #184]	; (2278 <AppRun+0xf4>)
    21be:	7018      	strb	r0, [r3, #0]
	if (FR)
    21c0:	2800      	cmp	r0, #0
    21c2:	d003      	beq.n	21cc <AppRun+0x48>
	{
		UART3_Write_Text("Error opening file for writing\r\n");
    21c4:	4833      	ldr	r0, [pc, #204]	; (2294 <AppRun+0x110>)
    21c6:	4b28      	ldr	r3, [pc, #160]	; (2268 <AppRun+0xe4>)
    21c8:	4798      	blx	r3
    21ca:	e7fe      	b.n	21ca <AppRun+0x46>
		while (1);
	}

	// Write some CSV data to the file
	UART3_Write_Text("Writing data to file...\r\n");
    21cc:	4832      	ldr	r0, [pc, #200]	; (2298 <AppRun+0x114>)
    21ce:	4b26      	ldr	r3, [pc, #152]	; (2268 <AppRun+0xe4>)
    21d0:	4798      	blx	r3
	FR = f_write(&fil, "Data1,Data2,Data3,Data4\r\n", 25, &bw);
    21d2:	4b32      	ldr	r3, [pc, #200]	; (229c <AppRun+0x118>)
    21d4:	2219      	movs	r2, #25
    21d6:	4932      	ldr	r1, [pc, #200]	; (22a0 <AppRun+0x11c>)
    21d8:	482c      	ldr	r0, [pc, #176]	; (228c <AppRun+0x108>)
    21da:	4c32      	ldr	r4, [pc, #200]	; (22a4 <AppRun+0x120>)
    21dc:	47a0      	blx	r4
    21de:	4b26      	ldr	r3, [pc, #152]	; (2278 <AppRun+0xf4>)
    21e0:	7018      	strb	r0, [r3, #0]
	if (FR)
    21e2:	2800      	cmp	r0, #0
    21e4:	d003      	beq.n	21ee <AppRun+0x6a>
	{
		UART3_Write_Text("Error writing to file\r\n");
    21e6:	4830      	ldr	r0, [pc, #192]	; (22a8 <AppRun+0x124>)
    21e8:	4b1f      	ldr	r3, [pc, #124]	; (2268 <AppRun+0xe4>)
    21ea:	4798      	blx	r3
    21ec:	e7fe      	b.n	21ec <AppRun+0x68>
		while (1);
	}

	// Close the file after writing
	FR = f_close(&fil);
    21ee:	4827      	ldr	r0, [pc, #156]	; (228c <AppRun+0x108>)
    21f0:	4b2e      	ldr	r3, [pc, #184]	; (22ac <AppRun+0x128>)
    21f2:	4798      	blx	r3
    21f4:	4b20      	ldr	r3, [pc, #128]	; (2278 <AppRun+0xf4>)
    21f6:	7018      	strb	r0, [r3, #0]
	if (FR)
    21f8:	2800      	cmp	r0, #0
    21fa:	d003      	beq.n	2204 <AppRun+0x80>
	{
		UART3_Write_Text("Error closing file after writing\r\n");
    21fc:	482c      	ldr	r0, [pc, #176]	; (22b0 <AppRun+0x12c>)
    21fe:	4b1a      	ldr	r3, [pc, #104]	; (2268 <AppRun+0xe4>)
    2200:	4798      	blx	r3
    2202:	e7fe      	b.n	2202 <AppRun+0x7e>
		while (1);
	}
	UART3_Write_Text("File written and closed successfully\r\n");
    2204:	482b      	ldr	r0, [pc, #172]	; (22b4 <AppRun+0x130>)
    2206:	4c18      	ldr	r4, [pc, #96]	; (2268 <AppRun+0xe4>)
    2208:	47a0      	blx	r4

	// Open the SD Card for reading
	UART3_Write_Text("Opening file for reading...\r\n");
    220a:	482b      	ldr	r0, [pc, #172]	; (22b8 <AppRun+0x134>)
    220c:	47a0      	blx	r4
	FR = f_open(&fil, data_file, FA_READ);
    220e:	2201      	movs	r2, #1
    2210:	491d      	ldr	r1, [pc, #116]	; (2288 <AppRun+0x104>)
    2212:	481e      	ldr	r0, [pc, #120]	; (228c <AppRun+0x108>)
    2214:	4b1e      	ldr	r3, [pc, #120]	; (2290 <AppRun+0x10c>)
    2216:	4798      	blx	r3
    2218:	4b17      	ldr	r3, [pc, #92]	; (2278 <AppRun+0xf4>)
    221a:	7018      	strb	r0, [r3, #0]
	if (FR)
    221c:	2800      	cmp	r0, #0
    221e:	d003      	beq.n	2228 <AppRun+0xa4>
	{
		UART3_Write_Text("Error opening file for reading\r\n");
    2220:	4826      	ldr	r0, [pc, #152]	; (22bc <AppRun+0x138>)
    2222:	4b11      	ldr	r3, [pc, #68]	; (2268 <AppRun+0xe4>)
    2224:	4798      	blx	r3
    2226:	e7fe      	b.n	2226 <AppRun+0xa2>
		while (1);
	}

	// Read data from the file and print to UART
	char line[100];
	UART3_Write_Text("Reading file contents:\r\n");
    2228:	4825      	ldr	r0, [pc, #148]	; (22c0 <AppRun+0x13c>)
    222a:	4b0f      	ldr	r3, [pc, #60]	; (2268 <AppRun+0xe4>)
    222c:	4798      	blx	r3
	while (f_gets(line, sizeof(line), &fil))
    222e:	e002      	b.n	2236 <AppRun+0xb2>
	{
		UART3_Write_Text(line);
    2230:	a801      	add	r0, sp, #4
    2232:	4b0d      	ldr	r3, [pc, #52]	; (2268 <AppRun+0xe4>)
    2234:	4798      	blx	r3
	while (f_gets(line, sizeof(line), &fil))
    2236:	4a15      	ldr	r2, [pc, #84]	; (228c <AppRun+0x108>)
    2238:	2164      	movs	r1, #100	; 0x64
    223a:	a801      	add	r0, sp, #4
    223c:	4b21      	ldr	r3, [pc, #132]	; (22c4 <AppRun+0x140>)
    223e:	4798      	blx	r3
    2240:	2800      	cmp	r0, #0
    2242:	d1f5      	bne.n	2230 <AppRun+0xac>
	}

	// Close the file after reading
	FR = f_close(&fil);
    2244:	4811      	ldr	r0, [pc, #68]	; (228c <AppRun+0x108>)
    2246:	4b19      	ldr	r3, [pc, #100]	; (22ac <AppRun+0x128>)
    2248:	4798      	blx	r3
    224a:	4b0b      	ldr	r3, [pc, #44]	; (2278 <AppRun+0xf4>)
    224c:	7018      	strb	r0, [r3, #0]
	if (FR)
    224e:	2800      	cmp	r0, #0
    2250:	d003      	beq.n	225a <AppRun+0xd6>
	{
		UART3_Write_Text("Error closing file after reading\r\n");
    2252:	481d      	ldr	r0, [pc, #116]	; (22c8 <AppRun+0x144>)
    2254:	4b04      	ldr	r3, [pc, #16]	; (2268 <AppRun+0xe4>)
    2256:	4798      	blx	r3
    2258:	e7fe      	b.n	2258 <AppRun+0xd4>
		while (1);
	}
	UART3_Write_Text("File read and closed successfully\r\n");
    225a:	481c      	ldr	r0, [pc, #112]	; (22cc <AppRun+0x148>)
    225c:	4b02      	ldr	r3, [pc, #8]	; (2268 <AppRun+0xe4>)
    225e:	4798      	blx	r3
    2260:	e7fe      	b.n	2260 <AppRun+0xdc>
    2262:	46c0      	nop			; (mov r8, r8)
    2264:	00004ea0 	.word	0x00004ea0
    2268:	00004771 	.word	0x00004771
    226c:	00004e58 	.word	0x00004e58
    2270:	2000046c 	.word	0x2000046c
    2274:	00003689 	.word	0x00003689
    2278:	2000069c 	.word	0x2000069c
    227c:	00004eb8 	.word	0x00004eb8
    2280:	00004ed8 	.word	0x00004ed8
    2284:	00004ef8 	.word	0x00004ef8
    2288:	20000000 	.word	0x20000000
    228c:	200006a4 	.word	0x200006a4
    2290:	000036ed 	.word	0x000036ed
    2294:	00004f18 	.word	0x00004f18
    2298:	00004f3c 	.word	0x00004f3c
    229c:	200006a0 	.word	0x200006a0
    22a0:	00004f58 	.word	0x00004f58
    22a4:	00003a29 	.word	0x00003a29
    22a8:	00004f74 	.word	0x00004f74
    22ac:	00003cc9 	.word	0x00003cc9
    22b0:	00004f8c 	.word	0x00004f8c
    22b4:	00004fb0 	.word	0x00004fb0
    22b8:	00004fd8 	.word	0x00004fd8
    22bc:	00004ff8 	.word	0x00004ff8
    22c0:	0000501c 	.word	0x0000501c
    22c4:	00003cf1 	.word	0x00003cf1
    22c8:	00005038 	.word	0x00005038
    22cc:	0000505c 	.word	0x0000505c

000022d0 <ClocksInit>:
 * Notes:
 *
 ******************************************************************************/

void ClocksInit(void)
{
    22d0:	b530      	push	{r4, r5, lr}

	/* ----------------------------------------------------------------------------------------------
	* 1) Set Flash wait states for 48 MHz (per Table 37-40 in data sheet)
	*/
	
	NVMCTRL->CTRLB.bit.RWS = 1;		/* 1 wait state required @ 3.3V & 48MHz */
    22d2:	4a50      	ldr	r2, [pc, #320]	; (2414 <ClocksInit+0x144>)
    22d4:	6853      	ldr	r3, [r2, #4]
    22d6:	211e      	movs	r1, #30
    22d8:	438b      	bics	r3, r1
    22da:	391c      	subs	r1, #28
    22dc:	430b      	orrs	r3, r1
    22de:	6053      	str	r3, [r2, #4]
	/* ----------------------------------------------------------------------------------------------
	* 2) Enable XOSC32K clock (External on-board 32.768kHz oscillator), will be used as DFLL48M reference.
	*/
	
	// Configure SYSCTRL->XOSC32K settings
	SYSCTRL_XOSC32K_Type sysctrl_xosc32k =
    22e0:	2208      	movs	r2, #8
    22e2:	2304      	movs	r3, #4
    22e4:	431a      	orrs	r2, r3
    22e6:	2380      	movs	r3, #128	; 0x80
    22e8:	009b      	lsls	r3, r3, #2
    22ea:	4313      	orrs	r3, r2
		.bit.AAMPEN = 0,		/* Disable automatic amplitude control */
		.bit.EN32K = 1,			/* 32kHz output is disabled */
		.bit.XTALEN = 1			/* Crystal connected to XIN32/XOUT32 */
	};
	// Write these settings
	SYSCTRL->XOSC32K.reg = sysctrl_xosc32k.reg;
    22ec:	b29b      	uxth	r3, r3
    22ee:	4a4a      	ldr	r2, [pc, #296]	; (2418 <ClocksInit+0x148>)
    22f0:	8293      	strh	r3, [r2, #20]
	// Enable the Oscillator - Separate step per data sheet recommendation (sec 17.6.3)
	SYSCTRL->XOSC32K.bit.ENABLE = 1;
    22f2:	8a93      	ldrh	r3, [r2, #20]
    22f4:	430b      	orrs	r3, r1
    22f6:	8293      	strh	r3, [r2, #20]
	
	// Wait for XOSC32K to stabilize
	while(!SYSCTRL->PCLKSR.bit.XOSC32KRDY);
    22f8:	4b47      	ldr	r3, [pc, #284]	; (2418 <ClocksInit+0x148>)
    22fa:	68db      	ldr	r3, [r3, #12]
    22fc:	079b      	lsls	r3, r3, #30
    22fe:	d5fb      	bpl.n	22f8 <ClocksInit+0x28>
	* 3) Put XOSC32K as source of Generic Clock Generator 1
	*/
	
	// Set the Generic Clock Generator 1 output divider to 1
	// Configure GCLK->GENDIV settings
	GCLK_GENDIV_Type gclk1_gendiv = 
    2300:	2301      	movs	r3, #1
    2302:	2180      	movs	r1, #128	; 0x80
    2304:	0049      	lsls	r1, r1, #1
    2306:	4319      	orrs	r1, r3
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K	/* Apply division factor to Generator 1 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk1_gendiv.reg;
    2308:	4844      	ldr	r0, [pc, #272]	; (241c <ClocksInit+0x14c>)
    230a:	6081      	str	r1, [r0, #8]
	
	// Configure Generic Clock Generator 1 with XOSC32K as source
	GCLK_GENCTRL_Type gclk1_genctrl = 
    230c:	22a0      	movs	r2, #160	; 0xa0
    230e:	00d2      	lsls	r2, r2, #3
    2310:	431a      	orrs	r2, r3
    2312:	2380      	movs	r3, #128	; 0x80
    2314:	025b      	lsls	r3, r3, #9
    2316:	431a      	orrs	r2, r3
    2318:	2380      	movs	r3, #128	; 0x80
    231a:	029b      	lsls	r3, r3, #10
    231c:	4313      	orrs	r3, r2
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x05,		/* Generator source: XOSC32K output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K			/* Generator ID: 1 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk1_genctrl.reg;
    231e:	6043      	str	r3, [r0, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    2320:	4b3e      	ldr	r3, [pc, #248]	; (241c <ClocksInit+0x14c>)
    2322:	785b      	ldrb	r3, [r3, #1]
    2324:	09db      	lsrs	r3, r3, #7
    2326:	d1fb      	bne.n	2320 <ClocksInit+0x50>
		.bit.CLKEN = 1,			/* Enable the Generic Clock */
		.bit.GEN = GENERIC_CLOCK_GENERATOR_XOSC32K, 	/* Generic Clock Generator 1 is the source */
		.bit.ID = 0x00			/* Generic Clock Multiplexer 0 (DFLL48M Reference) */
	};
	// Write these settings
	GCLK->CLKCTRL.reg = gclk_clkctrl.reg;
    2328:	2380      	movs	r3, #128	; 0x80
    232a:	01db      	lsls	r3, r3, #7
    232c:	2280      	movs	r2, #128	; 0x80
    232e:	0052      	lsls	r2, r2, #1
    2330:	4313      	orrs	r3, r2
    2332:	4a3a      	ldr	r2, [pc, #232]	; (241c <ClocksInit+0x14c>)
    2334:	8053      	strh	r3, [r2, #2]
	// Enable the DFLL48M in open loop mode. Without this step, attempts to go into closed loop mode at 48 MHz will
	// result in Processor Reset (you'll be at the in the Reset_Handler in startup_samd21.c).
	// PCLKSR.DFLLRDY must be one before writing to the DFLL Control register
	// Note that the DFLLRDY bit represents status of register synchronization - NOT clock stability
	// (see Data Sheet 17.6.14 Synchronization for detail)
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    2336:	4b38      	ldr	r3, [pc, #224]	; (2418 <ClocksInit+0x148>)
    2338:	68db      	ldr	r3, [r3, #12]
    233a:	06db      	lsls	r3, r3, #27
    233c:	d5fb      	bpl.n	2336 <ClocksInit+0x66>
	SYSCTRL->DFLLCTRL.reg = (uint16_t)(SYSCTRL_DFLLCTRL_ENABLE);
    233e:	2202      	movs	r2, #2
    2340:	4b35      	ldr	r3, [pc, #212]	; (2418 <ClocksInit+0x148>)
    2342:	849a      	strh	r2, [r3, #36]	; 0x24
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    2344:	4b34      	ldr	r3, [pc, #208]	; (2418 <ClocksInit+0x148>)
    2346:	68db      	ldr	r3, [r3, #12]
    2348:	06db      	lsls	r3, r3, #27
    234a:	d5fb      	bpl.n	2344 <ClocksInit+0x74>
	
	// Set up the Multiplier, Coarse and Fine steps
	SYSCTRL_DFLLMUL_Type sysctrl_dfllmul = 
    234c:	4b34      	ldr	r3, [pc, #208]	; (2420 <ClocksInit+0x150>)
    234e:	4a35      	ldr	r2, [pc, #212]	; (2424 <ClocksInit+0x154>)
    2350:	431a      	orrs	r2, r3
    2352:	23f8      	movs	r3, #248	; 0xf8
    2354:	05db      	lsls	r3, r3, #23
    2356:	4313      	orrs	r3, r2
		.bit.CSTEP = 31,		/* Coarse step - use half of the max value (63) */
		.bit.FSTEP = 511,		/* Fine step - use half of the max value (1023) */
		.bit.MUL = 1465			/* Multiplier = MAIN_CLK_FREQ (48MHz) / EXT_32K_CLK_FREQ (32768 Hz) */
	};
	// Write these settings
	SYSCTRL->DFLLMUL.reg = sysctrl_dfllmul.reg;
    2358:	4a2f      	ldr	r2, [pc, #188]	; (2418 <ClocksInit+0x148>)
    235a:	62d3      	str	r3, [r2, #44]	; 0x2c
	// Wait for synchronization
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    235c:	4b2e      	ldr	r3, [pc, #184]	; (2418 <ClocksInit+0x148>)
    235e:	68db      	ldr	r3, [r3, #12]
    2360:	06db      	lsls	r3, r3, #27
    2362:	d5fb      	bpl.n	235c <ClocksInit+0x8c>
	
	// To reduce lock time, load factory calibrated values into DFLLVAL (cf. Data Sheet 17.6.7.1)
	// Location of value is defined in Data Sheet Table 10-5. NVM Software Calibration Area Mapping
	
	// Get factory calibrated value for "DFLL48M COARSE CAL" from NVM Software Calibration Area
	tempDFLL48CalibrationCoarse = *(uint32_t*)FUSES_DFLL48M_COARSE_CAL_ADDR;
    2364:	4b30      	ldr	r3, [pc, #192]	; (2428 <ClocksInit+0x158>)
    2366:	681a      	ldr	r2, [r3, #0]
	tempDFLL48CalibrationCoarse &= FUSES_DFLL48M_COARSE_CAL_Msk;
	tempDFLL48CalibrationCoarse = tempDFLL48CalibrationCoarse>>FUSES_DFLL48M_COARSE_CAL_Pos;
	// Write the coarse calibration value
	SYSCTRL->DFLLVAL.bit.COARSE = tempDFLL48CalibrationCoarse;
    2368:	492b      	ldr	r1, [pc, #172]	; (2418 <ClocksInit+0x148>)
    236a:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    236c:	0e92      	lsrs	r2, r2, #26
    236e:	0292      	lsls	r2, r2, #10
    2370:	482e      	ldr	r0, [pc, #184]	; (242c <ClocksInit+0x15c>)
    2372:	4003      	ands	r3, r0
    2374:	4313      	orrs	r3, r2
    2376:	628b      	str	r3, [r1, #40]	; 0x28
	// Switch DFLL48M to Closed Loop mode and enable WAITLOCK
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    2378:	4b27      	ldr	r3, [pc, #156]	; (2418 <ClocksInit+0x148>)
    237a:	68db      	ldr	r3, [r3, #12]
    237c:	06db      	lsls	r3, r3, #27
    237e:	d5fb      	bpl.n	2378 <ClocksInit+0xa8>
	SYSCTRL->DFLLCTRL.reg |= (uint16_t) (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_WAITLOCK);
    2380:	4a25      	ldr	r2, [pc, #148]	; (2418 <ClocksInit+0x148>)
    2382:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    2384:	492a      	ldr	r1, [pc, #168]	; (2430 <ClocksInit+0x160>)
    2386:	430b      	orrs	r3, r1
    2388:	8493      	strh	r3, [r2, #36]	; 0x24
		.bit.IDC = 1,			/* Generator duty cycle is 50/50 */
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x07,		/* Generator source: DFLL48M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_MAIN			/* Generator ID: 0 */
	};
	GCLK->GENCTRL.reg = gclk_genctrl0.reg;
    238a:	4824      	ldr	r0, [pc, #144]	; (241c <ClocksInit+0x14c>)
    238c:	2380      	movs	r3, #128	; 0x80
    238e:	031b      	lsls	r3, r3, #12
    2390:	2280      	movs	r2, #128	; 0x80
    2392:	0292      	lsls	r2, r2, #10
    2394:	2180      	movs	r1, #128	; 0x80
    2396:	0249      	lsls	r1, r1, #9
    2398:	24e0      	movs	r4, #224	; 0xe0
    239a:	00e4      	lsls	r4, r4, #3
    239c:	4321      	orrs	r1, r4
    239e:	430a      	orrs	r2, r1
    23a0:	4313      	orrs	r3, r2
    23a2:	6043      	str	r3, [r0, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    23a4:	4b1d      	ldr	r3, [pc, #116]	; (241c <ClocksInit+0x14c>)
    23a6:	785b      	ldrb	r3, [r3, #1]
    23a8:	09db      	lsrs	r3, r3, #7
    23aa:	d1fb      	bne.n	23a4 <ClocksInit+0xd4>
		.bit.PMUX = 7,			/* Peripheral Function H selected (GCLK_IO[0]) */
		.bit.PMUXEN = 1,		/* Enable peripheral Multiplexer */
		.bit.PINMASK = (uint16_t)(1 << (28-16)) /* Select the pin(s) to be configured */
	};
	// Write these settings
	PORT->Group[0].WRCONFIG.reg = port0_wrconfig.reg;
    23ac:	4c21      	ldr	r4, [pc, #132]	; (2434 <ClocksInit+0x164>)
    23ae:	2380      	movs	r3, #128	; 0x80
    23b0:	061b      	lsls	r3, r3, #24
    23b2:	2280      	movs	r2, #128	; 0x80
    23b4:	05d2      	lsls	r2, r2, #23
    23b6:	2180      	movs	r1, #128	; 0x80
    23b8:	0549      	lsls	r1, r1, #21
    23ba:	20e0      	movs	r0, #224	; 0xe0
    23bc:	04c0      	lsls	r0, r0, #19
    23be:	2588      	movs	r5, #136	; 0x88
    23c0:	026d      	lsls	r5, r5, #9
    23c2:	4328      	orrs	r0, r5
    23c4:	4301      	orrs	r1, r0
    23c6:	430a      	orrs	r2, r1
    23c8:	4313      	orrs	r3, r2
    23ca:	62a3      	str	r3, [r4, #40]	; 0x28
	
	/* ----------------------------------------------------------------------------------------------
	* 7) Modify prescaler value of OSC8M to produce 8MHz output
	*/

	SYSCTRL->OSC8M.bit.PRESC = 0;		/* Prescale by 1 */
    23cc:	4b12      	ldr	r3, [pc, #72]	; (2418 <ClocksInit+0x148>)
    23ce:	6a1a      	ldr	r2, [r3, #32]
    23d0:	4919      	ldr	r1, [pc, #100]	; (2438 <ClocksInit+0x168>)
    23d2:	400a      	ands	r2, r1
    23d4:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;	/* Oscillator is always on if enabled */
    23d6:	6a1a      	ldr	r2, [r3, #32]
    23d8:	2180      	movs	r1, #128	; 0x80
    23da:	438a      	bics	r2, r1
    23dc:	621a      	str	r2, [r3, #32]
	* 8) Put OSC8M as source for Generic Clock Generator 3
	*/
	
	// Set the Generic Clock Generator 3 output divider to 1
	// Configure GCLK->GENDIV settings
	GCLK_GENDIV_Type gclk3_gendiv = 
    23de:	2303      	movs	r3, #3
    23e0:	3180      	adds	r1, #128	; 0x80
    23e2:	4319      	orrs	r1, r3
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M		/* Apply division factor to Generator 3 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk3_gendiv.reg;
    23e4:	480d      	ldr	r0, [pc, #52]	; (241c <ClocksInit+0x14c>)
    23e6:	6081      	str	r1, [r0, #8]
	
	// Configure Generic Clock Generator 3 with OSC8M as source
	GCLK_GENCTRL_Type gclk3_genctrl = 
    23e8:	22c0      	movs	r2, #192	; 0xc0
    23ea:	00d2      	lsls	r2, r2, #3
    23ec:	431a      	orrs	r2, r3
    23ee:	2380      	movs	r3, #128	; 0x80
    23f0:	025b      	lsls	r3, r3, #9
    23f2:	431a      	orrs	r2, r3
    23f4:	2380      	movs	r3, #128	; 0x80
    23f6:	029b      	lsls	r3, r3, #10
    23f8:	4313      	orrs	r3, r2
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x06,		/* Generator source: OSC8M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M			/* Generator ID: 3 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk3_genctrl.reg;
    23fa:	6043      	str	r3, [r0, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    23fc:	4b07      	ldr	r3, [pc, #28]	; (241c <ClocksInit+0x14c>)
    23fe:	785b      	ldrb	r3, [r3, #1]
    2400:	09db      	lsrs	r3, r3, #7
    2402:	d1fb      	bne.n	23fc <ClocksInit+0x12c>
	
	/* ----------------------------------------------------------------------------------------------
	* 9) Set CPU and APBx BUS Clocks to 48MHz
	*/
	PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
    2404:	4b0d      	ldr	r3, [pc, #52]	; (243c <ClocksInit+0x16c>)
    2406:	2200      	movs	r2, #0
    2408:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
    240a:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
    240c:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
    240e:	72da      	strb	r2, [r3, #11]
	
    2410:	bd30      	pop	{r4, r5, pc}
    2412:	46c0      	nop			; (mov r8, r8)
    2414:	41004000 	.word	0x41004000
    2418:	40000800 	.word	0x40000800
    241c:	40000c00 	.word	0x40000c00
    2420:	01ff0000 	.word	0x01ff0000
    2424:	000005b9 	.word	0x000005b9
    2428:	00806024 	.word	0x00806024
    242c:	ffff03ff 	.word	0xffff03ff
    2430:	00000804 	.word	0x00000804
    2434:	41004400 	.word	0x41004400
    2438:	fffffcff 	.word	0xfffffcff
    243c:	40000400 	.word	0x40000400

00002440 <delay_n_cycles>:
 *
 ******************************************************************************/

void delay_n_cycles(unsigned long n)
{
	__asm (
    2440:	f3bf 8f5f 	dmb	sy
    2444:	3801      	subs	r0, #1
    2446:	2800      	cmp	r0, #0
    2448:	d1fa      	bne.n	2440 <delay_n_cycles>
	"loop: DMB	\r\n"
	"SUB r0, r0, #1 \r\n"
	"CMP r0, #0  \r\n"
	"BNE loop         "
	);
} // delay_n_cycles()
    244a:	4770      	bx	lr

0000244c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    244c:	e7fe      	b.n	244c <Dummy_Handler>
	...

00002450 <Reset_Handler>:
{
    2450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
    2452:	4a23      	ldr	r2, [pc, #140]	; (24e0 <Reset_Handler+0x90>)
    2454:	4b23      	ldr	r3, [pc, #140]	; (24e4 <Reset_Handler+0x94>)
    2456:	429a      	cmp	r2, r3
    2458:	d009      	beq.n	246e <Reset_Handler+0x1e>
    245a:	4b22      	ldr	r3, [pc, #136]	; (24e4 <Reset_Handler+0x94>)
    245c:	4a20      	ldr	r2, [pc, #128]	; (24e0 <Reset_Handler+0x90>)
    245e:	e003      	b.n	2468 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
    2460:	6811      	ldr	r1, [r2, #0]
    2462:	6019      	str	r1, [r3, #0]
    2464:	3304      	adds	r3, #4
    2466:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    2468:	491f      	ldr	r1, [pc, #124]	; (24e8 <Reset_Handler+0x98>)
    246a:	428b      	cmp	r3, r1
    246c:	d3f8      	bcc.n	2460 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
    246e:	4b1f      	ldr	r3, [pc, #124]	; (24ec <Reset_Handler+0x9c>)
    2470:	e002      	b.n	2478 <Reset_Handler+0x28>
                *pDest++ = 0;
    2472:	2200      	movs	r2, #0
    2474:	601a      	str	r2, [r3, #0]
    2476:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
    2478:	4a1d      	ldr	r2, [pc, #116]	; (24f0 <Reset_Handler+0xa0>)
    247a:	4293      	cmp	r3, r2
    247c:	d3f9      	bcc.n	2472 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    247e:	4a1d      	ldr	r2, [pc, #116]	; (24f4 <Reset_Handler+0xa4>)
    2480:	21ff      	movs	r1, #255	; 0xff
    2482:	4b1d      	ldr	r3, [pc, #116]	; (24f8 <Reset_Handler+0xa8>)
    2484:	438b      	bics	r3, r1
    2486:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    2488:	39fd      	subs	r1, #253	; 0xfd
    248a:	2390      	movs	r3, #144	; 0x90
    248c:	005b      	lsls	r3, r3, #1
    248e:	4a1b      	ldr	r2, [pc, #108]	; (24fc <Reset_Handler+0xac>)
    2490:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    2492:	4a1b      	ldr	r2, [pc, #108]	; (2500 <Reset_Handler+0xb0>)
    2494:	78d3      	ldrb	r3, [r2, #3]
    2496:	2503      	movs	r5, #3
    2498:	43ab      	bics	r3, r5
    249a:	2402      	movs	r4, #2
    249c:	4323      	orrs	r3, r4
    249e:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    24a0:	78d3      	ldrb	r3, [r2, #3]
    24a2:	270c      	movs	r7, #12
    24a4:	43bb      	bics	r3, r7
    24a6:	2608      	movs	r6, #8
    24a8:	4333      	orrs	r3, r6
    24aa:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    24ac:	4b15      	ldr	r3, [pc, #84]	; (2504 <Reset_Handler+0xb4>)
    24ae:	7b98      	ldrb	r0, [r3, #14]
    24b0:	2230      	movs	r2, #48	; 0x30
    24b2:	4390      	bics	r0, r2
    24b4:	2220      	movs	r2, #32
    24b6:	4310      	orrs	r0, r2
    24b8:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    24ba:	7b99      	ldrb	r1, [r3, #14]
    24bc:	43b9      	bics	r1, r7
    24be:	4331      	orrs	r1, r6
    24c0:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    24c2:	7b9a      	ldrb	r2, [r3, #14]
    24c4:	43aa      	bics	r2, r5
    24c6:	4322      	orrs	r2, r4
    24c8:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    24ca:	4a0f      	ldr	r2, [pc, #60]	; (2508 <Reset_Handler+0xb8>)
    24cc:	6851      	ldr	r1, [r2, #4]
    24ce:	2380      	movs	r3, #128	; 0x80
    24d0:	430b      	orrs	r3, r1
    24d2:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    24d4:	4b0d      	ldr	r3, [pc, #52]	; (250c <Reset_Handler+0xbc>)
    24d6:	4798      	blx	r3
        main();
    24d8:	4b0d      	ldr	r3, [pc, #52]	; (2510 <Reset_Handler+0xc0>)
    24da:	4798      	blx	r3
    24dc:	e7fe      	b.n	24dc <Reset_Handler+0x8c>
    24de:	46c0      	nop			; (mov r8, r8)
    24e0:	00005500 	.word	0x00005500
    24e4:	20000000 	.word	0x20000000
    24e8:	2000043c 	.word	0x2000043c
    24ec:	2000043c 	.word	0x2000043c
    24f0:	20000aec 	.word	0x20000aec
    24f4:	e000ed00 	.word	0xe000ed00
    24f8:	00002000 	.word	0x00002000
    24fc:	41007000 	.word	0x41007000
    2500:	41005000 	.word	0x41005000
    2504:	41004800 	.word	0x41004800
    2508:	41004000 	.word	0x41004000
    250c:	00004c8d 	.word	0x00004c8d
    2510:	00003d45 	.word	0x00003d45

00002514 <disk_status>:
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status ( BYTE pdrv) /* Physical drive number to identify the drive */
{
     if(pdrv)
    2514:	2800      	cmp	r0, #0
    2516:	d101      	bne.n	251c <disk_status+0x8>
    {
        return STA_NOINIT;
    }
    return RES_OK;
    2518:	2000      	movs	r0, #0
}
    251a:	4770      	bx	lr
        return STA_NOINIT;
    251c:	2001      	movs	r0, #1
    251e:	e7fc      	b.n	251a <disk_status+0x6>

00002520 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(BYTE pdrv)
{
    2520:	b510      	push	{r4, lr}
	DSTATUS stat;
	if (pdrv != DEV_MMC) {
    2522:	2801      	cmp	r0, #1
    2524:	d001      	beq.n	252a <disk_initialize+0xa>
		return STA_NOINIT; // Only handle the SD card
    2526:	2001      	movs	r0, #1
		} else if (stat != 0) {
		return STA_NOINIT;
		} else {
		return RES_OK; // Successfully initialized
	}
}
    2528:	bd10      	pop	{r4, pc}
	stat = SDCard_Init();  // Call SD card initialization function
    252a:	4b04      	ldr	r3, [pc, #16]	; (253c <disk_initialize+0x1c>)
    252c:	4798      	blx	r3
	if (stat == STA_NODISK) {
    252e:	2802      	cmp	r0, #2
    2530:	d0fa      	beq.n	2528 <disk_initialize+0x8>
		} else if (stat != 0) {
    2532:	2800      	cmp	r0, #0
    2534:	d0f8      	beq.n	2528 <disk_initialize+0x8>
		return STA_NOINIT;
    2536:	2001      	movs	r0, #1
    2538:	e7f6      	b.n	2528 <disk_initialize+0x8>
    253a:	46c0      	nop			; (mov r8, r8)
    253c:	00003f01 	.word	0x00003f01

00002540 <disk_read>:
	BYTE pdrv,                                /* Physical drive number to identify the drive */
	BYTE *buff,                               /* Data buffer to store read data */
	DWORD sector,        /* Sector address in LBA */
	UINT count                               /* Number of sectors to read */
)
{
    2540:	b570      	push	{r4, r5, r6, lr}
    2542:	000e      	movs	r6, r1
    2544:	0015      	movs	r5, r2
    2546:	001c      	movs	r4, r3
    DRESULT res;
    if (pdrv || !count)
    2548:	2800      	cmp	r0, #0
    254a:	d001      	beq.n	2550 <disk_read+0x10>
    {
        return RES_PARERR;
    254c:	2004      	movs	r0, #4
    }
    else
    {
        return RES_ERROR;
    }
}
    254e:	bd70      	pop	{r4, r5, r6, pc}
    if (pdrv || !count)
    2550:	2b00      	cmp	r3, #0
    2552:	d101      	bne.n	2558 <disk_read+0x18>
        return RES_PARERR;
    2554:	2004      	movs	r0, #4
    2556:	e7fa      	b.n	254e <disk_read+0xe>
		if (count == 1)
    2558:	2b01      	cmp	r3, #1
    255a:	d00b      	beq.n	2574 <disk_read+0x34>
			UART3_Write_Text("read 2 \r\n");
    255c:	4807      	ldr	r0, [pc, #28]	; (257c <disk_read+0x3c>)
    255e:	4b08      	ldr	r3, [pc, #32]	; (2580 <disk_read+0x40>)
    2560:	4798      	blx	r3
			res = SDCard_ReadMultipleBlock(sector,buff,count);
    2562:	b2e2      	uxtb	r2, r4
    2564:	0031      	movs	r1, r6
    2566:	0028      	movs	r0, r5
    2568:	4b06      	ldr	r3, [pc, #24]	; (2584 <disk_read+0x44>)
    256a:	4798      	blx	r3
    if(res == 0x00)
    256c:	2800      	cmp	r0, #0
    256e:	d0ee      	beq.n	254e <disk_read+0xe>
        return RES_ERROR;
    2570:	2001      	movs	r0, #1
    2572:	e7ec      	b.n	254e <disk_read+0xe>
			res = SDCard_ReadSingleBlock(sector,buff);
    2574:	0010      	movs	r0, r2
    2576:	4b04      	ldr	r3, [pc, #16]	; (2588 <disk_read+0x48>)
    2578:	4798      	blx	r3
    257a:	e7f7      	b.n	256c <disk_read+0x2c>
    257c:	00005080 	.word	0x00005080
    2580:	00004771 	.word	0x00004771
    2584:	0000424d 	.word	0x0000424d
    2588:	00004185 	.word	0x00004185

0000258c <disk_write>:
	BYTE pdrv,             /* Physical drive number to identify the drive */
	const BYTE *buff,      /* Data to be written */
	DWORD sector,          /* Sector address in LBA */
	UINT count             /* Number of sectors to write */
)
{
    258c:	b570      	push	{r4, r5, r6, lr}
    258e:	000e      	movs	r6, r1
    2590:	0015      	movs	r5, r2
    2592:	001c      	movs	r4, r3
    DRESULT res;
    if (pdrv || !count) {
    2594:	2800      	cmp	r0, #0
    2596:	d001      	beq.n	259c <disk_write+0x10>
	    return RES_PARERR;
    2598:	2004      	movs	r0, #4
    else
    {
	    return RES_ERROR;
    }

}
    259a:	bd70      	pop	{r4, r5, r6, pc}
    if (pdrv || !count) {
    259c:	2b00      	cmp	r3, #0
    259e:	d101      	bne.n	25a4 <disk_write+0x18>
	    return RES_PARERR;
    25a0:	2004      	movs	r0, #4
    25a2:	e7fa      	b.n	259a <disk_write+0xe>
    if (count == 1)
    25a4:	2b01      	cmp	r3, #1
    25a6:	d00b      	beq.n	25c0 <disk_write+0x34>
	    UART3_Write_Text("write 2 \r\n");
    25a8:	4809      	ldr	r0, [pc, #36]	; (25d0 <disk_write+0x44>)
    25aa:	4b0a      	ldr	r3, [pc, #40]	; (25d4 <disk_write+0x48>)
    25ac:	4798      	blx	r3
	    res = SDCard_WriteMultipleBlock(sector, (const uint8_t*)buff, count);
    25ae:	b2e2      	uxtb	r2, r4
    25b0:	0031      	movs	r1, r6
    25b2:	0028      	movs	r0, r5
    25b4:	4b08      	ldr	r3, [pc, #32]	; (25d8 <disk_write+0x4c>)
    25b6:	4798      	blx	r3
    if (res == 0)
    25b8:	2800      	cmp	r0, #0
    25ba:	d0ee      	beq.n	259a <disk_write+0xe>
	    return RES_ERROR;
    25bc:	2001      	movs	r0, #1
    25be:	e7ec      	b.n	259a <disk_write+0xe>
	    UART3_Write_Text("write 1 \r\n");
    25c0:	4806      	ldr	r0, [pc, #24]	; (25dc <disk_write+0x50>)
    25c2:	4b04      	ldr	r3, [pc, #16]	; (25d4 <disk_write+0x48>)
    25c4:	4798      	blx	r3
	    res = SDCard_WriteSingleBlock(sector, buff);
    25c6:	0031      	movs	r1, r6
    25c8:	0028      	movs	r0, r5
    25ca:	4b05      	ldr	r3, [pc, #20]	; (25e0 <disk_write+0x54>)
    25cc:	4798      	blx	r3
    25ce:	e7f3      	b.n	25b8 <disk_write+0x2c>
    25d0:	00005098 	.word	0x00005098
    25d4:	00004771 	.word	0x00004771
    25d8:	000043bd 	.word	0x000043bd
    25dc:	0000508c 	.word	0x0000508c
    25e0:	000042d9 	.word	0x000042d9

000025e4 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,               /* Physical drive number (0..) */
	BYTE cmd,                /* Control code */
	void *buff               /* Buffer to send/receive control data */
)
{
    25e4:	b510      	push	{r4, lr}
    25e6:	b084      	sub	sp, #16
    25e8:	0014      	movs	r4, r2
	DRESULT res;
	BYTE n, csd[16];
	DWORD csize;

	if (pdrv)
    25ea:	2800      	cmp	r0, #0
    25ec:	d002      	beq.n	25f4 <disk_ioctl+0x10>
	{
		 return RES_PARERR;
    25ee:	2004      	movs	r0, #4
		
		default:
		 res = RES_PARERR; break;
	}
	return res;
}
    25f0:	b004      	add	sp, #16
    25f2:	bd10      	pop	{r4, pc}
	switch (cmd)
    25f4:	2901      	cmp	r1, #1
    25f6:	d009      	beq.n	260c <disk_ioctl+0x28>
    25f8:	2900      	cmp	r1, #0
    25fa:	d005      	beq.n	2608 <disk_ioctl+0x24>
    25fc:	2902      	cmp	r1, #2
    25fe:	d049      	beq.n	2694 <disk_ioctl+0xb0>
    2600:	2903      	cmp	r1, #3
    2602:	d04c      	beq.n	269e <disk_ioctl+0xba>
		 res = RES_PARERR; break;
    2604:	2004      	movs	r0, #4
    2606:	e7f3      	b.n	25f0 <disk_ioctl+0xc>
		case CTRL_SYNC        : res = RES_OK; break;
    2608:	2000      	movs	r0, #0
    260a:	e7f1      	b.n	25f0 <disk_ioctl+0xc>
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
    260c:	2295      	movs	r2, #149	; 0x95
    260e:	2100      	movs	r1, #0
    2610:	2049      	movs	r0, #73	; 0x49
    2612:	4b35      	ldr	r3, [pc, #212]	; (26e8 <disk_ioctl+0x104>)
    2614:	4798      	blx	r3
    2616:	2800      	cmp	r0, #0
    2618:	d001      	beq.n	261e <disk_ioctl+0x3a>
	res = RES_ERROR;
    261a:	2001      	movs	r0, #1
    261c:	e7e8      	b.n	25f0 <disk_ioctl+0xc>
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
    261e:	4669      	mov	r1, sp
    2620:	3049      	adds	r0, #73	; 0x49
    2622:	4b32      	ldr	r3, [pc, #200]	; (26ec <disk_ioctl+0x108>)
    2624:	4798      	blx	r3
    2626:	2800      	cmp	r0, #0
    2628:	d05a      	beq.n	26e0 <disk_ioctl+0xfc>
					if((csd[0] >> 6) == 1) /* SDC ver 2.00 */
    262a:	466b      	mov	r3, sp
    262c:	781b      	ldrb	r3, [r3, #0]
    262e:	099b      	lsrs	r3, r3, #6
    2630:	2b01      	cmp	r3, #1
    2632:	d024      	beq.n	267e <disk_ioctl+0x9a>
						n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    2634:	466b      	mov	r3, sp
    2636:	795a      	ldrb	r2, [r3, #5]
    2638:	230f      	movs	r3, #15
    263a:	4013      	ands	r3, r2
    263c:	466a      	mov	r2, sp
    263e:	7a92      	ldrb	r2, [r2, #10]
    2640:	09d2      	lsrs	r2, r2, #7
    2642:	189b      	adds	r3, r3, r2
    2644:	466a      	mov	r2, sp
    2646:	7a51      	ldrb	r1, [r2, #9]
    2648:	0049      	lsls	r1, r1, #1
    264a:	2206      	movs	r2, #6
    264c:	400a      	ands	r2, r1
    264e:	189b      	adds	r3, r3, r2
    2650:	b2db      	uxtb	r3, r3
    2652:	3302      	adds	r3, #2
    2654:	b2db      	uxtb	r3, r3
						csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    2656:	466a      	mov	r2, sp
    2658:	7a12      	ldrb	r2, [r2, #8]
    265a:	0992      	lsrs	r2, r2, #6
    265c:	4669      	mov	r1, sp
    265e:	79c9      	ldrb	r1, [r1, #7]
    2660:	0089      	lsls	r1, r1, #2
    2662:	1852      	adds	r2, r2, r1
    2664:	4669      	mov	r1, sp
    2666:	7989      	ldrb	r1, [r1, #6]
    2668:	0289      	lsls	r1, r1, #10
    266a:	20c0      	movs	r0, #192	; 0xc0
    266c:	0100      	lsls	r0, r0, #4
    266e:	4001      	ands	r1, r0
    2670:	1852      	adds	r2, r2, r1
    2672:	3201      	adds	r2, #1
						*(DWORD*)buff = (DWORD)csize << (n - 9);
    2674:	3b09      	subs	r3, #9
    2676:	409a      	lsls	r2, r3
    2678:	6022      	str	r2, [r4, #0]
					res = RES_OK;
    267a:	2000      	movs	r0, #0
    267c:	e7b8      	b.n	25f0 <disk_ioctl+0xc>
						csize = csd[9] + ((WORD)csd[8] << 8) + 1;
    267e:	466b      	mov	r3, sp
    2680:	7a5b      	ldrb	r3, [r3, #9]
    2682:	466a      	mov	r2, sp
    2684:	7a12      	ldrb	r2, [r2, #8]
    2686:	0212      	lsls	r2, r2, #8
    2688:	189b      	adds	r3, r3, r2
    268a:	3301      	adds	r3, #1
						*(DWORD*)buff = (DWORD)csize << 10;
    268c:	029b      	lsls	r3, r3, #10
    268e:	6023      	str	r3, [r4, #0]
					res = RES_OK;
    2690:	2000      	movs	r0, #0
    2692:	e7ad      	b.n	25f0 <disk_ioctl+0xc>
				*(WORD*)buff = 512;
    2694:	2380      	movs	r3, #128	; 0x80
    2696:	009b      	lsls	r3, r3, #2
    2698:	8013      	strh	r3, [r2, #0]
				res = RES_OK;
    269a:	2000      	movs	r0, #0
				break;
    269c:	e7a8      	b.n	25f0 <disk_ioctl+0xc>
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
    269e:	2295      	movs	r2, #149	; 0x95
    26a0:	2100      	movs	r1, #0
    26a2:	2049      	movs	r0, #73	; 0x49
    26a4:	4b10      	ldr	r3, [pc, #64]	; (26e8 <disk_ioctl+0x104>)
    26a6:	4798      	blx	r3
    26a8:	2800      	cmp	r0, #0
    26aa:	d001      	beq.n	26b0 <disk_ioctl+0xcc>
	res = RES_ERROR;
    26ac:	2001      	movs	r0, #1
    26ae:	e79f      	b.n	25f0 <disk_ioctl+0xc>
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
    26b0:	4669      	mov	r1, sp
    26b2:	3049      	adds	r0, #73	; 0x49
    26b4:	4b0d      	ldr	r3, [pc, #52]	; (26ec <disk_ioctl+0x108>)
    26b6:	4798      	blx	r3
    26b8:	2800      	cmp	r0, #0
    26ba:	d013      	beq.n	26e4 <disk_ioctl+0x100>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
    26bc:	466b      	mov	r3, sp
    26be:	7a9a      	ldrb	r2, [r3, #10]
    26c0:	0052      	lsls	r2, r2, #1
    26c2:	237e      	movs	r3, #126	; 0x7e
    26c4:	4013      	ands	r3, r2
    26c6:	466a      	mov	r2, sp
    26c8:	7ad2      	ldrb	r2, [r2, #11]
    26ca:	09d2      	lsrs	r2, r2, #7
    26cc:	189b      	adds	r3, r3, r2
    26ce:	3301      	adds	r3, #1
    26d0:	466a      	mov	r2, sp
    26d2:	7b52      	ldrb	r2, [r2, #13]
    26d4:	0992      	lsrs	r2, r2, #6
    26d6:	3a01      	subs	r2, #1
    26d8:	4093      	lsls	r3, r2
    26da:	6023      	str	r3, [r4, #0]
					res = RES_OK;
    26dc:	2000      	movs	r0, #0
    26de:	e787      	b.n	25f0 <disk_ioctl+0xc>
	res = RES_ERROR;
    26e0:	2001      	movs	r0, #1
    26e2:	e785      	b.n	25f0 <disk_ioctl+0xc>
    26e4:	2001      	movs	r0, #1
    26e6:	e783      	b.n	25f0 <disk_ioctl+0xc>
    26e8:	00003e11 	.word	0x00003e11
    26ec:	0000414d 	.word	0x0000414d

000026f0 <get_fattime>:

// FATTIME Work around
DWORD get_fattime (void)
{
	return 0;
}
    26f0:	2000      	movs	r0, #0
    26f2:	4770      	bx	lr

000026f4 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    26f4:	e004      	b.n	2700 <mem_cpy+0xc>
		*d++ = *s++;
    26f6:	780a      	ldrb	r2, [r1, #0]
    26f8:	7002      	strb	r2, [r0, #0]
    26fa:	3101      	adds	r1, #1
    26fc:	3001      	adds	r0, #1
	while (cnt--)
    26fe:	001a      	movs	r2, r3
    2700:	1e53      	subs	r3, r2, #1
    2702:	2a00      	cmp	r2, #0
    2704:	d1f7      	bne.n	26f6 <mem_cpy+0x2>
}
    2706:	4770      	bx	lr

00002708 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    2708:	e002      	b.n	2710 <mem_set+0x8>
		*d++ = (BYTE)val;
    270a:	7001      	strb	r1, [r0, #0]
    270c:	3001      	adds	r0, #1
	while (cnt--)
    270e:	001a      	movs	r2, r3
    2710:	1e53      	subs	r3, r2, #1
    2712:	2a00      	cmp	r2, #0
    2714:	d1f9      	bne.n	270a <mem_set+0x2>
}
    2716:	4770      	bx	lr

00002718 <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
    2718:	b570      	push	{r4, r5, r6, lr}
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    271a:	0003      	movs	r3, r0
	int r = 0;
    271c:	2000      	movs	r0, #0

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    271e:	e001      	b.n	2724 <mem_cmp+0xc>
    2720:	0029      	movs	r1, r5
    2722:	0033      	movs	r3, r6
    2724:	1e54      	subs	r4, r2, #1
    2726:	2a00      	cmp	r2, #0
    2728:	d007      	beq.n	273a <mem_cmp+0x22>
    272a:	1c5e      	adds	r6, r3, #1
    272c:	7818      	ldrb	r0, [r3, #0]
    272e:	1c4d      	adds	r5, r1, #1
    2730:	780b      	ldrb	r3, [r1, #0]
    2732:	1ac0      	subs	r0, r0, r3
    2734:	0022      	movs	r2, r4
    2736:	2800      	cmp	r0, #0
    2738:	d0f2      	beq.n	2720 <mem_cmp+0x8>
	return r;
}
    273a:	bd70      	pop	{r4, r5, r6, pc}

0000273c <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    273c:	e000      	b.n	2740 <chk_chr+0x4>
    273e:	3001      	adds	r0, #1
    2740:	7803      	ldrb	r3, [r0, #0]
    2742:	2b00      	cmp	r3, #0
    2744:	d001      	beq.n	274a <chk_chr+0xe>
    2746:	428b      	cmp	r3, r1
    2748:	d1f9      	bne.n	273e <chk_chr+0x2>
	return *str;
}
    274a:	0018      	movs	r0, r3
    274c:	4770      	bx	lr

0000274e <ld_clust>:
static
DWORD ld_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir	/* Pointer to the directory entry */
)
{
    274e:	b510      	push	{r4, lr}
    2750:	0004      	movs	r4, r0
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
    2752:	7eca      	ldrb	r2, [r1, #27]
    2754:	0212      	lsls	r2, r2, #8
    2756:	7e88      	ldrb	r0, [r1, #26]
    2758:	4310      	orrs	r0, r2
	if (fs->fs_type == FS_FAT32)
    275a:	7823      	ldrb	r3, [r4, #0]
    275c:	2b03      	cmp	r3, #3
    275e:	d000      	beq.n	2762 <ld_clust+0x14>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
    2760:	bd10      	pop	{r4, pc}
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
    2762:	7d4a      	ldrb	r2, [r1, #21]
    2764:	0212      	lsls	r2, r2, #8
    2766:	7d0b      	ldrb	r3, [r1, #20]
    2768:	4313      	orrs	r3, r2
    276a:	041b      	lsls	r3, r3, #16
    276c:	4318      	orrs	r0, r3
	return cl;
    276e:	e7f7      	b.n	2760 <ld_clust+0x12>

00002770 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
    2770:	7681      	strb	r1, [r0, #26]
    2772:	b28b      	uxth	r3, r1
    2774:	0a1b      	lsrs	r3, r3, #8
    2776:	76c3      	strb	r3, [r0, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    2778:	0c09      	lsrs	r1, r1, #16
    277a:	7501      	strb	r1, [r0, #20]
    277c:	0a09      	lsrs	r1, r1, #8
    277e:	7541      	strb	r1, [r0, #21]
}
    2780:	4770      	bx	lr
	...

00002784 <create_name>:
static
FRESULT create_name (
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
    2784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2786:	46de      	mov	lr, fp
    2788:	4657      	mov	r7, sl
    278a:	464e      	mov	r6, r9
    278c:	4645      	mov	r5, r8
    278e:	b5e0      	push	{r5, r6, r7, lr}
    2790:	4689      	mov	r9, r1
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2792:	680c      	ldr	r4, [r1, #0]
    2794:	e000      	b.n	2798 <create_name+0x14>
    2796:	3401      	adds	r4, #1
    2798:	7823      	ldrb	r3, [r4, #0]
    279a:	2b2f      	cmp	r3, #47	; 0x2f
    279c:	d0fb      	beq.n	2796 <create_name+0x12>
    279e:	2b5c      	cmp	r3, #92	; 0x5c
    27a0:	d0f9      	beq.n	2796 <create_name+0x12>
	sfn = dp->fn;
    27a2:	6983      	ldr	r3, [r0, #24]
    27a4:	4698      	mov	r8, r3
	mem_set(sfn, ' ', 11);
    27a6:	220b      	movs	r2, #11
    27a8:	2120      	movs	r1, #32
    27aa:	0018      	movs	r0, r3
    27ac:	4b55      	ldr	r3, [pc, #340]	; (2904 <create_name+0x180>)
    27ae:	4798      	blx	r3
	si = i = b = 0; ni = 8;
    27b0:	2600      	movs	r6, #0
    27b2:	2300      	movs	r3, #0
    27b4:	2708      	movs	r7, #8
    27b6:	2200      	movs	r2, #0
    27b8:	4692      	mov	sl, r2
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    27ba:	1c5a      	adds	r2, r3, #1
    27bc:	4693      	mov	fp, r2
    27be:	5ce5      	ldrb	r5, [r4, r3]
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    27c0:	2d20      	cmp	r5, #32
    27c2:	d966      	bls.n	2892 <create_name+0x10e>
    27c4:	2d2f      	cmp	r5, #47	; 0x2f
    27c6:	d064      	beq.n	2892 <create_name+0x10e>
    27c8:	2d5c      	cmp	r5, #92	; 0x5c
    27ca:	d062      	beq.n	2892 <create_name+0x10e>
		if (c == '.' || i >= ni) {
    27cc:	2d2e      	cmp	r5, #46	; 0x2e
    27ce:	d001      	beq.n	27d4 <create_name+0x50>
    27d0:	42b7      	cmp	r7, r6
    27d2:	d813      	bhi.n	27fc <create_name+0x78>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    27d4:	2f08      	cmp	r7, #8
    27d6:	d000      	beq.n	27da <create_name+0x56>
    27d8:	e08c      	b.n	28f4 <create_name+0x170>
    27da:	2d2e      	cmp	r5, #46	; 0x2e
    27dc:	d006      	beq.n	27ec <create_name+0x68>
    27de:	2006      	movs	r0, #6

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */

	return FR_OK;
#endif
}
    27e0:	bc3c      	pop	{r2, r3, r4, r5}
    27e2:	4690      	mov	r8, r2
    27e4:	4699      	mov	r9, r3
    27e6:	46a2      	mov	sl, r4
    27e8:	46ab      	mov	fp, r5
    27ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			b <<= 2; continue;
    27ec:	4653      	mov	r3, sl
    27ee:	009b      	lsls	r3, r3, #2
    27f0:	b2db      	uxtb	r3, r3
    27f2:	469a      	mov	sl, r3
			i = 8; ni = 11;
    27f4:	003e      	movs	r6, r7
		c = (BYTE)p[si++];
    27f6:	465b      	mov	r3, fp
			i = 8; ni = 11;
    27f8:	3703      	adds	r7, #3
			b <<= 2; continue;
    27fa:	e7de      	b.n	27ba <create_name+0x36>
		if (c >= 0x80) {				/* Extended character? */
    27fc:	b26a      	sxtb	r2, r5
    27fe:	2a00      	cmp	r2, #0
    2800:	db1f      	blt.n	2842 <create_name+0xbe>
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2802:	002a      	movs	r2, r5
    2804:	327f      	adds	r2, #127	; 0x7f
    2806:	b2d2      	uxtb	r2, r2
    2808:	2a1e      	cmp	r2, #30
    280a:	d904      	bls.n	2816 <create_name+0x92>
    280c:	002a      	movs	r2, r5
    280e:	3220      	adds	r2, #32
    2810:	b2d2      	uxtb	r2, r2
    2812:	2a1c      	cmp	r2, #28
    2814:	d81b      	bhi.n	284e <create_name+0xca>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2816:	3302      	adds	r3, #2
    2818:	465a      	mov	r2, fp
    281a:	5ca1      	ldrb	r1, [r4, r2]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    281c:	000a      	movs	r2, r1
    281e:	3a40      	subs	r2, #64	; 0x40
    2820:	b2d2      	uxtb	r2, r2
    2822:	2a3e      	cmp	r2, #62	; 0x3e
    2824:	d904      	bls.n	2830 <create_name+0xac>
    2826:	000a      	movs	r2, r1
    2828:	3a80      	subs	r2, #128	; 0x80
    282a:	b2d2      	uxtb	r2, r2
    282c:	2a7c      	cmp	r2, #124	; 0x7c
    282e:	d863      	bhi.n	28f8 <create_name+0x174>
    2830:	1e7a      	subs	r2, r7, #1
    2832:	4296      	cmp	r6, r2
    2834:	d262      	bcs.n	28fc <create_name+0x178>
			sfn[i++] = c;
    2836:	1c72      	adds	r2, r6, #1
    2838:	4640      	mov	r0, r8
    283a:	5585      	strb	r5, [r0, r6]
			sfn[i++] = d;
    283c:	5481      	strb	r1, [r0, r2]
    283e:	3602      	adds	r6, #2
    2840:	e7bb      	b.n	27ba <create_name+0x36>
			b |= 3;						/* Eliminate NT flag */
    2842:	2203      	movs	r2, #3
    2844:	4651      	mov	r1, sl
    2846:	4311      	orrs	r1, r2
    2848:	b2ca      	uxtb	r2, r1
    284a:	4692      	mov	sl, r2
    284c:	e7d9      	b.n	2802 <create_name+0x7e>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    284e:	0029      	movs	r1, r5
    2850:	482d      	ldr	r0, [pc, #180]	; (2908 <create_name+0x184>)
    2852:	4b2e      	ldr	r3, [pc, #184]	; (290c <create_name+0x188>)
    2854:	4798      	blx	r3
    2856:	2800      	cmp	r0, #0
    2858:	d152      	bne.n	2900 <create_name+0x17c>
			if (IsUpper(c)) {			/* ASCII large capital? */
    285a:	002b      	movs	r3, r5
    285c:	3b41      	subs	r3, #65	; 0x41
    285e:	b2db      	uxtb	r3, r3
    2860:	2b19      	cmp	r3, #25
    2862:	d809      	bhi.n	2878 <create_name+0xf4>
				b |= 2;
    2864:	2302      	movs	r3, #2
    2866:	4652      	mov	r2, sl
    2868:	431a      	orrs	r2, r3
    286a:	b2d3      	uxtb	r3, r2
    286c:	469a      	mov	sl, r3
			sfn[i++] = c;
    286e:	4643      	mov	r3, r8
    2870:	559d      	strb	r5, [r3, r6]
    2872:	3601      	adds	r6, #1
		c = (BYTE)p[si++];
    2874:	465b      	mov	r3, fp
    2876:	e7a0      	b.n	27ba <create_name+0x36>
				if (IsLower(c)) {		/* ASCII small capital? */
    2878:	002b      	movs	r3, r5
    287a:	3b61      	subs	r3, #97	; 0x61
    287c:	b2db      	uxtb	r3, r3
    287e:	2b19      	cmp	r3, #25
    2880:	d8f5      	bhi.n	286e <create_name+0xea>
					b |= 1; c -= 0x20;
    2882:	2301      	movs	r3, #1
    2884:	4652      	mov	r2, sl
    2886:	431a      	orrs	r2, r3
    2888:	b2d3      	uxtb	r3, r2
    288a:	469a      	mov	sl, r3
    288c:	3d20      	subs	r5, #32
    288e:	b2ed      	uxtb	r5, r5
    2890:	e7ed      	b.n	286e <create_name+0xea>
	*path = &p[si];						/* Return pointer to the next segment */
    2892:	445c      	add	r4, fp
    2894:	464b      	mov	r3, r9
    2896:	601c      	str	r4, [r3, #0]
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    2898:	2d20      	cmp	r5, #32
    289a:	d804      	bhi.n	28a6 <create_name+0x122>
    289c:	2304      	movs	r3, #4
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    289e:	2e00      	cmp	r6, #0
    28a0:	d103      	bne.n	28aa <create_name+0x126>
    28a2:	2006      	movs	r0, #6
    28a4:	e79c      	b.n	27e0 <create_name+0x5c>
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    28a6:	2300      	movs	r3, #0
    28a8:	e7f9      	b.n	289e <create_name+0x11a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    28aa:	4642      	mov	r2, r8
    28ac:	7812      	ldrb	r2, [r2, #0]
    28ae:	2ae5      	cmp	r2, #229	; 0xe5
    28b0:	d00f      	beq.n	28d2 <create_name+0x14e>
	if (ni == 8) b <<= 2;
    28b2:	2f08      	cmp	r7, #8
    28b4:	d011      	beq.n	28da <create_name+0x156>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    28b6:	2203      	movs	r2, #3
    28b8:	4651      	mov	r1, sl
    28ba:	400a      	ands	r2, r1
    28bc:	2a01      	cmp	r2, #1
    28be:	d011      	beq.n	28e4 <create_name+0x160>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    28c0:	220c      	movs	r2, #12
    28c2:	4651      	mov	r1, sl
    28c4:	400a      	ands	r2, r1
    28c6:	2a04      	cmp	r2, #4
    28c8:	d010      	beq.n	28ec <create_name+0x168>
	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
    28ca:	4642      	mov	r2, r8
    28cc:	72d3      	strb	r3, [r2, #11]
	return FR_OK;
    28ce:	2000      	movs	r0, #0
    28d0:	e786      	b.n	27e0 <create_name+0x5c>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    28d2:	3ae0      	subs	r2, #224	; 0xe0
    28d4:	4641      	mov	r1, r8
    28d6:	700a      	strb	r2, [r1, #0]
    28d8:	e7eb      	b.n	28b2 <create_name+0x12e>
	if (ni == 8) b <<= 2;
    28da:	4652      	mov	r2, sl
    28dc:	0092      	lsls	r2, r2, #2
    28de:	b2d2      	uxtb	r2, r2
    28e0:	4692      	mov	sl, r2
    28e2:	e7e8      	b.n	28b6 <create_name+0x132>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    28e4:	2210      	movs	r2, #16
    28e6:	4313      	orrs	r3, r2
    28e8:	b2db      	uxtb	r3, r3
    28ea:	e7e9      	b.n	28c0 <create_name+0x13c>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    28ec:	2208      	movs	r2, #8
    28ee:	4313      	orrs	r3, r2
    28f0:	b2db      	uxtb	r3, r3
    28f2:	e7ea      	b.n	28ca <create_name+0x146>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    28f4:	2006      	movs	r0, #6
    28f6:	e773      	b.n	27e0 <create_name+0x5c>
				return FR_INVALID_NAME;
    28f8:	2006      	movs	r0, #6
    28fa:	e771      	b.n	27e0 <create_name+0x5c>
    28fc:	2006      	movs	r0, #6
    28fe:	e76f      	b.n	27e0 <create_name+0x5c>
				return FR_INVALID_NAME;
    2900:	2006      	movs	r0, #6
    2902:	e76d      	b.n	27e0 <create_name+0x5c>
    2904:	00002709 	.word	0x00002709
    2908:	000050a4 	.word	0x000050a4
    290c:	0000273d 	.word	0x0000273d

00002910 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
    2910:	b510      	push	{r4, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
    2912:	6801      	ldr	r1, [r0, #0]
    2914:	2900      	cmp	r1, #0
    2916:	d001      	beq.n	291c <get_ldnumber+0xc>
    2918:	000a      	movs	r2, r1
    291a:	e003      	b.n	2924 <get_ldnumber+0x14>
	int vol = -1;
    291c:	2301      	movs	r3, #1
    291e:	425b      	negs	r3, r3
    2920:	e008      	b.n	2934 <get_ldnumber+0x24>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
    2922:	3201      	adds	r2, #1
    2924:	7813      	ldrb	r3, [r2, #0]
    2926:	2b20      	cmp	r3, #32
    2928:	d901      	bls.n	292e <get_ldnumber+0x1e>
    292a:	2b3a      	cmp	r3, #58	; 0x3a
    292c:	d1f9      	bne.n	2922 <get_ldnumber+0x12>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
    292e:	2b3a      	cmp	r3, #58	; 0x3a
    2930:	d002      	beq.n	2938 <get_ldnumber+0x28>
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
    2932:	2300      	movs	r3, #0
#endif
	}
	return vol;
}
    2934:	0018      	movs	r0, r3
    2936:	bd10      	pop	{r4, pc}
			i = *tp++ - '0'; 
    2938:	1c4c      	adds	r4, r1, #1
    293a:	780b      	ldrb	r3, [r1, #0]
    293c:	3b30      	subs	r3, #48	; 0x30
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
    293e:	2b09      	cmp	r3, #9
    2940:	d806      	bhi.n	2950 <get_ldnumber+0x40>
    2942:	42a2      	cmp	r2, r4
    2944:	d107      	bne.n	2956 <get_ldnumber+0x46>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
    2946:	2b00      	cmp	r3, #0
    2948:	d108      	bne.n	295c <get_ldnumber+0x4c>
					*path = ++tt;
    294a:	3201      	adds	r2, #1
    294c:	6002      	str	r2, [r0, #0]
    294e:	e7f1      	b.n	2934 <get_ldnumber+0x24>
	int vol = -1;
    2950:	2301      	movs	r3, #1
    2952:	425b      	negs	r3, r3
    2954:	e7ee      	b.n	2934 <get_ldnumber+0x24>
    2956:	2301      	movs	r3, #1
    2958:	425b      	negs	r3, r3
    295a:	e7eb      	b.n	2934 <get_ldnumber+0x24>
    295c:	2301      	movs	r3, #1
    295e:	425b      	negs	r3, r3
    2960:	e7e8      	b.n	2934 <get_ldnumber+0x24>
	...

00002964 <sync_window>:
{
    2964:	b5f0      	push	{r4, r5, r6, r7, lr}
    2966:	b083      	sub	sp, #12
    2968:	0004      	movs	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
    296a:	7903      	ldrb	r3, [r0, #4]
    296c:	2b00      	cmp	r3, #0
    296e:	d102      	bne.n	2976 <sync_window+0x12>
	FRESULT res = FR_OK;
    2970:	2000      	movs	r0, #0
}
    2972:	b003      	add	sp, #12
    2974:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
    2976:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
    2978:	2330      	movs	r3, #48	; 0x30
    297a:	469c      	mov	ip, r3
    297c:	4484      	add	ip, r0
    297e:	4663      	mov	r3, ip
    2980:	4661      	mov	r1, ip
    2982:	9301      	str	r3, [sp, #4]
    2984:	7840      	ldrb	r0, [r0, #1]
    2986:	2301      	movs	r3, #1
    2988:	002a      	movs	r2, r5
    298a:	4e0f      	ldr	r6, [pc, #60]	; (29c8 <sync_window+0x64>)
    298c:	47b0      	blx	r6
    298e:	2800      	cmp	r0, #0
    2990:	d116      	bne.n	29c0 <sync_window+0x5c>
			fs->wflag = 0;
    2992:	2300      	movs	r3, #0
    2994:	7123      	strb	r3, [r4, #4]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
    2996:	6a23      	ldr	r3, [r4, #32]
    2998:	1aeb      	subs	r3, r5, r3
    299a:	69a2      	ldr	r2, [r4, #24]
    299c:	4293      	cmp	r3, r2
    299e:	d211      	bcs.n	29c4 <sync_window+0x60>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    29a0:	78e6      	ldrb	r6, [r4, #3]
    29a2:	e009      	b.n	29b8 <sync_window+0x54>
					wsect += fs->fsize;
    29a4:	69a3      	ldr	r3, [r4, #24]
    29a6:	469c      	mov	ip, r3
    29a8:	4465      	add	r5, ip
					disk_write(fs->drv, fs->win, wsect, 1);
    29aa:	7860      	ldrb	r0, [r4, #1]
    29ac:	2301      	movs	r3, #1
    29ae:	002a      	movs	r2, r5
    29b0:	9901      	ldr	r1, [sp, #4]
    29b2:	4f05      	ldr	r7, [pc, #20]	; (29c8 <sync_window+0x64>)
    29b4:	47b8      	blx	r7
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    29b6:	3e01      	subs	r6, #1
    29b8:	2e01      	cmp	r6, #1
    29ba:	d8f3      	bhi.n	29a4 <sync_window+0x40>
	FRESULT res = FR_OK;
    29bc:	2000      	movs	r0, #0
    29be:	e7d8      	b.n	2972 <sync_window+0xe>
			res = FR_DISK_ERR;
    29c0:	2001      	movs	r0, #1
    29c2:	e7d6      	b.n	2972 <sync_window+0xe>
	FRESULT res = FR_OK;
    29c4:	2000      	movs	r0, #0
    29c6:	e7d4      	b.n	2972 <sync_window+0xe>
    29c8:	0000258d 	.word	0x0000258d

000029cc <move_window>:
{
    29cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    29ce:	0005      	movs	r5, r0
    29d0:	000e      	movs	r6, r1
	if (sector != fs->winsect) {	/* Window offset changed? */
    29d2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    29d4:	428b      	cmp	r3, r1
    29d6:	d013      	beq.n	2a00 <move_window+0x34>
		res = sync_window(fs);		/* Write-back changes */
    29d8:	4b0a      	ldr	r3, [pc, #40]	; (2a04 <move_window+0x38>)
    29da:	4798      	blx	r3
    29dc:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {			/* Fill sector window with new data */
    29de:	d001      	beq.n	29e4 <move_window+0x18>
}
    29e0:	0020      	movs	r0, r4
    29e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
    29e4:	0029      	movs	r1, r5
    29e6:	3130      	adds	r1, #48	; 0x30
    29e8:	7868      	ldrb	r0, [r5, #1]
    29ea:	2301      	movs	r3, #1
    29ec:	0032      	movs	r2, r6
    29ee:	4f06      	ldr	r7, [pc, #24]	; (2a08 <move_window+0x3c>)
    29f0:	47b8      	blx	r7
    29f2:	2800      	cmp	r0, #0
    29f4:	d002      	beq.n	29fc <move_window+0x30>
				res = FR_DISK_ERR;
    29f6:	3401      	adds	r4, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
    29f8:	2601      	movs	r6, #1
    29fa:	4276      	negs	r6, r6
			fs->winsect = sector;
    29fc:	62ee      	str	r6, [r5, #44]	; 0x2c
    29fe:	e7ef      	b.n	29e0 <move_window+0x14>
	FRESULT res = FR_OK;
    2a00:	2400      	movs	r4, #0
    2a02:	e7ed      	b.n	29e0 <move_window+0x14>
    2a04:	00002965 	.word	0x00002965
    2a08:	00002541 	.word	0x00002541

00002a0c <check_fs>:
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    2a0c:	b510      	push	{r4, lr}
    2a0e:	0004      	movs	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
    2a10:	2300      	movs	r3, #0
    2a12:	7103      	strb	r3, [r0, #4]
    2a14:	3b01      	subs	r3, #1
    2a16:	62c3      	str	r3, [r0, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
    2a18:	4b1d      	ldr	r3, [pc, #116]	; (2a90 <check_fs+0x84>)
    2a1a:	4798      	blx	r3
    2a1c:	2800      	cmp	r0, #0
    2a1e:	d001      	beq.n	2a24 <check_fs+0x18>
		return 3;
    2a20:	2003      	movs	r0, #3
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
    2a22:	bd10      	pop	{r4, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
    2a24:	4b1b      	ldr	r3, [pc, #108]	; (2a94 <check_fs+0x88>)
    2a26:	5ce2      	ldrb	r2, [r4, r3]
    2a28:	0212      	lsls	r2, r2, #8
    2a2a:	4b1b      	ldr	r3, [pc, #108]	; (2a98 <check_fs+0x8c>)
    2a2c:	5ce3      	ldrb	r3, [r4, r3]
    2a2e:	4313      	orrs	r3, r2
    2a30:	b21b      	sxth	r3, r3
    2a32:	4a1a      	ldr	r2, [pc, #104]	; (2a9c <check_fs+0x90>)
    2a34:	4293      	cmp	r3, r2
    2a36:	d001      	beq.n	2a3c <check_fs+0x30>
		return 2;
    2a38:	2002      	movs	r0, #2
    2a3a:	e7f2      	b.n	2a22 <check_fs+0x16>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
    2a3c:	2369      	movs	r3, #105	; 0x69
    2a3e:	5ce3      	ldrb	r3, [r4, r3]
    2a40:	061b      	lsls	r3, r3, #24
    2a42:	2268      	movs	r2, #104	; 0x68
    2a44:	5ca2      	ldrb	r2, [r4, r2]
    2a46:	0412      	lsls	r2, r2, #16
    2a48:	4313      	orrs	r3, r2
    2a4a:	2267      	movs	r2, #103	; 0x67
    2a4c:	5ca2      	ldrb	r2, [r4, r2]
    2a4e:	0212      	lsls	r2, r2, #8
    2a50:	4313      	orrs	r3, r2
    2a52:	2266      	movs	r2, #102	; 0x66
    2a54:	5ca2      	ldrb	r2, [r4, r2]
    2a56:	4313      	orrs	r3, r2
    2a58:	021b      	lsls	r3, r3, #8
    2a5a:	0a1b      	lsrs	r3, r3, #8
    2a5c:	4a10      	ldr	r2, [pc, #64]	; (2aa0 <check_fs+0x94>)
    2a5e:	4293      	cmp	r3, r2
    2a60:	d014      	beq.n	2a8c <check_fs+0x80>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    2a62:	2385      	movs	r3, #133	; 0x85
    2a64:	5ce3      	ldrb	r3, [r4, r3]
    2a66:	061b      	lsls	r3, r3, #24
    2a68:	2284      	movs	r2, #132	; 0x84
    2a6a:	5ca2      	ldrb	r2, [r4, r2]
    2a6c:	0412      	lsls	r2, r2, #16
    2a6e:	4313      	orrs	r3, r2
    2a70:	2283      	movs	r2, #131	; 0x83
    2a72:	5ca2      	ldrb	r2, [r4, r2]
    2a74:	0212      	lsls	r2, r2, #8
    2a76:	4313      	orrs	r3, r2
    2a78:	2282      	movs	r2, #130	; 0x82
    2a7a:	5ca2      	ldrb	r2, [r4, r2]
    2a7c:	4313      	orrs	r3, r2
    2a7e:	021b      	lsls	r3, r3, #8
    2a80:	0a1b      	lsrs	r3, r3, #8
    2a82:	4a07      	ldr	r2, [pc, #28]	; (2aa0 <check_fs+0x94>)
    2a84:	4293      	cmp	r3, r2
    2a86:	d0cc      	beq.n	2a22 <check_fs+0x16>
	return 1;
    2a88:	2001      	movs	r0, #1
    2a8a:	e7ca      	b.n	2a22 <check_fs+0x16>
		return 0;
    2a8c:	2000      	movs	r0, #0
    2a8e:	e7c8      	b.n	2a22 <check_fs+0x16>
    2a90:	000029cd 	.word	0x000029cd
    2a94:	0000022f 	.word	0x0000022f
    2a98:	0000022e 	.word	0x0000022e
    2a9c:	ffffaa55 	.word	0xffffaa55
    2aa0:	00544146 	.word	0x00544146

00002aa4 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    2aa4:	b510      	push	{r4, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    2aa6:	2800      	cmp	r0, #0
    2aa8:	d014      	beq.n	2ad4 <validate+0x30>
    2aaa:	6803      	ldr	r3, [r0, #0]
    2aac:	2b00      	cmp	r3, #0
    2aae:	d013      	beq.n	2ad8 <validate+0x34>
    2ab0:	781a      	ldrb	r2, [r3, #0]
    2ab2:	2a00      	cmp	r2, #0
    2ab4:	d101      	bne.n	2aba <validate+0x16>
		return FR_INVALID_OBJECT;
    2ab6:	2009      	movs	r0, #9

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
    2ab8:	bd10      	pop	{r4, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    2aba:	88d9      	ldrh	r1, [r3, #6]
    2abc:	8882      	ldrh	r2, [r0, #4]
    2abe:	4291      	cmp	r1, r2
    2ac0:	d001      	beq.n	2ac6 <validate+0x22>
		return FR_INVALID_OBJECT;
    2ac2:	2009      	movs	r0, #9
    2ac4:	e7f8      	b.n	2ab8 <validate+0x14>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
    2ac6:	7858      	ldrb	r0, [r3, #1]
    2ac8:	4b05      	ldr	r3, [pc, #20]	; (2ae0 <validate+0x3c>)
    2aca:	4798      	blx	r3
    2acc:	07c3      	lsls	r3, r0, #31
    2ace:	d505      	bpl.n	2adc <validate+0x38>
		return FR_NOT_READY;
    2ad0:	2003      	movs	r0, #3
    2ad2:	e7f1      	b.n	2ab8 <validate+0x14>
		return FR_INVALID_OBJECT;
    2ad4:	2009      	movs	r0, #9
    2ad6:	e7ef      	b.n	2ab8 <validate+0x14>
    2ad8:	2009      	movs	r0, #9
    2ada:	e7ed      	b.n	2ab8 <validate+0x14>
	return FR_OK;
    2adc:	2000      	movs	r0, #0
    2ade:	e7eb      	b.n	2ab8 <validate+0x14>
    2ae0:	00002515 	.word	0x00002515

00002ae4 <find_volume>:
{
    2ae4:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ae6:	46de      	mov	lr, fp
    2ae8:	4657      	mov	r7, sl
    2aea:	464e      	mov	r6, r9
    2aec:	4645      	mov	r5, r8
    2aee:	b5e0      	push	{r5, r6, r7, lr}
    2af0:	b085      	sub	sp, #20
    2af2:	0007      	movs	r7, r0
    2af4:	0016      	movs	r6, r2
	*rfs = 0;
    2af6:	2300      	movs	r3, #0
    2af8:	6003      	str	r3, [r0, #0]
	vol = get_ldnumber(path);
    2afa:	0008      	movs	r0, r1
    2afc:	4bca      	ldr	r3, [pc, #808]	; (2e28 <find_volume+0x344>)
    2afe:	4798      	blx	r3
    2b00:	1e04      	subs	r4, r0, #0
	if (vol < 0) return FR_INVALID_DRIVE;
    2b02:	da00      	bge.n	2b06 <find_volume+0x22>
    2b04:	e1c0      	b.n	2e88 <find_volume+0x3a4>
	fs = FatFs[vol];					/* Get pointer to the file system object */
    2b06:	0083      	lsls	r3, r0, #2
    2b08:	4ac8      	ldr	r2, [pc, #800]	; (2e2c <find_volume+0x348>)
    2b0a:	589d      	ldr	r5, [r3, r2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    2b0c:	2d00      	cmp	r5, #0
    2b0e:	d100      	bne.n	2b12 <find_volume+0x2e>
    2b10:	e1c2      	b.n	2e98 <find_volume+0x3b4>
	*rfs = fs;							/* Return pointer to the file system object */
    2b12:	603d      	str	r5, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
    2b14:	782b      	ldrb	r3, [r5, #0]
    2b16:	2b00      	cmp	r3, #0
    2b18:	d00d      	beq.n	2b36 <find_volume+0x52>
		stat = disk_status(fs->drv);
    2b1a:	7868      	ldrb	r0, [r5, #1]
    2b1c:	4bc4      	ldr	r3, [pc, #784]	; (2e30 <find_volume+0x34c>)
    2b1e:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
    2b20:	07c3      	lsls	r3, r0, #31
    2b22:	d408      	bmi.n	2b36 <find_volume+0x52>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    2b24:	2e00      	cmp	r6, #0
    2b26:	d100      	bne.n	2b2a <find_volume+0x46>
    2b28:	e1b8      	b.n	2e9c <find_volume+0x3b8>
    2b2a:	0743      	lsls	r3, r0, #29
    2b2c:	d501      	bpl.n	2b32 <find_volume+0x4e>
				return FR_WRITE_PROTECTED;
    2b2e:	200a      	movs	r0, #10
    2b30:	e1ab      	b.n	2e8a <find_volume+0x3a6>
			return FR_OK;				/* The file system object is valid */
    2b32:	2000      	movs	r0, #0
    2b34:	e1a9      	b.n	2e8a <find_volume+0x3a6>
	fs->fs_type = 0;					/* Clear the file system object */
    2b36:	2300      	movs	r3, #0
    2b38:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    2b3a:	b2e0      	uxtb	r0, r4
    2b3c:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    2b3e:	4bbd      	ldr	r3, [pc, #756]	; (2e34 <find_volume+0x350>)
    2b40:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    2b42:	07c3      	lsls	r3, r0, #31
    2b44:	d501      	bpl.n	2b4a <find_volume+0x66>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    2b46:	2003      	movs	r0, #3
    2b48:	e19f      	b.n	2e8a <find_volume+0x3a6>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    2b4a:	2e00      	cmp	r6, #0
    2b4c:	d003      	beq.n	2b56 <find_volume+0x72>
    2b4e:	0743      	lsls	r3, r0, #29
    2b50:	d501      	bpl.n	2b56 <find_volume+0x72>
		return FR_WRITE_PROTECTED;
    2b52:	200a      	movs	r0, #10
    2b54:	e199      	b.n	2e8a <find_volume+0x3a6>
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
    2b56:	2100      	movs	r1, #0
    2b58:	0028      	movs	r0, r5
    2b5a:	4bb7      	ldr	r3, [pc, #732]	; (2e38 <find_volume+0x354>)
    2b5c:	4798      	blx	r3
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
    2b5e:	2801      	cmp	r0, #1
    2b60:	d022      	beq.n	2ba8 <find_volume+0xc4>
	bsect = 0;
    2b62:	2600      	movs	r6, #0
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    2b64:	2803      	cmp	r0, #3
    2b66:	d100      	bne.n	2b6a <find_volume+0x86>
    2b68:	e19a      	b.n	2ea0 <find_volume+0x3bc>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    2b6a:	2800      	cmp	r0, #0
    2b6c:	d030      	beq.n	2bd0 <find_volume+0xec>
    2b6e:	200d      	movs	r0, #13
    2b70:	e18b      	b.n	2e8a <find_volume+0x3a6>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
    2b72:	2300      	movs	r3, #0
    2b74:	008a      	lsls	r2, r1, #2
    2b76:	4668      	mov	r0, sp
    2b78:	5013      	str	r3, [r2, r0]
		for (i = 0; i < 4; i++) {			/* Get partition offset */
    2b7a:	3101      	adds	r1, #1
    2b7c:	2903      	cmp	r1, #3
    2b7e:	d815      	bhi.n	2bac <find_volume+0xc8>
			pt = fs->win + MBR_Table + i * SZ_PTE;
    2b80:	002a      	movs	r2, r5
    2b82:	3230      	adds	r2, #48	; 0x30
    2b84:	010b      	lsls	r3, r1, #4
    2b86:	33bf      	adds	r3, #191	; 0xbf
    2b88:	33ff      	adds	r3, #255	; 0xff
    2b8a:	18d3      	adds	r3, r2, r3
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
    2b8c:	791a      	ldrb	r2, [r3, #4]
    2b8e:	2a00      	cmp	r2, #0
    2b90:	d0ef      	beq.n	2b72 <find_volume+0x8e>
    2b92:	7ada      	ldrb	r2, [r3, #11]
    2b94:	0612      	lsls	r2, r2, #24
    2b96:	7a98      	ldrb	r0, [r3, #10]
    2b98:	0400      	lsls	r0, r0, #16
    2b9a:	4302      	orrs	r2, r0
    2b9c:	7a58      	ldrb	r0, [r3, #9]
    2b9e:	0200      	lsls	r0, r0, #8
    2ba0:	4302      	orrs	r2, r0
    2ba2:	7a1b      	ldrb	r3, [r3, #8]
    2ba4:	4313      	orrs	r3, r2
    2ba6:	e7e5      	b.n	2b74 <find_volume+0x90>
    2ba8:	2100      	movs	r1, #0
    2baa:	e7e7      	b.n	2b7c <find_volume+0x98>
    2bac:	2400      	movs	r4, #0
    2bae:	e008      	b.n	2bc2 <find_volume+0xde>
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
    2bb0:	0031      	movs	r1, r6
    2bb2:	0028      	movs	r0, r5
    2bb4:	4ba0      	ldr	r3, [pc, #640]	; (2e38 <find_volume+0x354>)
    2bb6:	4798      	blx	r3
		} while (!LD2PT(vol) && fmt && ++i < 4);
    2bb8:	2800      	cmp	r0, #0
    2bba:	d0d3      	beq.n	2b64 <find_volume+0x80>
    2bbc:	3401      	adds	r4, #1
    2bbe:	2c03      	cmp	r4, #3
    2bc0:	d8d0      	bhi.n	2b64 <find_volume+0x80>
			bsect = br[i];
    2bc2:	00a3      	lsls	r3, r4, #2
    2bc4:	466a      	mov	r2, sp
    2bc6:	589e      	ldr	r6, [r3, r2]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
    2bc8:	2e00      	cmp	r6, #0
    2bca:	d1f1      	bne.n	2bb0 <find_volume+0xcc>
    2bcc:	2002      	movs	r0, #2
    2bce:	e7f3      	b.n	2bb8 <find_volume+0xd4>
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
    2bd0:	233c      	movs	r3, #60	; 0x3c
    2bd2:	5cea      	ldrb	r2, [r5, r3]
    2bd4:	0212      	lsls	r2, r2, #8
    2bd6:	3b01      	subs	r3, #1
    2bd8:	5ceb      	ldrb	r3, [r5, r3]
    2bda:	4313      	orrs	r3, r2
    2bdc:	b21b      	sxth	r3, r3
    2bde:	2280      	movs	r2, #128	; 0x80
    2be0:	0092      	lsls	r2, r2, #2
    2be2:	4293      	cmp	r3, r2
    2be4:	d001      	beq.n	2bea <find_volume+0x106>
		return FR_NO_FILESYSTEM;
    2be6:	200d      	movs	r0, #13
    2be8:	e14f      	b.n	2e8a <find_volume+0x3a6>
	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
    2bea:	2347      	movs	r3, #71	; 0x47
    2bec:	5ceb      	ldrb	r3, [r5, r3]
    2bee:	021b      	lsls	r3, r3, #8
    2bf0:	3abb      	subs	r2, #187	; 0xbb
    2bf2:	3aff      	subs	r2, #255	; 0xff
    2bf4:	5cac      	ldrb	r4, [r5, r2]
    2bf6:	431c      	orrs	r4, r3
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
    2bf8:	d10d      	bne.n	2c16 <find_volume+0x132>
    2bfa:	2357      	movs	r3, #87	; 0x57
    2bfc:	5cec      	ldrb	r4, [r5, r3]
    2bfe:	0624      	lsls	r4, r4, #24
    2c00:	3b01      	subs	r3, #1
    2c02:	5ceb      	ldrb	r3, [r5, r3]
    2c04:	041b      	lsls	r3, r3, #16
    2c06:	431c      	orrs	r4, r3
    2c08:	2355      	movs	r3, #85	; 0x55
    2c0a:	5ceb      	ldrb	r3, [r5, r3]
    2c0c:	021b      	lsls	r3, r3, #8
    2c0e:	431c      	orrs	r4, r3
    2c10:	2354      	movs	r3, #84	; 0x54
    2c12:	5ceb      	ldrb	r3, [r5, r3]
    2c14:	431c      	orrs	r4, r3
	fs->fsize = fasize;
    2c16:	61ac      	str	r4, [r5, #24]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
    2c18:	2340      	movs	r3, #64	; 0x40
    2c1a:	5cef      	ldrb	r7, [r5, r3]
    2c1c:	70ef      	strb	r7, [r5, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
    2c1e:	1e7b      	subs	r3, r7, #1
    2c20:	b2db      	uxtb	r3, r3
    2c22:	2b01      	cmp	r3, #1
    2c24:	d901      	bls.n	2c2a <find_volume+0x146>
		return FR_NO_FILESYSTEM;
    2c26:	200d      	movs	r0, #13
    2c28:	e12f      	b.n	2e8a <find_volume+0x3a6>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
    2c2a:	4367      	muls	r7, r4
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
    2c2c:	233d      	movs	r3, #61	; 0x3d
    2c2e:	5ce9      	ldrb	r1, [r5, r3]
    2c30:	70a9      	strb	r1, [r5, #2]
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
    2c32:	2900      	cmp	r1, #0
    2c34:	d101      	bne.n	2c3a <find_volume+0x156>
		return FR_NO_FILESYSTEM;
    2c36:	200d      	movs	r0, #13
    2c38:	e127      	b.n	2e8a <find_volume+0x3a6>
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
    2c3a:	1e4b      	subs	r3, r1, #1
    2c3c:	420b      	tst	r3, r1
    2c3e:	d001      	beq.n	2c44 <find_volume+0x160>
		return FR_NO_FILESYSTEM;
    2c40:	200d      	movs	r0, #13
    2c42:	e122      	b.n	2e8a <find_volume+0x3a6>
	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
    2c44:	2342      	movs	r3, #66	; 0x42
    2c46:	5ceb      	ldrb	r3, [r5, r3]
    2c48:	021b      	lsls	r3, r3, #8
    2c4a:	2241      	movs	r2, #65	; 0x41
    2c4c:	5caa      	ldrb	r2, [r5, r2]
    2c4e:	431a      	orrs	r2, r3
    2c50:	4693      	mov	fp, r2
    2c52:	812a      	strh	r2, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
    2c54:	0013      	movs	r3, r2
    2c56:	071b      	lsls	r3, r3, #28
    2c58:	d000      	beq.n	2c5c <find_volume+0x178>
    2c5a:	e123      	b.n	2ea4 <find_volume+0x3c0>
	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
    2c5c:	2344      	movs	r3, #68	; 0x44
    2c5e:	5ceb      	ldrb	r3, [r5, r3]
    2c60:	021b      	lsls	r3, r3, #8
    2c62:	2243      	movs	r2, #67	; 0x43
    2c64:	5ca8      	ldrb	r0, [r5, r2]
    2c66:	4318      	orrs	r0, r3
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
    2c68:	d10d      	bne.n	2c86 <find_volume+0x1a2>
    2c6a:	2353      	movs	r3, #83	; 0x53
    2c6c:	5ce8      	ldrb	r0, [r5, r3]
    2c6e:	0600      	lsls	r0, r0, #24
    2c70:	3b01      	subs	r3, #1
    2c72:	5ceb      	ldrb	r3, [r5, r3]
    2c74:	041b      	lsls	r3, r3, #16
    2c76:	4318      	orrs	r0, r3
    2c78:	2351      	movs	r3, #81	; 0x51
    2c7a:	5ceb      	ldrb	r3, [r5, r3]
    2c7c:	021b      	lsls	r3, r3, #8
    2c7e:	4318      	orrs	r0, r3
    2c80:	2350      	movs	r3, #80	; 0x50
    2c82:	5ceb      	ldrb	r3, [r5, r3]
    2c84:	4318      	orrs	r0, r3
	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
    2c86:	233f      	movs	r3, #63	; 0x3f
    2c88:	5ceb      	ldrb	r3, [r5, r3]
    2c8a:	021b      	lsls	r3, r3, #8
    2c8c:	223e      	movs	r2, #62	; 0x3e
    2c8e:	5caa      	ldrb	r2, [r5, r2]
    2c90:	431a      	orrs	r2, r3
    2c92:	4691      	mov	r9, r2
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
    2c94:	d100      	bne.n	2c98 <find_volume+0x1b4>
    2c96:	e107      	b.n	2ea8 <find_volume+0x3c4>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
    2c98:	18bb      	adds	r3, r7, r2
    2c9a:	465a      	mov	r2, fp
    2c9c:	0912      	lsrs	r2, r2, #4
    2c9e:	4698      	mov	r8, r3
    2ca0:	4490      	add	r8, r2
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    2ca2:	4540      	cmp	r0, r8
    2ca4:	d200      	bcs.n	2ca8 <find_volume+0x1c4>
    2ca6:	e101      	b.n	2eac <find_volume+0x3c8>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    2ca8:	4643      	mov	r3, r8
    2caa:	1ac0      	subs	r0, r0, r3
    2cac:	4b63      	ldr	r3, [pc, #396]	; (2e3c <find_volume+0x358>)
    2cae:	4798      	blx	r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    2cb0:	2800      	cmp	r0, #0
    2cb2:	d100      	bne.n	2cb6 <find_volume+0x1d2>
    2cb4:	e0fc      	b.n	2eb0 <find_volume+0x3cc>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    2cb6:	4b62      	ldr	r3, [pc, #392]	; (2e40 <find_volume+0x35c>)
    2cb8:	4298      	cmp	r0, r3
    2cba:	d900      	bls.n	2cbe <find_volume+0x1da>
    2cbc:	e09f      	b.n	2dfe <find_volume+0x31a>
	fmt = FS_FAT12;
    2cbe:	2301      	movs	r3, #1
    2cc0:	469a      	mov	sl, r3
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    2cc2:	4b60      	ldr	r3, [pc, #384]	; (2e44 <find_volume+0x360>)
    2cc4:	4298      	cmp	r0, r3
    2cc6:	d901      	bls.n	2ccc <find_volume+0x1e8>
    2cc8:	2303      	movs	r3, #3
    2cca:	469a      	mov	sl, r3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2ccc:	3002      	adds	r0, #2
    2cce:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
    2cd0:	61ee      	str	r6, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2cd2:	464b      	mov	r3, r9
    2cd4:	18f3      	adds	r3, r6, r3
    2cd6:	622b      	str	r3, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
    2cd8:	4642      	mov	r2, r8
    2cda:	18b2      	adds	r2, r6, r2
    2cdc:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fmt == FS_FAT32) {
    2cde:	4652      	mov	r2, sl
    2ce0:	2a03      	cmp	r2, #3
    2ce2:	d000      	beq.n	2ce6 <find_volume+0x202>
    2ce4:	e08e      	b.n	2e04 <find_volume+0x320>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    2ce6:	465b      	mov	r3, fp
    2ce8:	2b00      	cmp	r3, #0
    2cea:	d000      	beq.n	2cee <find_volume+0x20a>
    2cec:	e0e2      	b.n	2eb4 <find_volume+0x3d0>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
    2cee:	335f      	adds	r3, #95	; 0x5f
    2cf0:	5ceb      	ldrb	r3, [r5, r3]
    2cf2:	061b      	lsls	r3, r3, #24
    2cf4:	325b      	adds	r2, #91	; 0x5b
    2cf6:	5caa      	ldrb	r2, [r5, r2]
    2cf8:	0412      	lsls	r2, r2, #16
    2cfa:	4313      	orrs	r3, r2
    2cfc:	225d      	movs	r2, #93	; 0x5d
    2cfe:	5caa      	ldrb	r2, [r5, r2]
    2d00:	0212      	lsls	r2, r2, #8
    2d02:	4313      	orrs	r3, r2
    2d04:	225c      	movs	r2, #92	; 0x5c
    2d06:	5caa      	ldrb	r2, [r5, r2]
    2d08:	4313      	orrs	r3, r2
    2d0a:	626b      	str	r3, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
    2d0c:	0080      	lsls	r0, r0, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
    2d0e:	4b4e      	ldr	r3, [pc, #312]	; (2e48 <find_volume+0x364>)
    2d10:	469c      	mov	ip, r3
    2d12:	4460      	add	r0, ip
    2d14:	0a40      	lsrs	r0, r0, #9
    2d16:	4284      	cmp	r4, r0
    2d18:	d200      	bcs.n	2d1c <find_volume+0x238>
    2d1a:	e0cf      	b.n	2ebc <find_volume+0x3d8>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
    2d1c:	2301      	movs	r3, #1
    2d1e:	425b      	negs	r3, r3
    2d20:	612b      	str	r3, [r5, #16]
    2d22:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
    2d24:	3381      	adds	r3, #129	; 0x81
    2d26:	716b      	strb	r3, [r5, #5]
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    2d28:	4653      	mov	r3, sl
    2d2a:	2b03      	cmp	r3, #3
    2d2c:	d15d      	bne.n	2dea <find_volume+0x306>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
    2d2e:	335e      	adds	r3, #94	; 0x5e
    2d30:	5cea      	ldrb	r2, [r5, r3]
    2d32:	0212      	lsls	r2, r2, #8
    2d34:	3b01      	subs	r3, #1
    2d36:	5ceb      	ldrb	r3, [r5, r3]
    2d38:	4313      	orrs	r3, r2
    2d3a:	b21b      	sxth	r3, r3
    2d3c:	2b01      	cmp	r3, #1
    2d3e:	d154      	bne.n	2dea <find_volume+0x306>
		&& move_window(fs, bsect + 1) == FR_OK)
    2d40:	1c71      	adds	r1, r6, #1
    2d42:	0028      	movs	r0, r5
    2d44:	4b41      	ldr	r3, [pc, #260]	; (2e4c <find_volume+0x368>)
    2d46:	4798      	blx	r3
    2d48:	2800      	cmp	r0, #0
    2d4a:	d14e      	bne.n	2dea <find_volume+0x306>
		fs->fsi_flag = 0;
    2d4c:	2300      	movs	r3, #0
    2d4e:	716b      	strb	r3, [r5, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
    2d50:	4b3f      	ldr	r3, [pc, #252]	; (2e50 <find_volume+0x36c>)
    2d52:	5cea      	ldrb	r2, [r5, r3]
    2d54:	0212      	lsls	r2, r2, #8
    2d56:	4b3f      	ldr	r3, [pc, #252]	; (2e54 <find_volume+0x370>)
    2d58:	5ceb      	ldrb	r3, [r5, r3]
    2d5a:	4313      	orrs	r3, r2
    2d5c:	b21b      	sxth	r3, r3
    2d5e:	4a3e      	ldr	r2, [pc, #248]	; (2e58 <find_volume+0x374>)
    2d60:	4293      	cmp	r3, r2
    2d62:	d142      	bne.n	2dea <find_volume+0x306>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
    2d64:	2333      	movs	r3, #51	; 0x33
    2d66:	5ceb      	ldrb	r3, [r5, r3]
    2d68:	061b      	lsls	r3, r3, #24
    2d6a:	2232      	movs	r2, #50	; 0x32
    2d6c:	5caa      	ldrb	r2, [r5, r2]
    2d6e:	0412      	lsls	r2, r2, #16
    2d70:	4313      	orrs	r3, r2
    2d72:	2231      	movs	r2, #49	; 0x31
    2d74:	5caa      	ldrb	r2, [r5, r2]
    2d76:	0212      	lsls	r2, r2, #8
    2d78:	4313      	orrs	r3, r2
    2d7a:	2230      	movs	r2, #48	; 0x30
    2d7c:	5caa      	ldrb	r2, [r5, r2]
    2d7e:	4313      	orrs	r3, r2
    2d80:	4a36      	ldr	r2, [pc, #216]	; (2e5c <find_volume+0x378>)
    2d82:	4293      	cmp	r3, r2
    2d84:	d131      	bne.n	2dea <find_volume+0x306>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
    2d86:	4b36      	ldr	r3, [pc, #216]	; (2e60 <find_volume+0x37c>)
    2d88:	5ceb      	ldrb	r3, [r5, r3]
    2d8a:	061b      	lsls	r3, r3, #24
    2d8c:	4a35      	ldr	r2, [pc, #212]	; (2e64 <find_volume+0x380>)
    2d8e:	5caa      	ldrb	r2, [r5, r2]
    2d90:	0412      	lsls	r2, r2, #16
    2d92:	4313      	orrs	r3, r2
    2d94:	4a34      	ldr	r2, [pc, #208]	; (2e68 <find_volume+0x384>)
    2d96:	5caa      	ldrb	r2, [r5, r2]
    2d98:	0212      	lsls	r2, r2, #8
    2d9a:	4313      	orrs	r3, r2
    2d9c:	2285      	movs	r2, #133	; 0x85
    2d9e:	0092      	lsls	r2, r2, #2
    2da0:	5caa      	ldrb	r2, [r5, r2]
    2da2:	4313      	orrs	r3, r2
    2da4:	4a31      	ldr	r2, [pc, #196]	; (2e6c <find_volume+0x388>)
    2da6:	4293      	cmp	r3, r2
    2da8:	d11f      	bne.n	2dea <find_volume+0x306>
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
    2daa:	4b31      	ldr	r3, [pc, #196]	; (2e70 <find_volume+0x38c>)
    2dac:	5ceb      	ldrb	r3, [r5, r3]
    2dae:	061b      	lsls	r3, r3, #24
    2db0:	4a30      	ldr	r2, [pc, #192]	; (2e74 <find_volume+0x390>)
    2db2:	5caa      	ldrb	r2, [r5, r2]
    2db4:	0412      	lsls	r2, r2, #16
    2db6:	4313      	orrs	r3, r2
    2db8:	4a2f      	ldr	r2, [pc, #188]	; (2e78 <find_volume+0x394>)
    2dba:	5caa      	ldrb	r2, [r5, r2]
    2dbc:	0212      	lsls	r2, r2, #8
    2dbe:	4313      	orrs	r3, r2
    2dc0:	2286      	movs	r2, #134	; 0x86
    2dc2:	0092      	lsls	r2, r2, #2
    2dc4:	5caa      	ldrb	r2, [r5, r2]
    2dc6:	4313      	orrs	r3, r2
    2dc8:	612b      	str	r3, [r5, #16]
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
    2dca:	4b2c      	ldr	r3, [pc, #176]	; (2e7c <find_volume+0x398>)
    2dcc:	5ceb      	ldrb	r3, [r5, r3]
    2dce:	061b      	lsls	r3, r3, #24
    2dd0:	4a2b      	ldr	r2, [pc, #172]	; (2e80 <find_volume+0x39c>)
    2dd2:	5caa      	ldrb	r2, [r5, r2]
    2dd4:	0412      	lsls	r2, r2, #16
    2dd6:	4313      	orrs	r3, r2
    2dd8:	4a2a      	ldr	r2, [pc, #168]	; (2e84 <find_volume+0x3a0>)
    2dda:	5caa      	ldrb	r2, [r5, r2]
    2ddc:	0212      	lsls	r2, r2, #8
    2dde:	4313      	orrs	r3, r2
    2de0:	2287      	movs	r2, #135	; 0x87
    2de2:	0092      	lsls	r2, r2, #2
    2de4:	5caa      	ldrb	r2, [r5, r2]
    2de6:	4313      	orrs	r3, r2
    2de8:	60eb      	str	r3, [r5, #12]
	fs->fs_type = fmt;	/* FAT sub-type */
    2dea:	4653      	mov	r3, sl
    2dec:	702b      	strb	r3, [r5, #0]
	fs->id = ++Fsid;	/* File system mount ID */
    2dee:	4a0f      	ldr	r2, [pc, #60]	; (2e2c <find_volume+0x348>)
    2df0:	8893      	ldrh	r3, [r2, #4]
    2df2:	3301      	adds	r3, #1
    2df4:	b29b      	uxth	r3, r3
    2df6:	8093      	strh	r3, [r2, #4]
    2df8:	80eb      	strh	r3, [r5, #6]
	return FR_OK;
    2dfa:	2000      	movs	r0, #0
    2dfc:	e045      	b.n	2e8a <find_volume+0x3a6>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    2dfe:	2302      	movs	r3, #2
    2e00:	469a      	mov	sl, r3
    2e02:	e75e      	b.n	2cc2 <find_volume+0x1de>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    2e04:	465a      	mov	r2, fp
    2e06:	2a00      	cmp	r2, #0
    2e08:	d056      	beq.n	2eb8 <find_volume+0x3d4>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    2e0a:	18ff      	adds	r7, r7, r3
    2e0c:	626f      	str	r7, [r5, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2e0e:	4653      	mov	r3, sl
    2e10:	2b02      	cmp	r3, #2
    2e12:	d101      	bne.n	2e18 <find_volume+0x334>
    2e14:	0040      	lsls	r0, r0, #1
    2e16:	e77a      	b.n	2d0e <find_volume+0x22a>
    2e18:	2303      	movs	r3, #3
    2e1a:	4343      	muls	r3, r0
    2e1c:	085b      	lsrs	r3, r3, #1
    2e1e:	2201      	movs	r2, #1
    2e20:	4010      	ands	r0, r2
    2e22:	1818      	adds	r0, r3, r0
    2e24:	e773      	b.n	2d0e <find_volume+0x22a>
    2e26:	46c0      	nop			; (mov r8, r8)
    2e28:	00002911 	.word	0x00002911
    2e2c:	20000458 	.word	0x20000458
    2e30:	00002515 	.word	0x00002515
    2e34:	00002521 	.word	0x00002521
    2e38:	00002a0d 	.word	0x00002a0d
    2e3c:	0000478d 	.word	0x0000478d
    2e40:	00000ff5 	.word	0x00000ff5
    2e44:	0000fff5 	.word	0x0000fff5
    2e48:	000001ff 	.word	0x000001ff
    2e4c:	000029cd 	.word	0x000029cd
    2e50:	0000022f 	.word	0x0000022f
    2e54:	0000022e 	.word	0x0000022e
    2e58:	ffffaa55 	.word	0xffffaa55
    2e5c:	41615252 	.word	0x41615252
    2e60:	00000217 	.word	0x00000217
    2e64:	00000216 	.word	0x00000216
    2e68:	00000215 	.word	0x00000215
    2e6c:	61417272 	.word	0x61417272
    2e70:	0000021b 	.word	0x0000021b
    2e74:	0000021a 	.word	0x0000021a
    2e78:	00000219 	.word	0x00000219
    2e7c:	0000021f 	.word	0x0000021f
    2e80:	0000021e 	.word	0x0000021e
    2e84:	0000021d 	.word	0x0000021d
	if (vol < 0) return FR_INVALID_DRIVE;
    2e88:	200b      	movs	r0, #11
}
    2e8a:	b005      	add	sp, #20
    2e8c:	bc3c      	pop	{r2, r3, r4, r5}
    2e8e:	4690      	mov	r8, r2
    2e90:	4699      	mov	r9, r3
    2e92:	46a2      	mov	sl, r4
    2e94:	46ab      	mov	fp, r5
    2e96:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    2e98:	200c      	movs	r0, #12
    2e9a:	e7f6      	b.n	2e8a <find_volume+0x3a6>
			return FR_OK;				/* The file system object is valid */
    2e9c:	2000      	movs	r0, #0
    2e9e:	e7f4      	b.n	2e8a <find_volume+0x3a6>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    2ea0:	2001      	movs	r0, #1
    2ea2:	e7f2      	b.n	2e8a <find_volume+0x3a6>
		return FR_NO_FILESYSTEM;
    2ea4:	200d      	movs	r0, #13
    2ea6:	e7f0      	b.n	2e8a <find_volume+0x3a6>
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
    2ea8:	200d      	movs	r0, #13
    2eaa:	e7ee      	b.n	2e8a <find_volume+0x3a6>
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    2eac:	200d      	movs	r0, #13
    2eae:	e7ec      	b.n	2e8a <find_volume+0x3a6>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    2eb0:	200d      	movs	r0, #13
    2eb2:	e7ea      	b.n	2e8a <find_volume+0x3a6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    2eb4:	200d      	movs	r0, #13
    2eb6:	e7e8      	b.n	2e8a <find_volume+0x3a6>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    2eb8:	200d      	movs	r0, #13
    2eba:	e7e6      	b.n	2e8a <find_volume+0x3a6>
		return FR_NO_FILESYSTEM;
    2ebc:	200d      	movs	r0, #13
    2ebe:	e7e4      	b.n	2e8a <find_volume+0x3a6>

00002ec0 <sync_fs>:
{
    2ec0:	b570      	push	{r4, r5, r6, lr}
    2ec2:	0005      	movs	r5, r0
	res = sync_window(fs);
    2ec4:	4b2e      	ldr	r3, [pc, #184]	; (2f80 <sync_fs+0xc0>)
    2ec6:	4798      	blx	r3
    2ec8:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
    2eca:	d10a      	bne.n	2ee2 <sync_fs+0x22>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    2ecc:	782b      	ldrb	r3, [r5, #0]
    2ece:	2b03      	cmp	r3, #3
    2ed0:	d009      	beq.n	2ee6 <sync_fs+0x26>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    2ed2:	7868      	ldrb	r0, [r5, #1]
    2ed4:	2200      	movs	r2, #0
    2ed6:	2100      	movs	r1, #0
    2ed8:	4b2a      	ldr	r3, [pc, #168]	; (2f84 <sync_fs+0xc4>)
    2eda:	4798      	blx	r3
    2edc:	2800      	cmp	r0, #0
    2ede:	d000      	beq.n	2ee2 <sync_fs+0x22>
			res = FR_DISK_ERR;
    2ee0:	2401      	movs	r4, #1
}
    2ee2:	0020      	movs	r0, r4
    2ee4:	bd70      	pop	{r4, r5, r6, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    2ee6:	796b      	ldrb	r3, [r5, #5]
    2ee8:	2b01      	cmp	r3, #1
    2eea:	d1f2      	bne.n	2ed2 <sync_fs+0x12>
			mem_set(fs->win, 0, SS(fs));
    2eec:	002e      	movs	r6, r5
    2eee:	3630      	adds	r6, #48	; 0x30
    2ef0:	2280      	movs	r2, #128	; 0x80
    2ef2:	0092      	lsls	r2, r2, #2
    2ef4:	2100      	movs	r1, #0
    2ef6:	0030      	movs	r0, r6
    2ef8:	4b23      	ldr	r3, [pc, #140]	; (2f88 <sync_fs+0xc8>)
    2efa:	4798      	blx	r3
			ST_WORD(fs->win + BS_55AA, 0xAA55);
    2efc:	2255      	movs	r2, #85	; 0x55
    2efe:	4b23      	ldr	r3, [pc, #140]	; (2f8c <sync_fs+0xcc>)
    2f00:	54ea      	strb	r2, [r5, r3]
    2f02:	3255      	adds	r2, #85	; 0x55
    2f04:	4b22      	ldr	r3, [pc, #136]	; (2f90 <sync_fs+0xd0>)
    2f06:	54ea      	strb	r2, [r5, r3]
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
    2f08:	3bde      	subs	r3, #222	; 0xde
    2f0a:	3bff      	subs	r3, #255	; 0xff
    2f0c:	3a7a      	subs	r2, #122	; 0x7a
    2f0e:	54ab      	strb	r3, [r5, r2]
    2f10:	3201      	adds	r2, #1
    2f12:	54ab      	strb	r3, [r5, r2]
    2f14:	330f      	adds	r3, #15
    2f16:	3201      	adds	r2, #1
    2f18:	54ab      	strb	r3, [r5, r2]
    2f1a:	320f      	adds	r2, #15
    2f1c:	2133      	movs	r1, #51	; 0x33
    2f1e:	546a      	strb	r2, [r5, r1]
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
    2f20:	313f      	adds	r1, #63	; 0x3f
    2f22:	2085      	movs	r0, #133	; 0x85
    2f24:	0080      	lsls	r0, r0, #2
    2f26:	5429      	strb	r1, [r5, r0]
    2f28:	481a      	ldr	r0, [pc, #104]	; (2f94 <sync_fs+0xd4>)
    2f2a:	5429      	strb	r1, [r5, r0]
    2f2c:	491a      	ldr	r1, [pc, #104]	; (2f98 <sync_fs+0xd8>)
    2f2e:	546a      	strb	r2, [r5, r1]
    2f30:	4a1a      	ldr	r2, [pc, #104]	; (2f9c <sync_fs+0xdc>)
    2f32:	54ab      	strb	r3, [r5, r2]
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
    2f34:	692b      	ldr	r3, [r5, #16]
    2f36:	3201      	adds	r2, #1
    2f38:	54ab      	strb	r3, [r5, r2]
    2f3a:	b29a      	uxth	r2, r3
    2f3c:	0a12      	lsrs	r2, r2, #8
    2f3e:	4918      	ldr	r1, [pc, #96]	; (2fa0 <sync_fs+0xe0>)
    2f40:	546a      	strb	r2, [r5, r1]
    2f42:	0c19      	lsrs	r1, r3, #16
    2f44:	4a17      	ldr	r2, [pc, #92]	; (2fa4 <sync_fs+0xe4>)
    2f46:	54a9      	strb	r1, [r5, r2]
    2f48:	0e1b      	lsrs	r3, r3, #24
    2f4a:	4a17      	ldr	r2, [pc, #92]	; (2fa8 <sync_fs+0xe8>)
    2f4c:	54ab      	strb	r3, [r5, r2]
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
    2f4e:	68eb      	ldr	r3, [r5, #12]
    2f50:	3201      	adds	r2, #1
    2f52:	54ab      	strb	r3, [r5, r2]
    2f54:	b29a      	uxth	r2, r3
    2f56:	0a12      	lsrs	r2, r2, #8
    2f58:	4914      	ldr	r1, [pc, #80]	; (2fac <sync_fs+0xec>)
    2f5a:	546a      	strb	r2, [r5, r1]
    2f5c:	0c19      	lsrs	r1, r3, #16
    2f5e:	4a14      	ldr	r2, [pc, #80]	; (2fb0 <sync_fs+0xf0>)
    2f60:	54a9      	strb	r1, [r5, r2]
    2f62:	0e1b      	lsrs	r3, r3, #24
    2f64:	4a13      	ldr	r2, [pc, #76]	; (2fb4 <sync_fs+0xf4>)
    2f66:	54ab      	strb	r3, [r5, r2]
			fs->winsect = fs->volbase + 1;
    2f68:	69eb      	ldr	r3, [r5, #28]
    2f6a:	1c5a      	adds	r2, r3, #1
    2f6c:	62ea      	str	r2, [r5, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
    2f6e:	7868      	ldrb	r0, [r5, #1]
    2f70:	2301      	movs	r3, #1
    2f72:	0031      	movs	r1, r6
    2f74:	4e10      	ldr	r6, [pc, #64]	; (2fb8 <sync_fs+0xf8>)
    2f76:	47b0      	blx	r6
			fs->fsi_flag = 0;
    2f78:	2300      	movs	r3, #0
    2f7a:	716b      	strb	r3, [r5, #5]
    2f7c:	e7a9      	b.n	2ed2 <sync_fs+0x12>
    2f7e:	46c0      	nop			; (mov r8, r8)
    2f80:	00002965 	.word	0x00002965
    2f84:	000025e5 	.word	0x000025e5
    2f88:	00002709 	.word	0x00002709
    2f8c:	0000022e 	.word	0x0000022e
    2f90:	0000022f 	.word	0x0000022f
    2f94:	00000215 	.word	0x00000215
    2f98:	00000216 	.word	0x00000216
    2f9c:	00000217 	.word	0x00000217
    2fa0:	00000219 	.word	0x00000219
    2fa4:	0000021a 	.word	0x0000021a
    2fa8:	0000021b 	.word	0x0000021b
    2fac:	0000021d 	.word	0x0000021d
    2fb0:	0000021e 	.word	0x0000021e
    2fb4:	0000021f 	.word	0x0000021f
    2fb8:	0000258d 	.word	0x0000258d

00002fbc <clust2sect>:
	clst -= 2;
    2fbc:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
    2fbe:	6943      	ldr	r3, [r0, #20]
    2fc0:	3b02      	subs	r3, #2
    2fc2:	4299      	cmp	r1, r3
    2fc4:	d204      	bcs.n	2fd0 <clust2sect+0x14>
	return clst * fs->csize + fs->database;
    2fc6:	7883      	ldrb	r3, [r0, #2]
    2fc8:	4359      	muls	r1, r3
    2fca:	6a80      	ldr	r0, [r0, #40]	; 0x28
    2fcc:	1808      	adds	r0, r1, r0
}
    2fce:	4770      	bx	lr
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
    2fd0:	2000      	movs	r0, #0
    2fd2:	e7fc      	b.n	2fce <clust2sect+0x12>

00002fd4 <get_fat>:
{
    2fd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2fd6:	0005      	movs	r5, r0
    2fd8:	000c      	movs	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2fda:	2901      	cmp	r1, #1
    2fdc:	d972      	bls.n	30c4 <get_fat+0xf0>
    2fde:	6943      	ldr	r3, [r0, #20]
    2fe0:	4299      	cmp	r1, r3
    2fe2:	d271      	bcs.n	30c8 <get_fat+0xf4>
		switch (fs->fs_type) {
    2fe4:	7803      	ldrb	r3, [r0, #0]
    2fe6:	2b02      	cmp	r3, #2
    2fe8:	d032      	beq.n	3050 <get_fat+0x7c>
    2fea:	2b03      	cmp	r3, #3
    2fec:	d049      	beq.n	3082 <get_fat+0xae>
    2fee:	2b01      	cmp	r3, #1
    2ff0:	d001      	beq.n	2ff6 <get_fat+0x22>
			val = 1;	/* Internal error */
    2ff2:	2001      	movs	r0, #1
    2ff4:	e069      	b.n	30ca <get_fat+0xf6>
			bc = (UINT)clst; bc += bc / 2;
    2ff6:	084e      	lsrs	r6, r1, #1
    2ff8:	198e      	adds	r6, r1, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    2ffa:	0a71      	lsrs	r1, r6, #9
    2ffc:	6a03      	ldr	r3, [r0, #32]
    2ffe:	469c      	mov	ip, r3
    3000:	4461      	add	r1, ip
    3002:	4b32      	ldr	r3, [pc, #200]	; (30cc <get_fat+0xf8>)
    3004:	4798      	blx	r3
    3006:	2800      	cmp	r0, #0
    3008:	d002      	beq.n	3010 <get_fat+0x3c>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    300a:	2001      	movs	r0, #1
    300c:	4240      	negs	r0, r0
    300e:	e05c      	b.n	30ca <get_fat+0xf6>
			wc = fs->win[bc++ % SS(fs)];
    3010:	1c77      	adds	r7, r6, #1
    3012:	05f3      	lsls	r3, r6, #23
    3014:	0ddb      	lsrs	r3, r3, #23
    3016:	18eb      	adds	r3, r5, r3
    3018:	3330      	adds	r3, #48	; 0x30
    301a:	781e      	ldrb	r6, [r3, #0]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    301c:	0a79      	lsrs	r1, r7, #9
    301e:	6a2b      	ldr	r3, [r5, #32]
    3020:	469c      	mov	ip, r3
    3022:	4461      	add	r1, ip
    3024:	0028      	movs	r0, r5
    3026:	4b29      	ldr	r3, [pc, #164]	; (30cc <get_fat+0xf8>)
    3028:	4798      	blx	r3
    302a:	2800      	cmp	r0, #0
    302c:	d002      	beq.n	3034 <get_fat+0x60>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    302e:	2001      	movs	r0, #1
    3030:	4240      	negs	r0, r0
    3032:	e04a      	b.n	30ca <get_fat+0xf6>
			wc |= fs->win[bc % SS(fs)] << 8;
    3034:	05ff      	lsls	r7, r7, #23
    3036:	0dff      	lsrs	r7, r7, #23
    3038:	19ed      	adds	r5, r5, r7
    303a:	3530      	adds	r5, #48	; 0x30
    303c:	7828      	ldrb	r0, [r5, #0]
    303e:	0200      	lsls	r0, r0, #8
    3040:	4330      	orrs	r0, r6
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
    3042:	07e3      	lsls	r3, r4, #31
    3044:	d501      	bpl.n	304a <get_fat+0x76>
    3046:	0900      	lsrs	r0, r0, #4
    3048:	e03f      	b.n	30ca <get_fat+0xf6>
    304a:	0500      	lsls	r0, r0, #20
    304c:	0d00      	lsrs	r0, r0, #20
    304e:	e03c      	b.n	30ca <get_fat+0xf6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
    3050:	0a09      	lsrs	r1, r1, #8
    3052:	6a03      	ldr	r3, [r0, #32]
    3054:	469c      	mov	ip, r3
    3056:	4461      	add	r1, ip
    3058:	4b1c      	ldr	r3, [pc, #112]	; (30cc <get_fat+0xf8>)
    305a:	4798      	blx	r3
    305c:	2800      	cmp	r0, #0
    305e:	d002      	beq.n	3066 <get_fat+0x92>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    3060:	2001      	movs	r0, #1
    3062:	4240      	negs	r0, r0
    3064:	e031      	b.n	30ca <get_fat+0xf6>
			p = &fs->win[clst * 2 % SS(fs)];
    3066:	0064      	lsls	r4, r4, #1
    3068:	23ff      	movs	r3, #255	; 0xff
    306a:	005b      	lsls	r3, r3, #1
    306c:	401c      	ands	r4, r3
    306e:	0023      	movs	r3, r4
    3070:	3330      	adds	r3, #48	; 0x30
    3072:	18eb      	adds	r3, r5, r3
			val = LD_WORD(p);
    3074:	785b      	ldrb	r3, [r3, #1]
    3076:	021b      	lsls	r3, r3, #8
    3078:	192c      	adds	r4, r5, r4
    307a:	3430      	adds	r4, #48	; 0x30
    307c:	7820      	ldrb	r0, [r4, #0]
    307e:	4318      	orrs	r0, r3
			break;
    3080:	e023      	b.n	30ca <get_fat+0xf6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
    3082:	09c9      	lsrs	r1, r1, #7
    3084:	6a03      	ldr	r3, [r0, #32]
    3086:	469c      	mov	ip, r3
    3088:	4461      	add	r1, ip
    308a:	4b10      	ldr	r3, [pc, #64]	; (30cc <get_fat+0xf8>)
    308c:	4798      	blx	r3
    308e:	2800      	cmp	r0, #0
    3090:	d002      	beq.n	3098 <get_fat+0xc4>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    3092:	2001      	movs	r0, #1
    3094:	4240      	negs	r0, r0
	return val;
    3096:	e018      	b.n	30ca <get_fat+0xf6>
			p = &fs->win[clst * 4 % SS(fs)];
    3098:	00a4      	lsls	r4, r4, #2
    309a:	23fe      	movs	r3, #254	; 0xfe
    309c:	005b      	lsls	r3, r3, #1
    309e:	401c      	ands	r4, r3
    30a0:	0023      	movs	r3, r4
    30a2:	3330      	adds	r3, #48	; 0x30
    30a4:	18eb      	adds	r3, r5, r3
			val = LD_DWORD(p) & 0x0FFFFFFF;
    30a6:	78d8      	ldrb	r0, [r3, #3]
    30a8:	0600      	lsls	r0, r0, #24
    30aa:	789a      	ldrb	r2, [r3, #2]
    30ac:	0412      	lsls	r2, r2, #16
    30ae:	4310      	orrs	r0, r2
    30b0:	785b      	ldrb	r3, [r3, #1]
    30b2:	021b      	lsls	r3, r3, #8
    30b4:	4318      	orrs	r0, r3
    30b6:	192c      	adds	r4, r5, r4
    30b8:	3430      	adds	r4, #48	; 0x30
    30ba:	7823      	ldrb	r3, [r4, #0]
    30bc:	4318      	orrs	r0, r3
    30be:	0100      	lsls	r0, r0, #4
    30c0:	0900      	lsrs	r0, r0, #4
			break;
    30c2:	e002      	b.n	30ca <get_fat+0xf6>
		val = 1;	/* Internal error */
    30c4:	2001      	movs	r0, #1
    30c6:	e000      	b.n	30ca <get_fat+0xf6>
    30c8:	2001      	movs	r0, #1
}
    30ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    30cc:	000029cd 	.word	0x000029cd

000030d0 <dir_sdi>:
{
    30d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    30d2:	0005      	movs	r5, r0
    30d4:	000e      	movs	r6, r1
	dp->index = (WORD)idx;	/* Current index */
    30d6:	80e9      	strh	r1, [r5, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
    30d8:	6884      	ldr	r4, [r0, #8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
    30da:	2c01      	cmp	r4, #1
    30dc:	d03d      	beq.n	315a <dir_sdi+0x8a>
    30de:	6803      	ldr	r3, [r0, #0]
    30e0:	695a      	ldr	r2, [r3, #20]
    30e2:	4294      	cmp	r4, r2
    30e4:	d301      	bcc.n	30ea <dir_sdi+0x1a>
		return FR_INT_ERR;
    30e6:	2002      	movs	r0, #2
    30e8:	e038      	b.n	315c <dir_sdi+0x8c>
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    30ea:	2c00      	cmp	r4, #0
    30ec:	d102      	bne.n	30f4 <dir_sdi+0x24>
    30ee:	781a      	ldrb	r2, [r3, #0]
    30f0:	2a03      	cmp	r2, #3
    30f2:	d006      	beq.n	3102 <dir_sdi+0x32>
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
    30f4:	2c00      	cmp	r4, #0
    30f6:	d10c      	bne.n	3112 <dir_sdi+0x42>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
    30f8:	891a      	ldrh	r2, [r3, #8]
    30fa:	4296      	cmp	r6, r2
    30fc:	d303      	bcc.n	3106 <dir_sdi+0x36>
			return FR_INT_ERR;
    30fe:	2002      	movs	r0, #2
    3100:	e02c      	b.n	315c <dir_sdi+0x8c>
		clst = dp->fs->dirbase;
    3102:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    3104:	e7f6      	b.n	30f4 <dir_sdi+0x24>
		sect = dp->fs->dirbase;
    3106:	6a58      	ldr	r0, [r3, #36]	; 0x24
	dp->clust = clst;	/* Current cluster# */
    3108:	60ec      	str	r4, [r5, #12]
	if (!sect) return FR_INT_ERR;
    310a:	2800      	cmp	r0, #0
    310c:	d119      	bne.n	3142 <dir_sdi+0x72>
    310e:	2002      	movs	r0, #2
    3110:	e024      	b.n	315c <dir_sdi+0x8c>
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
    3112:	789f      	ldrb	r7, [r3, #2]
    3114:	013f      	lsls	r7, r7, #4
		while (idx >= ic) {	/* Follow cluster chain */
    3116:	42be      	cmp	r6, r7
    3118:	d30e      	bcc.n	3138 <dir_sdi+0x68>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
    311a:	0021      	movs	r1, r4
    311c:	6828      	ldr	r0, [r5, #0]
    311e:	4b13      	ldr	r3, [pc, #76]	; (316c <dir_sdi+0x9c>)
    3120:	4798      	blx	r3
    3122:	0004      	movs	r4, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3124:	1c43      	adds	r3, r0, #1
    3126:	d01a      	beq.n	315e <dir_sdi+0x8e>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
    3128:	2801      	cmp	r0, #1
    312a:	d91a      	bls.n	3162 <dir_sdi+0x92>
    312c:	682b      	ldr	r3, [r5, #0]
    312e:	695b      	ldr	r3, [r3, #20]
    3130:	4298      	cmp	r0, r3
    3132:	d218      	bcs.n	3166 <dir_sdi+0x96>
			idx -= ic;
    3134:	1bf6      	subs	r6, r6, r7
    3136:	e7ee      	b.n	3116 <dir_sdi+0x46>
		sect = clust2sect(dp->fs, clst);
    3138:	0021      	movs	r1, r4
    313a:	6828      	ldr	r0, [r5, #0]
    313c:	4b0c      	ldr	r3, [pc, #48]	; (3170 <dir_sdi+0xa0>)
    313e:	4798      	blx	r3
    3140:	e7e2      	b.n	3108 <dir_sdi+0x38>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
    3142:	0933      	lsrs	r3, r6, #4
    3144:	18c0      	adds	r0, r0, r3
    3146:	6128      	str	r0, [r5, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
    3148:	682b      	ldr	r3, [r5, #0]
    314a:	3330      	adds	r3, #48	; 0x30
    314c:	220f      	movs	r2, #15
    314e:	4016      	ands	r6, r2
    3150:	0176      	lsls	r6, r6, #5
    3152:	199e      	adds	r6, r3, r6
    3154:	616e      	str	r6, [r5, #20]
	return FR_OK;
    3156:	2000      	movs	r0, #0
    3158:	e000      	b.n	315c <dir_sdi+0x8c>
		return FR_INT_ERR;
    315a:	2002      	movs	r0, #2
}
    315c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    315e:	2001      	movs	r0, #1
    3160:	e7fc      	b.n	315c <dir_sdi+0x8c>
				return FR_INT_ERR;
    3162:	2002      	movs	r0, #2
    3164:	e7fa      	b.n	315c <dir_sdi+0x8c>
    3166:	2002      	movs	r0, #2
    3168:	e7f8      	b.n	315c <dir_sdi+0x8c>
    316a:	46c0      	nop			; (mov r8, r8)
    316c:	00002fd5 	.word	0x00002fd5
    3170:	00002fbd 	.word	0x00002fbd

00003174 <put_fat>:
{
    3174:	b5f0      	push	{r4, r5, r6, r7, lr}
    3176:	46c6      	mov	lr, r8
    3178:	b500      	push	{lr}
    317a:	0006      	movs	r6, r0
    317c:	000c      	movs	r4, r1
    317e:	0015      	movs	r5, r2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    3180:	2901      	cmp	r1, #1
    3182:	d800      	bhi.n	3186 <put_fat+0x12>
    3184:	e08d      	b.n	32a2 <put_fat+0x12e>
    3186:	6943      	ldr	r3, [r0, #20]
    3188:	4299      	cmp	r1, r3
    318a:	d301      	bcc.n	3190 <put_fat+0x1c>
		res = FR_INT_ERR;
    318c:	2002      	movs	r0, #2
    318e:	e089      	b.n	32a4 <put_fat+0x130>
		switch (fs->fs_type) {
    3190:	7803      	ldrb	r3, [r0, #0]
    3192:	2b02      	cmp	r3, #2
    3194:	d04d      	beq.n	3232 <put_fat+0xbe>
    3196:	2b03      	cmp	r3, #3
    3198:	d063      	beq.n	3262 <put_fat+0xee>
    319a:	2b01      	cmp	r3, #1
    319c:	d001      	beq.n	31a2 <put_fat+0x2e>
			res = FR_INT_ERR;
    319e:	2002      	movs	r0, #2
    31a0:	e080      	b.n	32a4 <put_fat+0x130>
			bc = (UINT)clst; bc += bc / 2;
    31a2:	084f      	lsrs	r7, r1, #1
    31a4:	19cf      	adds	r7, r1, r7
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    31a6:	0a79      	lsrs	r1, r7, #9
    31a8:	6a03      	ldr	r3, [r0, #32]
    31aa:	469c      	mov	ip, r3
    31ac:	4461      	add	r1, ip
    31ae:	4b3f      	ldr	r3, [pc, #252]	; (32ac <put_fat+0x138>)
    31b0:	4798      	blx	r3
			if (res != FR_OK) break;
    31b2:	2800      	cmp	r0, #0
    31b4:	d176      	bne.n	32a4 <put_fat+0x130>
			p = &fs->win[bc++ % SS(fs)];
    31b6:	1c7b      	adds	r3, r7, #1
    31b8:	4698      	mov	r8, r3
    31ba:	05ff      	lsls	r7, r7, #23
    31bc:	0dff      	lsrs	r7, r7, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    31be:	2301      	movs	r3, #1
    31c0:	401c      	ands	r4, r3
    31c2:	d027      	beq.n	3214 <put_fat+0xa0>
    31c4:	19f3      	adds	r3, r6, r7
    31c6:	3330      	adds	r3, #48	; 0x30
    31c8:	2200      	movs	r2, #0
    31ca:	569a      	ldrsb	r2, [r3, r2]
    31cc:	230f      	movs	r3, #15
    31ce:	4013      	ands	r3, r2
    31d0:	012a      	lsls	r2, r5, #4
    31d2:	21ff      	movs	r1, #255	; 0xff
    31d4:	0109      	lsls	r1, r1, #4
    31d6:	400a      	ands	r2, r1
    31d8:	4313      	orrs	r3, r2
    31da:	b2db      	uxtb	r3, r3
    31dc:	19f7      	adds	r7, r6, r7
    31de:	3730      	adds	r7, #48	; 0x30
    31e0:	703b      	strb	r3, [r7, #0]
			fs->wflag = 1;
    31e2:	2301      	movs	r3, #1
    31e4:	7133      	strb	r3, [r6, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    31e6:	4643      	mov	r3, r8
    31e8:	0a59      	lsrs	r1, r3, #9
    31ea:	6a33      	ldr	r3, [r6, #32]
    31ec:	469c      	mov	ip, r3
    31ee:	4461      	add	r1, ip
    31f0:	0030      	movs	r0, r6
    31f2:	4b2e      	ldr	r3, [pc, #184]	; (32ac <put_fat+0x138>)
    31f4:	4798      	blx	r3
			if (res != FR_OK) break;
    31f6:	2800      	cmp	r0, #0
    31f8:	d154      	bne.n	32a4 <put_fat+0x130>
			p = &fs->win[bc % SS(fs)];
    31fa:	4643      	mov	r3, r8
    31fc:	05db      	lsls	r3, r3, #23
    31fe:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    3200:	2c00      	cmp	r4, #0
    3202:	d009      	beq.n	3218 <put_fat+0xa4>
    3204:	092d      	lsrs	r5, r5, #4
    3206:	b2ed      	uxtb	r5, r5
    3208:	18f3      	adds	r3, r6, r3
    320a:	3330      	adds	r3, #48	; 0x30
    320c:	701d      	strb	r5, [r3, #0]
			fs->wflag = 1;
    320e:	2301      	movs	r3, #1
    3210:	7133      	strb	r3, [r6, #4]
			break;
    3212:	e047      	b.n	32a4 <put_fat+0x130>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    3214:	b2eb      	uxtb	r3, r5
    3216:	e7e1      	b.n	31dc <put_fat+0x68>
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    3218:	18f2      	adds	r2, r6, r3
    321a:	3230      	adds	r2, #48	; 0x30
    321c:	7812      	ldrb	r2, [r2, #0]
    321e:	b252      	sxtb	r2, r2
    3220:	210f      	movs	r1, #15
    3222:	438a      	bics	r2, r1
    3224:	0a2d      	lsrs	r5, r5, #8
    3226:	b269      	sxtb	r1, r5
    3228:	250f      	movs	r5, #15
    322a:	400d      	ands	r5, r1
    322c:	4315      	orrs	r5, r2
    322e:	b2ed      	uxtb	r5, r5
    3230:	e7ea      	b.n	3208 <put_fat+0x94>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    3232:	0a09      	lsrs	r1, r1, #8
    3234:	6a03      	ldr	r3, [r0, #32]
    3236:	469c      	mov	ip, r3
    3238:	4461      	add	r1, ip
    323a:	4b1c      	ldr	r3, [pc, #112]	; (32ac <put_fat+0x138>)
    323c:	4798      	blx	r3
			if (res != FR_OK) break;
    323e:	2800      	cmp	r0, #0
    3240:	d130      	bne.n	32a4 <put_fat+0x130>
			p = &fs->win[clst * 2 % SS(fs)];
    3242:	0064      	lsls	r4, r4, #1
    3244:	23ff      	movs	r3, #255	; 0xff
    3246:	005b      	lsls	r3, r3, #1
    3248:	401c      	ands	r4, r3
    324a:	0023      	movs	r3, r4
    324c:	3330      	adds	r3, #48	; 0x30
    324e:	18f3      	adds	r3, r6, r3
			ST_WORD(p, (WORD)val);
    3250:	1934      	adds	r4, r6, r4
    3252:	3430      	adds	r4, #48	; 0x30
    3254:	7025      	strb	r5, [r4, #0]
    3256:	b2ad      	uxth	r5, r5
    3258:	0a2d      	lsrs	r5, r5, #8
    325a:	705d      	strb	r5, [r3, #1]
			fs->wflag = 1;
    325c:	2301      	movs	r3, #1
    325e:	7133      	strb	r3, [r6, #4]
			break;
    3260:	e020      	b.n	32a4 <put_fat+0x130>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    3262:	09c9      	lsrs	r1, r1, #7
    3264:	6a03      	ldr	r3, [r0, #32]
    3266:	469c      	mov	ip, r3
    3268:	4461      	add	r1, ip
    326a:	4b10      	ldr	r3, [pc, #64]	; (32ac <put_fat+0x138>)
    326c:	4798      	blx	r3
			if (res != FR_OK) break;
    326e:	2800      	cmp	r0, #0
    3270:	d118      	bne.n	32a4 <put_fat+0x130>
			p = &fs->win[clst * 4 % SS(fs)];
    3272:	00a4      	lsls	r4, r4, #2
    3274:	23fe      	movs	r3, #254	; 0xfe
    3276:	005b      	lsls	r3, r3, #1
    3278:	401c      	ands	r4, r3
    327a:	0023      	movs	r3, r4
    327c:	3330      	adds	r3, #48	; 0x30
    327e:	18f3      	adds	r3, r6, r3
			val |= LD_DWORD(p) & 0xF0000000;
    3280:	78da      	ldrb	r2, [r3, #3]
    3282:	1934      	adds	r4, r6, r4
    3284:	3430      	adds	r4, #48	; 0x30
    3286:	0912      	lsrs	r2, r2, #4
    3288:	0712      	lsls	r2, r2, #28
    328a:	4315      	orrs	r5, r2
			ST_DWORD(p, val);
    328c:	7025      	strb	r5, [r4, #0]
    328e:	b2aa      	uxth	r2, r5
    3290:	0a12      	lsrs	r2, r2, #8
    3292:	705a      	strb	r2, [r3, #1]
    3294:	0c2a      	lsrs	r2, r5, #16
    3296:	709a      	strb	r2, [r3, #2]
    3298:	0e2d      	lsrs	r5, r5, #24
    329a:	70dd      	strb	r5, [r3, #3]
			fs->wflag = 1;
    329c:	2301      	movs	r3, #1
    329e:	7133      	strb	r3, [r6, #4]
			break;
    32a0:	e000      	b.n	32a4 <put_fat+0x130>
		res = FR_INT_ERR;
    32a2:	2002      	movs	r0, #2
}
    32a4:	bc04      	pop	{r2}
    32a6:	4690      	mov	r8, r2
    32a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    32aa:	46c0      	nop			; (mov r8, r8)
    32ac:	000029cd 	.word	0x000029cd

000032b0 <create_chain>:
{
    32b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    32b2:	0005      	movs	r5, r0
    32b4:	1e0f      	subs	r7, r1, #0
	if (clst == 0) {		/* Create a new chain */
    32b6:	d107      	bne.n	32c8 <create_chain+0x18>
		scl = fs->last_clust;			/* Get suggested start point */
    32b8:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
    32ba:	2e00      	cmp	r6, #0
    32bc:	d00f      	beq.n	32de <create_chain+0x2e>
    32be:	6943      	ldr	r3, [r0, #20]
    32c0:	429e      	cmp	r6, r3
    32c2:	d30d      	bcc.n	32e0 <create_chain+0x30>
    32c4:	2601      	movs	r6, #1
    32c6:	e00b      	b.n	32e0 <create_chain+0x30>
		cs = get_fat(fs, clst);			/* Check the cluster status */
    32c8:	4b26      	ldr	r3, [pc, #152]	; (3364 <create_chain+0xb4>)
    32ca:	4798      	blx	r3
		if (cs < 2) return 1;			/* Invalid value */
    32cc:	2801      	cmp	r0, #1
    32ce:	d940      	bls.n	3352 <create_chain+0xa2>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
    32d0:	1c43      	adds	r3, r0, #1
    32d2:	d043      	beq.n	335c <create_chain+0xac>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    32d4:	696b      	ldr	r3, [r5, #20]
    32d6:	4298      	cmp	r0, r3
    32d8:	d340      	bcc.n	335c <create_chain+0xac>
		scl = clst;
    32da:	003e      	movs	r6, r7
    32dc:	e000      	b.n	32e0 <create_chain+0x30>
		if (!scl || scl >= fs->n_fatent) scl = 1;
    32de:	2601      	movs	r6, #1
	ncl = scl;				/* Start cluster */
    32e0:	0034      	movs	r4, r6
    32e2:	e00b      	b.n	32fc <create_chain+0x4c>
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    32e4:	0021      	movs	r1, r4
    32e6:	0028      	movs	r0, r5
    32e8:	4b1e      	ldr	r3, [pc, #120]	; (3364 <create_chain+0xb4>)
    32ea:	4798      	blx	r3
		if (cs == 0) break;				/* Found a free cluster */
    32ec:	2800      	cmp	r0, #0
    32ee:	d00d      	beq.n	330c <create_chain+0x5c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    32f0:	1c43      	adds	r3, r0, #1
    32f2:	d033      	beq.n	335c <create_chain+0xac>
    32f4:	2801      	cmp	r0, #1
    32f6:	d031      	beq.n	335c <create_chain+0xac>
		if (ncl == scl) return 0;		/* No free cluster */
    32f8:	42b4      	cmp	r4, r6
    32fa:	d02e      	beq.n	335a <create_chain+0xaa>
		ncl++;							/* Next cluster */
    32fc:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
    32fe:	696b      	ldr	r3, [r5, #20]
    3300:	429c      	cmp	r4, r3
    3302:	d3ef      	bcc.n	32e4 <create_chain+0x34>
			if (ncl > scl) return 0;	/* No free cluster */
    3304:	2e01      	cmp	r6, #1
    3306:	d926      	bls.n	3356 <create_chain+0xa6>
			ncl = 2;
    3308:	2402      	movs	r4, #2
    330a:	e7eb      	b.n	32e4 <create_chain+0x34>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    330c:	4a16      	ldr	r2, [pc, #88]	; (3368 <create_chain+0xb8>)
    330e:	0021      	movs	r1, r4
    3310:	0028      	movs	r0, r5
    3312:	4b16      	ldr	r3, [pc, #88]	; (336c <create_chain+0xbc>)
    3314:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
    3316:	2800      	cmp	r0, #0
    3318:	d101      	bne.n	331e <create_chain+0x6e>
    331a:	2f00      	cmp	r7, #0
    331c:	d10d      	bne.n	333a <create_chain+0x8a>
	if (res == FR_OK) {
    331e:	2800      	cmp	r0, #0
    3320:	d111      	bne.n	3346 <create_chain+0x96>
		fs->last_clust = ncl;			/* Update FSINFO */
    3322:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
    3324:	692b      	ldr	r3, [r5, #16]
    3326:	1c5a      	adds	r2, r3, #1
    3328:	d019      	beq.n	335e <create_chain+0xae>
			fs->free_clust--;
    332a:	3b01      	subs	r3, #1
    332c:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
    332e:	796b      	ldrb	r3, [r5, #5]
    3330:	2201      	movs	r2, #1
    3332:	4313      	orrs	r3, r2
    3334:	716b      	strb	r3, [r5, #5]
    3336:	0020      	movs	r0, r4
    3338:	e010      	b.n	335c <create_chain+0xac>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    333a:	0022      	movs	r2, r4
    333c:	0039      	movs	r1, r7
    333e:	0028      	movs	r0, r5
    3340:	4b0a      	ldr	r3, [pc, #40]	; (336c <create_chain+0xbc>)
    3342:	4798      	blx	r3
    3344:	e7eb      	b.n	331e <create_chain+0x6e>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    3346:	2801      	cmp	r0, #1
    3348:	d001      	beq.n	334e <create_chain+0x9e>
    334a:	2001      	movs	r0, #1
    334c:	e006      	b.n	335c <create_chain+0xac>
    334e:	3802      	subs	r0, #2
    3350:	e004      	b.n	335c <create_chain+0xac>
		if (cs < 2) return 1;			/* Invalid value */
    3352:	2001      	movs	r0, #1
    3354:	e002      	b.n	335c <create_chain+0xac>
			if (ncl > scl) return 0;	/* No free cluster */
    3356:	2000      	movs	r0, #0
    3358:	e000      	b.n	335c <create_chain+0xac>
		if (ncl == scl) return 0;		/* No free cluster */
    335a:	2000      	movs	r0, #0
}
    335c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    335e:	0020      	movs	r0, r4
    3360:	e7fc      	b.n	335c <create_chain+0xac>
    3362:	46c0      	nop			; (mov r8, r8)
    3364:	00002fd5 	.word	0x00002fd5
    3368:	0fffffff 	.word	0x0fffffff
    336c:	00003175 	.word	0x00003175

00003370 <dir_next>:
{
    3370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3372:	46ce      	mov	lr, r9
    3374:	4647      	mov	r7, r8
    3376:	b580      	push	{r7, lr}
    3378:	0006      	movs	r6, r0
    337a:	000d      	movs	r5, r1
	i = dp->index + 1;
    337c:	88c4      	ldrh	r4, [r0, #6]
    337e:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    3380:	0423      	lsls	r3, r4, #16
    3382:	d104      	bne.n	338e <dir_next+0x1e>
		return FR_NO_FILE;
    3384:	2004      	movs	r0, #4
}
    3386:	bc0c      	pop	{r2, r3}
    3388:	4690      	mov	r8, r2
    338a:	4699      	mov	r9, r3
    338c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    338e:	6903      	ldr	r3, [r0, #16]
    3390:	2b00      	cmp	r3, #0
    3392:	d101      	bne.n	3398 <dir_next+0x28>
		return FR_NO_FILE;
    3394:	2004      	movs	r0, #4
    3396:	e7f6      	b.n	3386 <dir_next+0x16>
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
    3398:	270f      	movs	r7, #15
    339a:	4027      	ands	r7, r4
    339c:	d111      	bne.n	33c2 <dir_next+0x52>
		dp->sect++;					/* Next sector */
    339e:	3301      	adds	r3, #1
    33a0:	6103      	str	r3, [r0, #16]
		if (!dp->clust) {		/* Static table */
    33a2:	68c1      	ldr	r1, [r0, #12]
    33a4:	2900      	cmp	r1, #0
    33a6:	d105      	bne.n	33b4 <dir_next+0x44>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
    33a8:	6803      	ldr	r3, [r0, #0]
    33aa:	891b      	ldrh	r3, [r3, #8]
    33ac:	429c      	cmp	r4, r3
    33ae:	d308      	bcc.n	33c2 <dir_next+0x52>
				return FR_NO_FILE;
    33b0:	2004      	movs	r0, #4
    33b2:	e7e8      	b.n	3386 <dir_next+0x16>
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
    33b4:	0923      	lsrs	r3, r4, #4
    33b6:	6800      	ldr	r0, [r0, #0]
    33b8:	7882      	ldrb	r2, [r0, #2]
    33ba:	3a01      	subs	r2, #1
    33bc:	401a      	ands	r2, r3
    33be:	4690      	mov	r8, r2
    33c0:	d007      	beq.n	33d2 <dir_next+0x62>
	dp->index = (WORD)i;	/* Current index */
    33c2:	80f4      	strh	r4, [r6, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
    33c4:	6833      	ldr	r3, [r6, #0]
    33c6:	3330      	adds	r3, #48	; 0x30
    33c8:	017f      	lsls	r7, r7, #5
    33ca:	19df      	adds	r7, r3, r7
    33cc:	6177      	str	r7, [r6, #20]
	return FR_OK;
    33ce:	2000      	movs	r0, #0
    33d0:	e7d9      	b.n	3386 <dir_next+0x16>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
    33d2:	4b2c      	ldr	r3, [pc, #176]	; (3484 <dir_next+0x114>)
    33d4:	4798      	blx	r3
    33d6:	4681      	mov	r9, r0
				if (clst <= 1) return FR_INT_ERR;
    33d8:	0003      	movs	r3, r0
    33da:	2801      	cmp	r0, #1
    33dc:	d946      	bls.n	346c <dir_next+0xfc>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    33de:	3301      	adds	r3, #1
    33e0:	d046      	beq.n	3470 <dir_next+0x100>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
    33e2:	6830      	ldr	r0, [r6, #0]
    33e4:	6943      	ldr	r3, [r0, #20]
    33e6:	4599      	cmp	r9, r3
    33e8:	d338      	bcc.n	345c <dir_next+0xec>
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
    33ea:	2d00      	cmp	r5, #0
    33ec:	d101      	bne.n	33f2 <dir_next+0x82>
    33ee:	2004      	movs	r0, #4
    33f0:	e7c9      	b.n	3386 <dir_next+0x16>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
    33f2:	68f1      	ldr	r1, [r6, #12]
    33f4:	4b24      	ldr	r3, [pc, #144]	; (3488 <dir_next+0x118>)
    33f6:	4798      	blx	r3
    33f8:	4681      	mov	r9, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    33fa:	1e03      	subs	r3, r0, #0
    33fc:	d101      	bne.n	3402 <dir_next+0x92>
    33fe:	2007      	movs	r0, #7
    3400:	e7c1      	b.n	3386 <dir_next+0x16>
					if (clst == 1) return FR_INT_ERR;
    3402:	2801      	cmp	r0, #1
    3404:	d036      	beq.n	3474 <dir_next+0x104>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    3406:	3301      	adds	r3, #1
    3408:	d036      	beq.n	3478 <dir_next+0x108>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
    340a:	6830      	ldr	r0, [r6, #0]
    340c:	4b1f      	ldr	r3, [pc, #124]	; (348c <dir_next+0x11c>)
    340e:	4798      	blx	r3
    3410:	2800      	cmp	r0, #0
    3412:	d133      	bne.n	347c <dir_next+0x10c>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
    3414:	6830      	ldr	r0, [r6, #0]
    3416:	3030      	adds	r0, #48	; 0x30
    3418:	2280      	movs	r2, #128	; 0x80
    341a:	0092      	lsls	r2, r2, #2
    341c:	2100      	movs	r1, #0
    341e:	4b1c      	ldr	r3, [pc, #112]	; (3490 <dir_next+0x120>)
    3420:	4798      	blx	r3
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
    3422:	6835      	ldr	r5, [r6, #0]
    3424:	4649      	mov	r1, r9
    3426:	0028      	movs	r0, r5
    3428:	4b1a      	ldr	r3, [pc, #104]	; (3494 <dir_next+0x124>)
    342a:	4798      	blx	r3
    342c:	62e8      	str	r0, [r5, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    342e:	6833      	ldr	r3, [r6, #0]
    3430:	789a      	ldrb	r2, [r3, #2]
    3432:	4590      	cmp	r8, r2
    3434:	d20e      	bcs.n	3454 <dir_next+0xe4>
						dp->fs->wflag = 1;
    3436:	2201      	movs	r2, #1
    3438:	711a      	strb	r2, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    343a:	6830      	ldr	r0, [r6, #0]
    343c:	4b13      	ldr	r3, [pc, #76]	; (348c <dir_next+0x11c>)
    343e:	4798      	blx	r3
    3440:	2800      	cmp	r0, #0
    3442:	d11d      	bne.n	3480 <dir_next+0x110>
						dp->fs->winsect++;
    3444:	6832      	ldr	r2, [r6, #0]
    3446:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    3448:	3301      	adds	r3, #1
    344a:	62d3      	str	r3, [r2, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    344c:	2301      	movs	r3, #1
    344e:	469c      	mov	ip, r3
    3450:	44e0      	add	r8, ip
    3452:	e7ec      	b.n	342e <dir_next+0xbe>
					dp->fs->winsect -= c;						/* Rewind window offset */
    3454:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3456:	4641      	mov	r1, r8
    3458:	1a52      	subs	r2, r2, r1
    345a:	62da      	str	r2, [r3, #44]	; 0x2c
				dp->clust = clst;				/* Initialize data for new cluster */
    345c:	464b      	mov	r3, r9
    345e:	60f3      	str	r3, [r6, #12]
				dp->sect = clust2sect(dp->fs, clst);
    3460:	4649      	mov	r1, r9
    3462:	6830      	ldr	r0, [r6, #0]
    3464:	4b0b      	ldr	r3, [pc, #44]	; (3494 <dir_next+0x124>)
    3466:	4798      	blx	r3
    3468:	6130      	str	r0, [r6, #16]
    346a:	e7aa      	b.n	33c2 <dir_next+0x52>
				if (clst <= 1) return FR_INT_ERR;
    346c:	2002      	movs	r0, #2
    346e:	e78a      	b.n	3386 <dir_next+0x16>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    3470:	2001      	movs	r0, #1
    3472:	e788      	b.n	3386 <dir_next+0x16>
					if (clst == 1) return FR_INT_ERR;
    3474:	2002      	movs	r0, #2
    3476:	e786      	b.n	3386 <dir_next+0x16>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    3478:	2001      	movs	r0, #1
    347a:	e784      	b.n	3386 <dir_next+0x16>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
    347c:	2001      	movs	r0, #1
    347e:	e782      	b.n	3386 <dir_next+0x16>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    3480:	2001      	movs	r0, #1
    3482:	e780      	b.n	3386 <dir_next+0x16>
    3484:	00002fd5 	.word	0x00002fd5
    3488:	000032b1 	.word	0x000032b1
    348c:	00002965 	.word	0x00002965
    3490:	00002709 	.word	0x00002709
    3494:	00002fbd 	.word	0x00002fbd

00003498 <dir_find>:
{
    3498:	b570      	push	{r4, r5, r6, lr}
    349a:	0005      	movs	r5, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
    349c:	2100      	movs	r1, #0
    349e:	4b11      	ldr	r3, [pc, #68]	; (34e4 <dir_find+0x4c>)
    34a0:	4798      	blx	r3
    34a2:	1e04      	subs	r4, r0, #0
	if (res != FR_OK) return res;
    34a4:	d007      	beq.n	34b6 <dir_find+0x1e>
}
    34a6:	0020      	movs	r0, r4
    34a8:	bd70      	pop	{r4, r5, r6, pc}
		res = dir_next(dp, 0);		/* Next entry */
    34aa:	2100      	movs	r1, #0
    34ac:	0028      	movs	r0, r5
    34ae:	4b0e      	ldr	r3, [pc, #56]	; (34e8 <dir_find+0x50>)
    34b0:	4798      	blx	r3
    34b2:	1e04      	subs	r4, r0, #0
	} while (res == FR_OK);
    34b4:	d1f7      	bne.n	34a6 <dir_find+0xe>
		res = move_window(dp->fs, dp->sect);
    34b6:	6929      	ldr	r1, [r5, #16]
    34b8:	6828      	ldr	r0, [r5, #0]
    34ba:	4b0c      	ldr	r3, [pc, #48]	; (34ec <dir_find+0x54>)
    34bc:	4798      	blx	r3
    34be:	1e04      	subs	r4, r0, #0
		if (res != FR_OK) break;
    34c0:	d1f1      	bne.n	34a6 <dir_find+0xe>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
    34c2:	6968      	ldr	r0, [r5, #20]
		c = dir[DIR_Name];
    34c4:	7803      	ldrb	r3, [r0, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    34c6:	2b00      	cmp	r3, #0
    34c8:	d009      	beq.n	34de <dir_find+0x46>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    34ca:	7ac3      	ldrb	r3, [r0, #11]
    34cc:	071b      	lsls	r3, r3, #28
    34ce:	d4ec      	bmi.n	34aa <dir_find+0x12>
    34d0:	220b      	movs	r2, #11
    34d2:	69a9      	ldr	r1, [r5, #24]
    34d4:	4b06      	ldr	r3, [pc, #24]	; (34f0 <dir_find+0x58>)
    34d6:	4798      	blx	r3
    34d8:	2800      	cmp	r0, #0
    34da:	d1e6      	bne.n	34aa <dir_find+0x12>
    34dc:	e7e3      	b.n	34a6 <dir_find+0xe>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    34de:	2404      	movs	r4, #4
    34e0:	e7e1      	b.n	34a6 <dir_find+0xe>
    34e2:	46c0      	nop			; (mov r8, r8)
    34e4:	000030d1 	.word	0x000030d1
    34e8:	00003371 	.word	0x00003371
    34ec:	000029cd 	.word	0x000029cd
    34f0:	00002719 	.word	0x00002719

000034f4 <follow_path>:
{
    34f4:	b510      	push	{r4, lr}
    34f6:	b082      	sub	sp, #8
    34f8:	0004      	movs	r4, r0
    34fa:	9101      	str	r1, [sp, #4]
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
    34fc:	780b      	ldrb	r3, [r1, #0]
    34fe:	2b2f      	cmp	r3, #47	; 0x2f
    3500:	d01f      	beq.n	3542 <follow_path+0x4e>
    3502:	2b5c      	cmp	r3, #92	; 0x5c
    3504:	d01d      	beq.n	3542 <follow_path+0x4e>
	dp->sclust = 0;							/* Always start from the root directory */
    3506:	2300      	movs	r3, #0
    3508:	60a3      	str	r3, [r4, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
    350a:	9b01      	ldr	r3, [sp, #4]
    350c:	781b      	ldrb	r3, [r3, #0]
    350e:	2b1f      	cmp	r3, #31
    3510:	d91a      	bls.n	3548 <follow_path+0x54>
			res = create_name(dp, &path);	/* Get a segment name of the path */
    3512:	a901      	add	r1, sp, #4
    3514:	0020      	movs	r0, r4
    3516:	4b14      	ldr	r3, [pc, #80]	; (3568 <follow_path+0x74>)
    3518:	4798      	blx	r3
			if (res != FR_OK) break;
    351a:	2800      	cmp	r0, #0
    351c:	d11a      	bne.n	3554 <follow_path+0x60>
			res = dir_find(dp);				/* Find an object with the sagment name */
    351e:	0020      	movs	r0, r4
    3520:	4b12      	ldr	r3, [pc, #72]	; (356c <follow_path+0x78>)
    3522:	4798      	blx	r3
			ns = dp->fn[NSFLAG];
    3524:	69a3      	ldr	r3, [r4, #24]
    3526:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
    3528:	2800      	cmp	r0, #0
    352a:	d115      	bne.n	3558 <follow_path+0x64>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
    352c:	075b      	lsls	r3, r3, #29
    352e:	d411      	bmi.n	3554 <follow_path+0x60>
			dir = dp->dir;						/* Follow the sub-directory */
    3530:	6961      	ldr	r1, [r4, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
    3532:	7acb      	ldrb	r3, [r1, #11]
    3534:	06db      	lsls	r3, r3, #27
    3536:	d515      	bpl.n	3564 <follow_path+0x70>
			dp->sclust = ld_clust(dp->fs, dir);
    3538:	6820      	ldr	r0, [r4, #0]
    353a:	4b0d      	ldr	r3, [pc, #52]	; (3570 <follow_path+0x7c>)
    353c:	4798      	blx	r3
    353e:	60a0      	str	r0, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
    3540:	e7e7      	b.n	3512 <follow_path+0x1e>
		path++;
    3542:	3101      	adds	r1, #1
    3544:	9101      	str	r1, [sp, #4]
    3546:	e7de      	b.n	3506 <follow_path+0x12>
		res = dir_sdi(dp, 0);
    3548:	2100      	movs	r1, #0
    354a:	0020      	movs	r0, r4
    354c:	4b09      	ldr	r3, [pc, #36]	; (3574 <follow_path+0x80>)
    354e:	4798      	blx	r3
		dp->dir = 0;
    3550:	2300      	movs	r3, #0
    3552:	6163      	str	r3, [r4, #20]
}
    3554:	b002      	add	sp, #8
    3556:	bd10      	pop	{r4, pc}
				if (res == FR_NO_FILE) {	/* Object is not found */
    3558:	2804      	cmp	r0, #4
    355a:	d1fb      	bne.n	3554 <follow_path+0x60>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
    355c:	075b      	lsls	r3, r3, #29
    355e:	d4f9      	bmi.n	3554 <follow_path+0x60>
    3560:	2005      	movs	r0, #5
    3562:	e7f7      	b.n	3554 <follow_path+0x60>
				res = FR_NO_PATH; break;
    3564:	2005      	movs	r0, #5
    3566:	e7f5      	b.n	3554 <follow_path+0x60>
    3568:	00002785 	.word	0x00002785
    356c:	00003499 	.word	0x00003499
    3570:	0000274f 	.word	0x0000274f
    3574:	000030d1 	.word	0x000030d1

00003578 <dir_alloc>:
{
    3578:	b570      	push	{r4, r5, r6, lr}
    357a:	0004      	movs	r4, r0
    357c:	000e      	movs	r6, r1
	res = dir_sdi(dp, 0);
    357e:	2100      	movs	r1, #0
    3580:	4b10      	ldr	r3, [pc, #64]	; (35c4 <dir_alloc+0x4c>)
    3582:	4798      	blx	r3
	if (res == FR_OK) {
    3584:	2800      	cmp	r0, #0
    3586:	d118      	bne.n	35ba <dir_alloc+0x42>
    3588:	2500      	movs	r5, #0
    358a:	e008      	b.n	359e <dir_alloc+0x26>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
    358c:	3501      	adds	r5, #1
    358e:	42b5      	cmp	r5, r6
    3590:	d013      	beq.n	35ba <dir_alloc+0x42>
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
    3592:	2101      	movs	r1, #1
    3594:	0020      	movs	r0, r4
    3596:	4b0c      	ldr	r3, [pc, #48]	; (35c8 <dir_alloc+0x50>)
    3598:	4798      	blx	r3
		} while (res == FR_OK);
    359a:	2800      	cmp	r0, #0
    359c:	d10d      	bne.n	35ba <dir_alloc+0x42>
			res = move_window(dp->fs, dp->sect);
    359e:	6921      	ldr	r1, [r4, #16]
    35a0:	6820      	ldr	r0, [r4, #0]
    35a2:	4b0a      	ldr	r3, [pc, #40]	; (35cc <dir_alloc+0x54>)
    35a4:	4798      	blx	r3
			if (res != FR_OK) break;
    35a6:	2800      	cmp	r0, #0
    35a8:	d107      	bne.n	35ba <dir_alloc+0x42>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
    35aa:	6963      	ldr	r3, [r4, #20]
    35ac:	781b      	ldrb	r3, [r3, #0]
    35ae:	2be5      	cmp	r3, #229	; 0xe5
    35b0:	d0ec      	beq.n	358c <dir_alloc+0x14>
    35b2:	2b00      	cmp	r3, #0
    35b4:	d0ea      	beq.n	358c <dir_alloc+0x14>
				n = 0;					/* Not a blank entry. Restart to search */
    35b6:	2500      	movs	r5, #0
    35b8:	e7eb      	b.n	3592 <dir_alloc+0x1a>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    35ba:	2804      	cmp	r0, #4
    35bc:	d000      	beq.n	35c0 <dir_alloc+0x48>
}
    35be:	bd70      	pop	{r4, r5, r6, pc}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    35c0:	3003      	adds	r0, #3
    35c2:	e7fc      	b.n	35be <dir_alloc+0x46>
    35c4:	000030d1 	.word	0x000030d1
    35c8:	00003371 	.word	0x00003371
    35cc:	000029cd 	.word	0x000029cd

000035d0 <dir_register>:
{
    35d0:	b570      	push	{r4, r5, r6, lr}
    35d2:	0005      	movs	r5, r0
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
    35d4:	2101      	movs	r1, #1
    35d6:	4b0d      	ldr	r3, [pc, #52]	; (360c <dir_register+0x3c>)
    35d8:	4798      	blx	r3
    35da:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {				/* Set SFN entry */
    35dc:	d001      	beq.n	35e2 <dir_register+0x12>
}
    35de:	0020      	movs	r0, r4
    35e0:	bd70      	pop	{r4, r5, r6, pc}
		res = move_window(dp->fs, dp->sect);
    35e2:	6929      	ldr	r1, [r5, #16]
    35e4:	6828      	ldr	r0, [r5, #0]
    35e6:	4b0a      	ldr	r3, [pc, #40]	; (3610 <dir_register+0x40>)
    35e8:	4798      	blx	r3
    35ea:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
    35ec:	d1f7      	bne.n	35de <dir_register+0xe>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
    35ee:	2220      	movs	r2, #32
    35f0:	2100      	movs	r1, #0
    35f2:	6968      	ldr	r0, [r5, #20]
    35f4:	4b07      	ldr	r3, [pc, #28]	; (3614 <dir_register+0x44>)
    35f6:	4798      	blx	r3
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
    35f8:	220b      	movs	r2, #11
    35fa:	69a9      	ldr	r1, [r5, #24]
    35fc:	6968      	ldr	r0, [r5, #20]
    35fe:	4b06      	ldr	r3, [pc, #24]	; (3618 <dir_register+0x48>)
    3600:	4798      	blx	r3
			dp->fs->wflag = 1;
    3602:	682b      	ldr	r3, [r5, #0]
    3604:	2201      	movs	r2, #1
    3606:	711a      	strb	r2, [r3, #4]
    3608:	e7e9      	b.n	35de <dir_register+0xe>
    360a:	46c0      	nop			; (mov r8, r8)
    360c:	00003579 	.word	0x00003579
    3610:	000029cd 	.word	0x000029cd
    3614:	00002709 	.word	0x00002709
    3618:	000026f5 	.word	0x000026f5

0000361c <remove_chain>:
{
    361c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    361e:	0004      	movs	r4, r0
    3620:	000d      	movs	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    3622:	2901      	cmp	r1, #1
    3624:	d925      	bls.n	3672 <remove_chain+0x56>
    3626:	6943      	ldr	r3, [r0, #20]
    3628:	4299      	cmp	r1, r3
    362a:	d301      	bcc.n	3630 <remove_chain+0x14>
		res = FR_INT_ERR;
    362c:	2702      	movs	r7, #2
    362e:	e021      	b.n	3674 <remove_chain+0x58>
    3630:	2700      	movs	r7, #0
    3632:	e000      	b.n	3636 <remove_chain+0x1a>
    3634:	0035      	movs	r5, r6
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3636:	6963      	ldr	r3, [r4, #20]
    3638:	429d      	cmp	r5, r3
    363a:	d21b      	bcs.n	3674 <remove_chain+0x58>
			nxt = get_fat(fs, clst);			/* Get cluster status */
    363c:	0029      	movs	r1, r5
    363e:	0020      	movs	r0, r4
    3640:	4b0f      	ldr	r3, [pc, #60]	; (3680 <remove_chain+0x64>)
    3642:	4798      	blx	r3
    3644:	1e06      	subs	r6, r0, #0
			if (nxt == 0) break;				/* Empty cluster? */
    3646:	d015      	beq.n	3674 <remove_chain+0x58>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    3648:	2801      	cmp	r0, #1
    364a:	d015      	beq.n	3678 <remove_chain+0x5c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    364c:	1c43      	adds	r3, r0, #1
    364e:	d015      	beq.n	367c <remove_chain+0x60>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    3650:	2200      	movs	r2, #0
    3652:	0029      	movs	r1, r5
    3654:	0020      	movs	r0, r4
    3656:	4b0b      	ldr	r3, [pc, #44]	; (3684 <remove_chain+0x68>)
    3658:	4798      	blx	r3
    365a:	1e07      	subs	r7, r0, #0
			if (res != FR_OK) break;
    365c:	d10a      	bne.n	3674 <remove_chain+0x58>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
    365e:	6923      	ldr	r3, [r4, #16]
    3660:	1c5a      	adds	r2, r3, #1
    3662:	d0e7      	beq.n	3634 <remove_chain+0x18>
				fs->free_clust++;
    3664:	3301      	adds	r3, #1
    3666:	6123      	str	r3, [r4, #16]
				fs->fsi_flag |= 1;
    3668:	7963      	ldrb	r3, [r4, #5]
    366a:	2201      	movs	r2, #1
    366c:	4313      	orrs	r3, r2
    366e:	7163      	strb	r3, [r4, #5]
    3670:	e7e0      	b.n	3634 <remove_chain+0x18>
		res = FR_INT_ERR;
    3672:	2702      	movs	r7, #2
}
    3674:	0038      	movs	r0, r7
    3676:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    3678:	2702      	movs	r7, #2
    367a:	e7fb      	b.n	3674 <remove_chain+0x58>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    367c:	2701      	movs	r7, #1
    367e:	e7f9      	b.n	3674 <remove_chain+0x58>
    3680:	00002fd5 	.word	0x00002fd5
    3684:	00003175 	.word	0x00003175

00003688 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    3688:	b510      	push	{r4, lr}
    368a:	b084      	sub	sp, #16
    368c:	9001      	str	r0, [sp, #4]
    368e:	9100      	str	r1, [sp, #0]
    3690:	0014      	movs	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
    3692:	9103      	str	r1, [sp, #12]


	vol = get_ldnumber(&rp);
    3694:	a803      	add	r0, sp, #12
    3696:	4b12      	ldr	r3, [pc, #72]	; (36e0 <f_mount+0x58>)
    3698:	4798      	blx	r3
	if (vol < 0) return FR_INVALID_DRIVE;
    369a:	2800      	cmp	r0, #0
    369c:	db1b      	blt.n	36d6 <f_mount+0x4e>
	cfs = FatFs[vol];					/* Pointer to fs object */
    369e:	0083      	lsls	r3, r0, #2
    36a0:	4a10      	ldr	r2, [pc, #64]	; (36e4 <f_mount+0x5c>)
    36a2:	589b      	ldr	r3, [r3, r2]

	if (cfs) {
    36a4:	2b00      	cmp	r3, #0
    36a6:	d001      	beq.n	36ac <f_mount+0x24>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
    36a8:	2200      	movs	r2, #0
    36aa:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
    36ac:	9b01      	ldr	r3, [sp, #4]
    36ae:	2b00      	cmp	r3, #0
    36b0:	d001      	beq.n	36b6 <f_mount+0x2e>
		fs->fs_type = 0;				/* Clear new fs object */
    36b2:	2200      	movs	r2, #0
    36b4:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
    36b6:	9b01      	ldr	r3, [sp, #4]
    36b8:	0080      	lsls	r0, r0, #2
    36ba:	4a0a      	ldr	r2, [pc, #40]	; (36e4 <f_mount+0x5c>)
    36bc:	5083      	str	r3, [r0, r2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    36be:	2b00      	cmp	r3, #0
    36c0:	d00c      	beq.n	36dc <f_mount+0x54>
    36c2:	2c01      	cmp	r4, #1
    36c4:	d001      	beq.n	36ca <f_mount+0x42>
    36c6:	2000      	movs	r0, #0
    36c8:	e006      	b.n	36d8 <f_mount+0x50>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
    36ca:	2200      	movs	r2, #0
    36cc:	4669      	mov	r1, sp
    36ce:	a801      	add	r0, sp, #4
    36d0:	4b05      	ldr	r3, [pc, #20]	; (36e8 <f_mount+0x60>)
    36d2:	4798      	blx	r3
	LEAVE_FF(fs, res);
    36d4:	e000      	b.n	36d8 <f_mount+0x50>
	if (vol < 0) return FR_INVALID_DRIVE;
    36d6:	200b      	movs	r0, #11
}
    36d8:	b004      	add	sp, #16
    36da:	bd10      	pop	{r4, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    36dc:	2000      	movs	r0, #0
    36de:	e7fb      	b.n	36d8 <f_mount+0x50>
    36e0:	00002911 	.word	0x00002911
    36e4:	20000458 	.word	0x20000458
    36e8:	00002ae5 	.word	0x00002ae5

000036ec <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    36ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    36ee:	46ce      	mov	lr, r9
    36f0:	4647      	mov	r7, r8
    36f2:	b580      	push	{r7, lr}
    36f4:	b08d      	sub	sp, #52	; 0x34
    36f6:	0005      	movs	r5, r0
    36f8:	9101      	str	r1, [sp, #4]
    36fa:	0016      	movs	r6, r2
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
    36fc:	2800      	cmp	r0, #0
    36fe:	d100      	bne.n	3702 <f_open+0x16>
    3700:	e0a3      	b.n	384a <f_open+0x15e>
	fp->fs = 0;			/* Clear file object */
    3702:	2300      	movs	r3, #0
    3704:	6003      	str	r3, [r0, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    3706:	271f      	movs	r7, #31
    3708:	4017      	ands	r7, r2
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
    370a:	221e      	movs	r2, #30
    370c:	4032      	ands	r2, r6
    370e:	a901      	add	r1, sp, #4
    3710:	a805      	add	r0, sp, #20
    3712:	4b51      	ldr	r3, [pc, #324]	; (3858 <f_open+0x16c>)
    3714:	4798      	blx	r3
    3716:	1e04      	subs	r4, r0, #0
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
    3718:	d000      	beq.n	371c <f_open+0x30>
    371a:	e097      	b.n	384c <f_open+0x160>
		INIT_BUF(dj);
    371c:	ab02      	add	r3, sp, #8
    371e:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
    3720:	9901      	ldr	r1, [sp, #4]
    3722:	a805      	add	r0, sp, #20
    3724:	4b4d      	ldr	r3, [pc, #308]	; (385c <f_open+0x170>)
    3726:	4798      	blx	r3
    3728:	1e04      	subs	r4, r0, #0
		dir = dj.dir;
    372a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    372c:	4698      	mov	r8, r3
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    372e:	d101      	bne.n	3734 <f_open+0x48>
			if (!dir)	/* Default directory itself */
    3730:	2b00      	cmp	r3, #0
    3732:	d03b      	beq.n	37ac <f_open+0xc0>
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3734:	231c      	movs	r3, #28
    3736:	4233      	tst	r3, r6
    3738:	d079      	beq.n	382e <f_open+0x142>
			if (res != FR_OK) {					/* No file, create new */
    373a:	2c00      	cmp	r4, #0
    373c:	d03d      	beq.n	37ba <f_open+0xce>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    373e:	2c04      	cmp	r4, #4
    3740:	d036      	beq.n	37b0 <f_open+0xc4>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3742:	2308      	movs	r3, #8
    3744:	431f      	orrs	r7, r3
    3746:	b2ff      	uxtb	r7, r7
				dir = dj.dir;					/* New entry */
    3748:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    374a:	4698      	mov	r8, r3
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    374c:	2c00      	cmp	r4, #0
    374e:	d101      	bne.n	3754 <f_open+0x68>
    3750:	073b      	lsls	r3, r7, #28
    3752:	d43d      	bmi.n	37d0 <f_open+0xe4>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    3754:	2c00      	cmp	r4, #0
    3756:	d109      	bne.n	376c <f_open+0x80>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
    3758:	073b      	lsls	r3, r7, #28
    375a:	d502      	bpl.n	3762 <f_open+0x76>
				mode |= FA__WRITTEN;
    375c:	2320      	movs	r3, #32
    375e:	431f      	orrs	r7, r3
    3760:	b2ff      	uxtb	r7, r7
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    3762:	9b05      	ldr	r3, [sp, #20]
    3764:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3766:	61eb      	str	r3, [r5, #28]
			fp->dir_ptr = dir;
    3768:	4643      	mov	r3, r8
    376a:	622b      	str	r3, [r5, #32]
			}
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
    376c:	2c00      	cmp	r4, #0
    376e:	d16d      	bne.n	384c <f_open+0x160>
			fp->flag = mode;					/* File access mode */
    3770:	71af      	strb	r7, [r5, #6]
			fp->err = 0;						/* Clear error flag */
    3772:	2700      	movs	r7, #0
    3774:	71ef      	strb	r7, [r5, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    3776:	9e05      	ldr	r6, [sp, #20]
    3778:	4641      	mov	r1, r8
    377a:	0030      	movs	r0, r6
    377c:	4b38      	ldr	r3, [pc, #224]	; (3860 <f_open+0x174>)
    377e:	4798      	blx	r3
    3780:	6128      	str	r0, [r5, #16]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
    3782:	4643      	mov	r3, r8
    3784:	7fdb      	ldrb	r3, [r3, #31]
    3786:	061b      	lsls	r3, r3, #24
    3788:	4642      	mov	r2, r8
    378a:	7f92      	ldrb	r2, [r2, #30]
    378c:	0412      	lsls	r2, r2, #16
    378e:	4313      	orrs	r3, r2
    3790:	4642      	mov	r2, r8
    3792:	7f52      	ldrb	r2, [r2, #29]
    3794:	0212      	lsls	r2, r2, #8
    3796:	4313      	orrs	r3, r2
    3798:	4642      	mov	r2, r8
    379a:	7f12      	ldrb	r2, [r2, #28]
    379c:	4313      	orrs	r3, r2
    379e:	60eb      	str	r3, [r5, #12]
			fp->fptr = 0;						/* File pointer */
    37a0:	60af      	str	r7, [r5, #8]
			fp->dsect = 0;
    37a2:	61af      	str	r7, [r5, #24]
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
    37a4:	602e      	str	r6, [r5, #0]
			fp->id = fp->fs->id;
    37a6:	88f3      	ldrh	r3, [r6, #6]
    37a8:	80ab      	strh	r3, [r5, #4]
    37aa:	e04f      	b.n	384c <f_open+0x160>
				res = FR_INVALID_NAME;
    37ac:	3406      	adds	r4, #6
    37ae:	e7c1      	b.n	3734 <f_open+0x48>
					res = dir_register(&dj);
    37b0:	a805      	add	r0, sp, #20
    37b2:	4b2c      	ldr	r3, [pc, #176]	; (3864 <f_open+0x178>)
    37b4:	4798      	blx	r3
    37b6:	0004      	movs	r4, r0
    37b8:	e7c3      	b.n	3742 <f_open+0x56>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    37ba:	4643      	mov	r3, r8
    37bc:	7adb      	ldrb	r3, [r3, #11]
    37be:	2211      	movs	r2, #17
    37c0:	421a      	tst	r2, r3
    37c2:	d103      	bne.n	37cc <f_open+0xe0>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    37c4:	0773      	lsls	r3, r6, #29
    37c6:	d5c1      	bpl.n	374c <f_open+0x60>
						res = FR_EXIST;
    37c8:	2408      	movs	r4, #8
    37ca:	e7bf      	b.n	374c <f_open+0x60>
					res = FR_DENIED;
    37cc:	2407      	movs	r4, #7
    37ce:	e7bd      	b.n	374c <f_open+0x60>
				dw = GET_FATTIME();				/* Created time */
    37d0:	4b25      	ldr	r3, [pc, #148]	; (3868 <f_open+0x17c>)
    37d2:	4798      	blx	r3
				ST_DWORD(dir + DIR_CrtTime, dw);
    37d4:	4643      	mov	r3, r8
    37d6:	7398      	strb	r0, [r3, #14]
    37d8:	b283      	uxth	r3, r0
    37da:	0a1b      	lsrs	r3, r3, #8
    37dc:	4642      	mov	r2, r8
    37de:	73d3      	strb	r3, [r2, #15]
    37e0:	0c03      	lsrs	r3, r0, #16
    37e2:	7413      	strb	r3, [r2, #16]
    37e4:	0e00      	lsrs	r0, r0, #24
    37e6:	7450      	strb	r0, [r2, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
    37e8:	2300      	movs	r3, #0
    37ea:	72d3      	strb	r3, [r2, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
    37ec:	7713      	strb	r3, [r2, #28]
    37ee:	7753      	strb	r3, [r2, #29]
    37f0:	7793      	strb	r3, [r2, #30]
    37f2:	77d3      	strb	r3, [r2, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
    37f4:	4641      	mov	r1, r8
    37f6:	9805      	ldr	r0, [sp, #20]
    37f8:	4b19      	ldr	r3, [pc, #100]	; (3860 <f_open+0x174>)
    37fa:	4798      	blx	r3
    37fc:	0006      	movs	r6, r0
				st_clust(dir, 0);				/* cluster = 0 */
    37fe:	2100      	movs	r1, #0
    3800:	4640      	mov	r0, r8
    3802:	4b1a      	ldr	r3, [pc, #104]	; (386c <f_open+0x180>)
    3804:	4798      	blx	r3
				dj.fs->wflag = 1;
    3806:	9805      	ldr	r0, [sp, #20]
    3808:	2301      	movs	r3, #1
    380a:	7103      	strb	r3, [r0, #4]
				if (cl) {						/* Remove the cluster chain if exist */
    380c:	2e00      	cmp	r6, #0
    380e:	d0a1      	beq.n	3754 <f_open+0x68>
					dw = dj.fs->winsect;
    3810:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    3812:	4699      	mov	r9, r3
					res = remove_chain(dj.fs, cl);
    3814:	0031      	movs	r1, r6
    3816:	4b16      	ldr	r3, [pc, #88]	; (3870 <f_open+0x184>)
    3818:	4798      	blx	r3
    381a:	1e04      	subs	r4, r0, #0
					if (res == FR_OK) {
    381c:	d19a      	bne.n	3754 <f_open+0x68>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    381e:	9805      	ldr	r0, [sp, #20]
    3820:	3e01      	subs	r6, #1
    3822:	60c6      	str	r6, [r0, #12]
						res = move_window(dj.fs, dw);
    3824:	4649      	mov	r1, r9
    3826:	4b13      	ldr	r3, [pc, #76]	; (3874 <f_open+0x188>)
    3828:	4798      	blx	r3
    382a:	0004      	movs	r4, r0
    382c:	e792      	b.n	3754 <f_open+0x68>
			if (res == FR_OK) {					/* Follow succeeded */
    382e:	2c00      	cmp	r4, #0
    3830:	d190      	bne.n	3754 <f_open+0x68>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
    3832:	4643      	mov	r3, r8
    3834:	7adb      	ldrb	r3, [r3, #11]
    3836:	06da      	lsls	r2, r3, #27
    3838:	d405      	bmi.n	3846 <f_open+0x15a>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    383a:	07b2      	lsls	r2, r6, #30
    383c:	d58a      	bpl.n	3754 <f_open+0x68>
    383e:	07db      	lsls	r3, r3, #31
    3840:	d588      	bpl.n	3754 <f_open+0x68>
						res = FR_DENIED;
    3842:	2407      	movs	r4, #7
    3844:	e786      	b.n	3754 <f_open+0x68>
					res = FR_NO_FILE;
    3846:	2404      	movs	r4, #4
    3848:	e784      	b.n	3754 <f_open+0x68>
	if (!fp) return FR_INVALID_OBJECT;
    384a:	2409      	movs	r4, #9
		}
	}

	LEAVE_FF(dj.fs, res);
}
    384c:	0020      	movs	r0, r4
    384e:	b00d      	add	sp, #52	; 0x34
    3850:	bc0c      	pop	{r2, r3}
    3852:	4690      	mov	r8, r2
    3854:	4699      	mov	r9, r3
    3856:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3858:	00002ae5 	.word	0x00002ae5
    385c:	000034f5 	.word	0x000034f5
    3860:	0000274f 	.word	0x0000274f
    3864:	000035d1 	.word	0x000035d1
    3868:	000026f1 	.word	0x000026f1
    386c:	00002771 	.word	0x00002771
    3870:	0000361d 	.word	0x0000361d
    3874:	000029cd 	.word	0x000029cd

00003878 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
    3878:	b5f0      	push	{r4, r5, r6, r7, lr}
    387a:	46de      	mov	lr, fp
    387c:	4657      	mov	r7, sl
    387e:	464e      	mov	r6, r9
    3880:	4645      	mov	r5, r8
    3882:	b5e0      	push	{r5, r6, r7, lr}
    3884:	b083      	sub	sp, #12
    3886:	0004      	movs	r4, r0
    3888:	000d      	movs	r5, r1
    388a:	0017      	movs	r7, r2
    388c:	001e      	movs	r6, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    388e:	2300      	movs	r3, #0
    3890:	6033      	str	r3, [r6, #0]

	res = validate(fp);							/* Check validity */
    3892:	4b5f      	ldr	r3, [pc, #380]	; (3a10 <f_read+0x198>)
    3894:	4798      	blx	r3
    3896:	9000      	str	r0, [sp, #0]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3898:	2800      	cmp	r0, #0
    389a:	d108      	bne.n	38ae <f_read+0x36>
	if (fp->err)								/* Check error */
    389c:	79e3      	ldrb	r3, [r4, #7]
    389e:	2b00      	cmp	r3, #0
    38a0:	d000      	beq.n	38a4 <f_read+0x2c>
    38a2:	e0b2      	b.n	3a0a <f_read+0x192>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    38a4:	79a3      	ldrb	r3, [r4, #6]
    38a6:	07db      	lsls	r3, r3, #31
    38a8:	d409      	bmi.n	38be <f_read+0x46>
		LEAVE_FF(fp->fs, FR_DENIED);
    38aa:	2307      	movs	r3, #7
    38ac:	9300      	str	r3, [sp, #0]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    38ae:	9800      	ldr	r0, [sp, #0]
    38b0:	b003      	add	sp, #12
    38b2:	bc3c      	pop	{r2, r3, r4, r5}
    38b4:	4690      	mov	r8, r2
    38b6:	4699      	mov	r9, r3
    38b8:	46a2      	mov	sl, r4
    38ba:	46ab      	mov	fp, r5
    38bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	remain = fp->fsize - fp->fptr;
    38be:	68e3      	ldr	r3, [r4, #12]
    38c0:	68a2      	ldr	r2, [r4, #8]
    38c2:	1a9b      	subs	r3, r3, r2
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    38c4:	42bb      	cmp	r3, r7
    38c6:	d200      	bcs.n	38ca <f_read+0x52>
    38c8:	001f      	movs	r7, r3
		if (rcnt > btr) rcnt = btr;
    38ca:	46a8      	mov	r8, r5
    38cc:	e053      	b.n	3976 <f_read+0xfe>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    38ce:	6961      	ldr	r1, [r4, #20]
    38d0:	4b50      	ldr	r3, [pc, #320]	; (3a14 <f_read+0x19c>)
    38d2:	4798      	blx	r3
    38d4:	e05f      	b.n	3996 <f_read+0x11e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    38d6:	2302      	movs	r3, #2
    38d8:	71e3      	strb	r3, [r4, #7]
    38da:	9300      	str	r3, [sp, #0]
    38dc:	e7e7      	b.n	38ae <f_read+0x36>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    38de:	2301      	movs	r3, #1
    38e0:	71e3      	strb	r3, [r4, #7]
    38e2:	9300      	str	r3, [sp, #0]
    38e4:	e7e3      	b.n	38ae <f_read+0x36>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    38e6:	2302      	movs	r3, #2
    38e8:	71e3      	strb	r3, [r4, #7]
    38ea:	9300      	str	r3, [sp, #0]
    38ec:	e7df      	b.n	38ae <f_read+0x36>
					ABORT(fp->fs, FR_DISK_ERR);
    38ee:	2301      	movs	r3, #1
    38f0:	71e3      	strb	r3, [r4, #7]
    38f2:	9300      	str	r3, [sp, #0]
    38f4:	e7db      	b.n	38ae <f_read+0x36>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    38f6:	0240      	lsls	r0, r0, #9
    38f8:	4440      	add	r0, r8
    38fa:	0021      	movs	r1, r4
    38fc:	3124      	adds	r1, #36	; 0x24
    38fe:	2280      	movs	r2, #128	; 0x80
    3900:	0092      	lsls	r2, r2, #2
    3902:	4b45      	ldr	r3, [pc, #276]	; (3a18 <f_read+0x1a0>)
    3904:	4798      	blx	r3
    3906:	e075      	b.n	39f4 <f_read+0x17c>
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    3908:	69a2      	ldr	r2, [r4, #24]
    390a:	4290      	cmp	r0, r2
    390c:	d019      	beq.n	3942 <f_read+0xca>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    390e:	79a3      	ldrb	r3, [r4, #6]
    3910:	065b      	lsls	r3, r3, #25
    3912:	d50c      	bpl.n	392e <f_read+0xb6>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3914:	0021      	movs	r1, r4
    3916:	3124      	adds	r1, #36	; 0x24
    3918:	465b      	mov	r3, fp
    391a:	7858      	ldrb	r0, [r3, #1]
    391c:	2301      	movs	r3, #1
    391e:	4d3f      	ldr	r5, [pc, #252]	; (3a1c <f_read+0x1a4>)
    3920:	47a8      	blx	r5
    3922:	2800      	cmp	r0, #0
    3924:	d169      	bne.n	39fa <f_read+0x182>
					fp->flag &= ~FA__DIRTY;
    3926:	79a3      	ldrb	r3, [r4, #6]
    3928:	2240      	movs	r2, #64	; 0x40
    392a:	4393      	bics	r3, r2
    392c:	71a3      	strb	r3, [r4, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    392e:	0021      	movs	r1, r4
    3930:	3124      	adds	r1, #36	; 0x24
    3932:	6823      	ldr	r3, [r4, #0]
    3934:	7858      	ldrb	r0, [r3, #1]
    3936:	2301      	movs	r3, #1
    3938:	464a      	mov	r2, r9
    393a:	4d39      	ldr	r5, [pc, #228]	; (3a20 <f_read+0x1a8>)
    393c:	47a8      	blx	r5
    393e:	2800      	cmp	r0, #0
    3940:	d15f      	bne.n	3a02 <f_read+0x18a>
			fp->dsect = sect;
    3942:	464b      	mov	r3, r9
    3944:	61a3      	str	r3, [r4, #24]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3946:	68a3      	ldr	r3, [r4, #8]
    3948:	05d9      	lsls	r1, r3, #23
    394a:	0dc9      	lsrs	r1, r1, #23
    394c:	2580      	movs	r5, #128	; 0x80
    394e:	00ad      	lsls	r5, r5, #2
    3950:	1a6d      	subs	r5, r5, r1
		if (rcnt > btr) rcnt = btr;
    3952:	42af      	cmp	r7, r5
    3954:	d200      	bcs.n	3958 <f_read+0xe0>
    3956:	003d      	movs	r5, r7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3958:	3120      	adds	r1, #32
    395a:	1861      	adds	r1, r4, r1
    395c:	3104      	adds	r1, #4
    395e:	002a      	movs	r2, r5
    3960:	4640      	mov	r0, r8
    3962:	4b2d      	ldr	r3, [pc, #180]	; (3a18 <f_read+0x1a0>)
    3964:	4798      	blx	r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3966:	44a8      	add	r8, r5
    3968:	68a3      	ldr	r3, [r4, #8]
    396a:	195b      	adds	r3, r3, r5
    396c:	60a3      	str	r3, [r4, #8]
    396e:	6833      	ldr	r3, [r6, #0]
    3970:	195b      	adds	r3, r3, r5
    3972:	6033      	str	r3, [r6, #0]
    3974:	1b7f      	subs	r7, r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    3976:	2f00      	cmp	r7, #0
    3978:	d099      	beq.n	38ae <f_read+0x36>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    397a:	68a1      	ldr	r1, [r4, #8]
    397c:	05cb      	lsls	r3, r1, #23
    397e:	d1e2      	bne.n	3946 <f_read+0xce>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3980:	0a4a      	lsrs	r2, r1, #9
    3982:	6820      	ldr	r0, [r4, #0]
    3984:	7883      	ldrb	r3, [r0, #2]
    3986:	3b01      	subs	r3, #1
    3988:	b2db      	uxtb	r3, r3
    398a:	401a      	ands	r2, r3
    398c:	4692      	mov	sl, r2
			if (!csect) {						/* On the cluster boundary? */
    398e:	d107      	bne.n	39a0 <f_read+0x128>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3990:	2900      	cmp	r1, #0
    3992:	d19c      	bne.n	38ce <f_read+0x56>
					clst = fp->sclust;			/* Follow from the origin */
    3994:	6920      	ldr	r0, [r4, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    3996:	2801      	cmp	r0, #1
    3998:	d99d      	bls.n	38d6 <f_read+0x5e>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    399a:	1c43      	adds	r3, r0, #1
    399c:	d09f      	beq.n	38de <f_read+0x66>
				fp->clust = clst;				/* Update current cluster */
    399e:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    39a0:	6823      	ldr	r3, [r4, #0]
    39a2:	469b      	mov	fp, r3
    39a4:	6961      	ldr	r1, [r4, #20]
    39a6:	0018      	movs	r0, r3
    39a8:	4b1e      	ldr	r3, [pc, #120]	; (3a24 <f_read+0x1ac>)
    39aa:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    39ac:	2800      	cmp	r0, #0
    39ae:	d09a      	beq.n	38e6 <f_read+0x6e>
			sect += csect;
    39b0:	4450      	add	r0, sl
    39b2:	4681      	mov	r9, r0
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    39b4:	0a7a      	lsrs	r2, r7, #9
    39b6:	9201      	str	r2, [sp, #4]
			if (cc) {							/* Read maximum contiguous sectors directly */
    39b8:	d0a6      	beq.n	3908 <f_read+0x90>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    39ba:	4653      	mov	r3, sl
    39bc:	4694      	mov	ip, r2
    39be:	4463      	add	r3, ip
    39c0:	465a      	mov	r2, fp
    39c2:	7892      	ldrb	r2, [r2, #2]
    39c4:	4293      	cmp	r3, r2
    39c6:	d902      	bls.n	39ce <f_read+0x156>
					cc = fp->fs->csize - csect;
    39c8:	4653      	mov	r3, sl
    39ca:	1ad3      	subs	r3, r2, r3
    39cc:	9301      	str	r3, [sp, #4]
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
    39ce:	465b      	mov	r3, fp
    39d0:	7858      	ldrb	r0, [r3, #1]
    39d2:	9b01      	ldr	r3, [sp, #4]
    39d4:	464a      	mov	r2, r9
    39d6:	4641      	mov	r1, r8
    39d8:	4d11      	ldr	r5, [pc, #68]	; (3a20 <f_read+0x1a8>)
    39da:	47a8      	blx	r5
    39dc:	2800      	cmp	r0, #0
    39de:	d186      	bne.n	38ee <f_read+0x76>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    39e0:	79a3      	ldrb	r3, [r4, #6]
    39e2:	065b      	lsls	r3, r3, #25
    39e4:	d506      	bpl.n	39f4 <f_read+0x17c>
    39e6:	69a3      	ldr	r3, [r4, #24]
    39e8:	464a      	mov	r2, r9
    39ea:	1a98      	subs	r0, r3, r2
    39ec:	9b01      	ldr	r3, [sp, #4]
    39ee:	4283      	cmp	r3, r0
    39f0:	d900      	bls.n	39f4 <f_read+0x17c>
    39f2:	e780      	b.n	38f6 <f_read+0x7e>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    39f4:	9b01      	ldr	r3, [sp, #4]
    39f6:	025d      	lsls	r5, r3, #9
				continue;
    39f8:	e7b5      	b.n	3966 <f_read+0xee>
						ABORT(fp->fs, FR_DISK_ERR);
    39fa:	2301      	movs	r3, #1
    39fc:	71e3      	strb	r3, [r4, #7]
    39fe:	9300      	str	r3, [sp, #0]
    3a00:	e755      	b.n	38ae <f_read+0x36>
					ABORT(fp->fs, FR_DISK_ERR);
    3a02:	2301      	movs	r3, #1
    3a04:	71e3      	strb	r3, [r4, #7]
    3a06:	9300      	str	r3, [sp, #0]
    3a08:	e751      	b.n	38ae <f_read+0x36>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    3a0a:	9300      	str	r3, [sp, #0]
    3a0c:	e74f      	b.n	38ae <f_read+0x36>
    3a0e:	46c0      	nop			; (mov r8, r8)
    3a10:	00002aa5 	.word	0x00002aa5
    3a14:	00002fd5 	.word	0x00002fd5
    3a18:	000026f5 	.word	0x000026f5
    3a1c:	0000258d 	.word	0x0000258d
    3a20:	00002541 	.word	0x00002541
    3a24:	00002fbd 	.word	0x00002fbd

00003a28 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    3a28:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a2a:	46de      	mov	lr, fp
    3a2c:	4657      	mov	r7, sl
    3a2e:	464e      	mov	r6, r9
    3a30:	4645      	mov	r5, r8
    3a32:	b5e0      	push	{r5, r6, r7, lr}
    3a34:	b083      	sub	sp, #12
    3a36:	0004      	movs	r4, r0
    3a38:	000d      	movs	r5, r1
    3a3a:	0017      	movs	r7, r2
    3a3c:	001e      	movs	r6, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3a3e:	2300      	movs	r3, #0
    3a40:	6033      	str	r3, [r6, #0]

	res = validate(fp);						/* Check validity */
    3a42:	4b6f      	ldr	r3, [pc, #444]	; (3c00 <f_write+0x1d8>)
    3a44:	4798      	blx	r3
    3a46:	9000      	str	r0, [sp, #0]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3a48:	2800      	cmp	r0, #0
    3a4a:	d108      	bne.n	3a5e <f_write+0x36>
	if (fp->err)							/* Check error */
    3a4c:	79e3      	ldrb	r3, [r4, #7]
    3a4e:	2b00      	cmp	r3, #0
    3a50:	d000      	beq.n	3a54 <f_write+0x2c>
    3a52:	e0d2      	b.n	3bfa <f_write+0x1d2>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3a54:	79a3      	ldrb	r3, [r4, #6]
    3a56:	079b      	lsls	r3, r3, #30
    3a58:	d409      	bmi.n	3a6e <f_write+0x46>
		LEAVE_FF(fp->fs, FR_DENIED);
    3a5a:	2307      	movs	r3, #7
    3a5c:	9300      	str	r3, [sp, #0]

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3a5e:	9800      	ldr	r0, [sp, #0]
    3a60:	b003      	add	sp, #12
    3a62:	bc3c      	pop	{r2, r3, r4, r5}
    3a64:	4690      	mov	r8, r2
    3a66:	4699      	mov	r9, r3
    3a68:	46a2      	mov	sl, r4
    3a6a:	46ab      	mov	fp, r5
    3a6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
    3a6e:	68a3      	ldr	r3, [r4, #8]
    3a70:	19da      	adds	r2, r3, r7
    3a72:	4293      	cmp	r3, r2
    3a74:	d900      	bls.n	3a78 <f_write+0x50>
    3a76:	2700      	movs	r7, #0
		if (wcnt > btw) wcnt = btw;
    3a78:	46a8      	mov	r8, r5
    3a7a:	e05d      	b.n	3b38 <f_write+0x110>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3a7c:	4b61      	ldr	r3, [pc, #388]	; (3c04 <f_write+0x1dc>)
    3a7e:	4798      	blx	r3
    3a80:	0003      	movs	r3, r0
    3a82:	e06b      	b.n	3b5c <f_write+0x134>
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3a84:	6961      	ldr	r1, [r4, #20]
    3a86:	4b5f      	ldr	r3, [pc, #380]	; (3c04 <f_write+0x1dc>)
    3a88:	4798      	blx	r3
    3a8a:	0003      	movs	r3, r0
    3a8c:	e066      	b.n	3b5c <f_write+0x134>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3a8e:	3301      	adds	r3, #1
    3a90:	71e3      	strb	r3, [r4, #7]
    3a92:	9300      	str	r3, [sp, #0]
    3a94:	e7e3      	b.n	3a5e <f_write+0x36>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3a96:	3302      	adds	r3, #2
    3a98:	71e3      	strb	r3, [r4, #7]
    3a9a:	9300      	str	r3, [sp, #0]
    3a9c:	e7df      	b.n	3a5e <f_write+0x36>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3a9e:	0021      	movs	r1, r4
    3aa0:	3124      	adds	r1, #36	; 0x24
    3aa2:	6823      	ldr	r3, [r4, #0]
    3aa4:	7858      	ldrb	r0, [r3, #1]
    3aa6:	2301      	movs	r3, #1
    3aa8:	69a2      	ldr	r2, [r4, #24]
    3aaa:	4d57      	ldr	r5, [pc, #348]	; (3c08 <f_write+0x1e0>)
    3aac:	47a8      	blx	r5
    3aae:	2800      	cmp	r0, #0
    3ab0:	d104      	bne.n	3abc <f_write+0x94>
				fp->flag &= ~FA__DIRTY;
    3ab2:	79a3      	ldrb	r3, [r4, #6]
    3ab4:	2240      	movs	r2, #64	; 0x40
    3ab6:	4393      	bics	r3, r2
    3ab8:	71a3      	strb	r3, [r4, #6]
    3aba:	e05d      	b.n	3b78 <f_write+0x150>
					ABORT(fp->fs, FR_DISK_ERR);
    3abc:	2301      	movs	r3, #1
    3abe:	71e3      	strb	r3, [r4, #7]
    3ac0:	9300      	str	r3, [sp, #0]
    3ac2:	e7cc      	b.n	3a5e <f_write+0x36>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3ac4:	2302      	movs	r3, #2
    3ac6:	71e3      	strb	r3, [r4, #7]
    3ac8:	9300      	str	r3, [sp, #0]
    3aca:	e7c8      	b.n	3a5e <f_write+0x36>
					ABORT(fp->fs, FR_DISK_ERR);
    3acc:	2301      	movs	r3, #1
    3ace:	71e3      	strb	r3, [r4, #7]
    3ad0:	9300      	str	r3, [sp, #0]
    3ad2:	e7c4      	b.n	3a5e <f_write+0x36>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3ad4:	0020      	movs	r0, r4
    3ad6:	3024      	adds	r0, #36	; 0x24
    3ad8:	0249      	lsls	r1, r1, #9
    3ada:	4441      	add	r1, r8
    3adc:	2280      	movs	r2, #128	; 0x80
    3ade:	0092      	lsls	r2, r2, #2
    3ae0:	4b4a      	ldr	r3, [pc, #296]	; (3c0c <f_write+0x1e4>)
    3ae2:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
    3ae4:	79a3      	ldrb	r3, [r4, #6]
    3ae6:	2240      	movs	r2, #64	; 0x40
    3ae8:	4393      	bics	r3, r2
    3aea:	71a3      	strb	r3, [r4, #6]
    3aec:	e06a      	b.n	3bc4 <f_write+0x19c>
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3aee:	69a3      	ldr	r3, [r4, #24]
    3af0:	4298      	cmp	r0, r3
    3af2:	d003      	beq.n	3afc <f_write+0xd4>
				if (fp->fptr < fp->fsize &&
    3af4:	68a3      	ldr	r3, [r4, #8]
    3af6:	68e2      	ldr	r2, [r4, #12]
    3af8:	4293      	cmp	r3, r2
    3afa:	d366      	bcc.n	3bca <f_write+0x1a2>
			fp->dsect = sect;
    3afc:	465b      	mov	r3, fp
    3afe:	61a3      	str	r3, [r4, #24]
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3b00:	68a3      	ldr	r3, [r4, #8]
    3b02:	05d8      	lsls	r0, r3, #23
    3b04:	0dc0      	lsrs	r0, r0, #23
    3b06:	2580      	movs	r5, #128	; 0x80
    3b08:	00ad      	lsls	r5, r5, #2
    3b0a:	1a2d      	subs	r5, r5, r0
		if (wcnt > btw) wcnt = btw;
    3b0c:	42af      	cmp	r7, r5
    3b0e:	d200      	bcs.n	3b12 <f_write+0xea>
    3b10:	003d      	movs	r5, r7
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3b12:	3020      	adds	r0, #32
    3b14:	1820      	adds	r0, r4, r0
    3b16:	3004      	adds	r0, #4
    3b18:	002a      	movs	r2, r5
    3b1a:	4641      	mov	r1, r8
    3b1c:	4b3b      	ldr	r3, [pc, #236]	; (3c0c <f_write+0x1e4>)
    3b1e:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
    3b20:	79a3      	ldrb	r3, [r4, #6]
    3b22:	2240      	movs	r2, #64	; 0x40
    3b24:	4313      	orrs	r3, r2
    3b26:	71a3      	strb	r3, [r4, #6]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3b28:	44a8      	add	r8, r5
    3b2a:	68a3      	ldr	r3, [r4, #8]
    3b2c:	195b      	adds	r3, r3, r5
    3b2e:	60a3      	str	r3, [r4, #8]
    3b30:	6833      	ldr	r3, [r6, #0]
    3b32:	195b      	adds	r3, r3, r5
    3b34:	6033      	str	r3, [r6, #0]
    3b36:	1b7f      	subs	r7, r7, r5
	for ( ;  btw;							/* Repeat until all data written */
    3b38:	2f00      	cmp	r7, #0
    3b3a:	d054      	beq.n	3be6 <f_write+0x1be>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3b3c:	68a1      	ldr	r1, [r4, #8]
    3b3e:	05cb      	lsls	r3, r1, #23
    3b40:	d1de      	bne.n	3b00 <f_write+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3b42:	0a4a      	lsrs	r2, r1, #9
    3b44:	6820      	ldr	r0, [r4, #0]
    3b46:	7883      	ldrb	r3, [r0, #2]
    3b48:	3b01      	subs	r3, #1
    3b4a:	b2db      	uxtb	r3, r3
    3b4c:	401a      	ands	r2, r3
    3b4e:	4692      	mov	sl, r2
			if (!csect) {					/* On the cluster boundary? */
    3b50:	d10f      	bne.n	3b72 <f_write+0x14a>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3b52:	2900      	cmp	r1, #0
    3b54:	d196      	bne.n	3a84 <f_write+0x5c>
					clst = fp->sclust;		/* Follow from the origin */
    3b56:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
    3b58:	2b00      	cmp	r3, #0
    3b5a:	d08f      	beq.n	3a7c <f_write+0x54>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3b5c:	2b00      	cmp	r3, #0
    3b5e:	d042      	beq.n	3be6 <f_write+0x1be>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3b60:	2b01      	cmp	r3, #1
    3b62:	d094      	beq.n	3a8e <f_write+0x66>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3b64:	1c5a      	adds	r2, r3, #1
    3b66:	d096      	beq.n	3a96 <f_write+0x6e>
				fp->clust = clst;			/* Update current cluster */
    3b68:	6163      	str	r3, [r4, #20]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
    3b6a:	6922      	ldr	r2, [r4, #16]
    3b6c:	2a00      	cmp	r2, #0
    3b6e:	d100      	bne.n	3b72 <f_write+0x14a>
    3b70:	6123      	str	r3, [r4, #16]
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3b72:	79a3      	ldrb	r3, [r4, #6]
    3b74:	065b      	lsls	r3, r3, #25
    3b76:	d492      	bmi.n	3a9e <f_write+0x76>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3b78:	6823      	ldr	r3, [r4, #0]
    3b7a:	4699      	mov	r9, r3
    3b7c:	6961      	ldr	r1, [r4, #20]
    3b7e:	0018      	movs	r0, r3
    3b80:	4b23      	ldr	r3, [pc, #140]	; (3c10 <f_write+0x1e8>)
    3b82:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3b84:	2800      	cmp	r0, #0
    3b86:	d09d      	beq.n	3ac4 <f_write+0x9c>
			sect += csect;
    3b88:	4450      	add	r0, sl
    3b8a:	4683      	mov	fp, r0
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3b8c:	0a7a      	lsrs	r2, r7, #9
    3b8e:	9201      	str	r2, [sp, #4]
			if (cc) {						/* Write maximum contiguous sectors directly */
    3b90:	d0ad      	beq.n	3aee <f_write+0xc6>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3b92:	4653      	mov	r3, sl
    3b94:	4694      	mov	ip, r2
    3b96:	4463      	add	r3, ip
    3b98:	464a      	mov	r2, r9
    3b9a:	7892      	ldrb	r2, [r2, #2]
    3b9c:	4293      	cmp	r3, r2
    3b9e:	d902      	bls.n	3ba6 <f_write+0x17e>
					cc = fp->fs->csize - csect;
    3ba0:	4653      	mov	r3, sl
    3ba2:	1ad3      	subs	r3, r2, r3
    3ba4:	9301      	str	r3, [sp, #4]
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
    3ba6:	464b      	mov	r3, r9
    3ba8:	7858      	ldrb	r0, [r3, #1]
    3baa:	9b01      	ldr	r3, [sp, #4]
    3bac:	465a      	mov	r2, fp
    3bae:	4641      	mov	r1, r8
    3bb0:	4d15      	ldr	r5, [pc, #84]	; (3c08 <f_write+0x1e0>)
    3bb2:	47a8      	blx	r5
    3bb4:	2800      	cmp	r0, #0
    3bb6:	d189      	bne.n	3acc <f_write+0xa4>
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3bb8:	69a3      	ldr	r3, [r4, #24]
    3bba:	465a      	mov	r2, fp
    3bbc:	1a99      	subs	r1, r3, r2
    3bbe:	9b01      	ldr	r3, [sp, #4]
    3bc0:	428b      	cmp	r3, r1
    3bc2:	d887      	bhi.n	3ad4 <f_write+0xac>
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3bc4:	9b01      	ldr	r3, [sp, #4]
    3bc6:	025d      	lsls	r5, r3, #9
				continue;
    3bc8:	e7ae      	b.n	3b28 <f_write+0x100>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3bca:	0021      	movs	r1, r4
    3bcc:	3124      	adds	r1, #36	; 0x24
    3bce:	464b      	mov	r3, r9
    3bd0:	7858      	ldrb	r0, [r3, #1]
    3bd2:	2301      	movs	r3, #1
    3bd4:	465a      	mov	r2, fp
    3bd6:	4d0f      	ldr	r5, [pc, #60]	; (3c14 <f_write+0x1ec>)
    3bd8:	47a8      	blx	r5
				if (fp->fptr < fp->fsize &&
    3bda:	2800      	cmp	r0, #0
    3bdc:	d08e      	beq.n	3afc <f_write+0xd4>
						ABORT(fp->fs, FR_DISK_ERR);
    3bde:	2601      	movs	r6, #1
    3be0:	71e6      	strb	r6, [r4, #7]
    3be2:	9600      	str	r6, [sp, #0]
    3be4:	e73b      	b.n	3a5e <f_write+0x36>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3be6:	68a3      	ldr	r3, [r4, #8]
    3be8:	68e2      	ldr	r2, [r4, #12]
    3bea:	4293      	cmp	r3, r2
    3bec:	d900      	bls.n	3bf0 <f_write+0x1c8>
    3bee:	60e3      	str	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3bf0:	79a3      	ldrb	r3, [r4, #6]
    3bf2:	2220      	movs	r2, #32
    3bf4:	4313      	orrs	r3, r2
    3bf6:	71a3      	strb	r3, [r4, #6]
	LEAVE_FF(fp->fs, FR_OK);
    3bf8:	e731      	b.n	3a5e <f_write+0x36>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    3bfa:	9300      	str	r3, [sp, #0]
    3bfc:	e72f      	b.n	3a5e <f_write+0x36>
    3bfe:	46c0      	nop			; (mov r8, r8)
    3c00:	00002aa5 	.word	0x00002aa5
    3c04:	000032b1 	.word	0x000032b1
    3c08:	0000258d 	.word	0x0000258d
    3c0c:	000026f5 	.word	0x000026f5
    3c10:	00002fbd 	.word	0x00002fbd
    3c14:	00002541 	.word	0x00002541

00003c18 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    3c18:	b570      	push	{r4, r5, r6, lr}
    3c1a:	0004      	movs	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3c1c:	4b24      	ldr	r3, [pc, #144]	; (3cb0 <f_sync+0x98>)
    3c1e:	4798      	blx	r3
	if (res == FR_OK) {
    3c20:	2800      	cmp	r0, #0
    3c22:	d118      	bne.n	3c56 <f_sync+0x3e>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3c24:	79a3      	ldrb	r3, [r4, #6]
    3c26:	069a      	lsls	r2, r3, #26
    3c28:	d515      	bpl.n	3c56 <f_sync+0x3e>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
    3c2a:	065b      	lsls	r3, r3, #25
    3c2c:	d50d      	bpl.n	3c4a <f_sync+0x32>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3c2e:	0021      	movs	r1, r4
    3c30:	3124      	adds	r1, #36	; 0x24
    3c32:	6823      	ldr	r3, [r4, #0]
    3c34:	7858      	ldrb	r0, [r3, #1]
    3c36:	2301      	movs	r3, #1
    3c38:	69a2      	ldr	r2, [r4, #24]
    3c3a:	4d1e      	ldr	r5, [pc, #120]	; (3cb4 <f_sync+0x9c>)
    3c3c:	47a8      	blx	r5
    3c3e:	2800      	cmp	r0, #0
    3c40:	d134      	bne.n	3cac <f_sync+0x94>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    3c42:	79a3      	ldrb	r3, [r4, #6]
    3c44:	2240      	movs	r2, #64	; 0x40
    3c46:	4393      	bics	r3, r2
    3c48:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    3c4a:	69e1      	ldr	r1, [r4, #28]
    3c4c:	6820      	ldr	r0, [r4, #0]
    3c4e:	4b1a      	ldr	r3, [pc, #104]	; (3cb8 <f_sync+0xa0>)
    3c50:	4798      	blx	r3
			if (res == FR_OK) {
    3c52:	2800      	cmp	r0, #0
    3c54:	d000      	beq.n	3c58 <f_sync+0x40>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    3c56:	bd70      	pop	{r4, r5, r6, pc}
				dir = fp->dir_ptr;
    3c58:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    3c5a:	7aeb      	ldrb	r3, [r5, #11]
    3c5c:	2220      	movs	r2, #32
    3c5e:	4313      	orrs	r3, r2
    3c60:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
    3c62:	7b23      	ldrb	r3, [r4, #12]
    3c64:	772b      	strb	r3, [r5, #28]
    3c66:	89a3      	ldrh	r3, [r4, #12]
    3c68:	0a1b      	lsrs	r3, r3, #8
    3c6a:	776b      	strb	r3, [r5, #29]
    3c6c:	7ba3      	ldrb	r3, [r4, #14]
    3c6e:	77ab      	strb	r3, [r5, #30]
    3c70:	7be3      	ldrb	r3, [r4, #15]
    3c72:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
    3c74:	6921      	ldr	r1, [r4, #16]
    3c76:	0028      	movs	r0, r5
    3c78:	4b10      	ldr	r3, [pc, #64]	; (3cbc <f_sync+0xa4>)
    3c7a:	4798      	blx	r3
				tm = GET_FATTIME();							/* Update updated time */
    3c7c:	4b10      	ldr	r3, [pc, #64]	; (3cc0 <f_sync+0xa8>)
    3c7e:	4798      	blx	r3
				ST_DWORD(dir + DIR_WrtTime, tm);
    3c80:	75a8      	strb	r0, [r5, #22]
    3c82:	b283      	uxth	r3, r0
    3c84:	0a1b      	lsrs	r3, r3, #8
    3c86:	75eb      	strb	r3, [r5, #23]
    3c88:	0c03      	lsrs	r3, r0, #16
    3c8a:	762b      	strb	r3, [r5, #24]
    3c8c:	0e00      	lsrs	r0, r0, #24
    3c8e:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
    3c90:	2300      	movs	r3, #0
    3c92:	74ab      	strb	r3, [r5, #18]
    3c94:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
    3c96:	79a3      	ldrb	r3, [r4, #6]
    3c98:	2220      	movs	r2, #32
    3c9a:	4393      	bics	r3, r2
    3c9c:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    3c9e:	2301      	movs	r3, #1
    3ca0:	6822      	ldr	r2, [r4, #0]
    3ca2:	7113      	strb	r3, [r2, #4]
				res = sync_fs(fp->fs);
    3ca4:	6820      	ldr	r0, [r4, #0]
    3ca6:	4b07      	ldr	r3, [pc, #28]	; (3cc4 <f_sync+0xac>)
    3ca8:	4798      	blx	r3
    3caa:	e7d4      	b.n	3c56 <f_sync+0x3e>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    3cac:	2001      	movs	r0, #1
    3cae:	e7d2      	b.n	3c56 <f_sync+0x3e>
    3cb0:	00002aa5 	.word	0x00002aa5
    3cb4:	0000258d 	.word	0x0000258d
    3cb8:	000029cd 	.word	0x000029cd
    3cbc:	00002771 	.word	0x00002771
    3cc0:	000026f1 	.word	0x000026f1
    3cc4:	00002ec1 	.word	0x00002ec1

00003cc8 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    3cc8:	b510      	push	{r4, lr}
    3cca:	0004      	movs	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
    3ccc:	4b06      	ldr	r3, [pc, #24]	; (3ce8 <f_close+0x20>)
    3cce:	4798      	blx	r3
	if (res == FR_OK)
    3cd0:	2800      	cmp	r0, #0
    3cd2:	d000      	beq.n	3cd6 <f_close+0xe>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
    3cd4:	bd10      	pop	{r4, pc}
		res = validate(fp);				/* Lock volume */
    3cd6:	0020      	movs	r0, r4
    3cd8:	4b04      	ldr	r3, [pc, #16]	; (3cec <f_close+0x24>)
    3cda:	4798      	blx	r3
		if (res == FR_OK) {
    3cdc:	2800      	cmp	r0, #0
    3cde:	d1f9      	bne.n	3cd4 <f_close+0xc>
				fp->fs = 0;				/* Invalidate file object */
    3ce0:	2300      	movs	r3, #0
    3ce2:	6023      	str	r3, [r4, #0]
    3ce4:	e7f6      	b.n	3cd4 <f_close+0xc>
    3ce6:	46c0      	nop			; (mov r8, r8)
    3ce8:	00003c19 	.word	0x00003c19
    3cec:	00002aa5 	.word	0x00002aa5

00003cf0 <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
    3cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
    3cf2:	b085      	sub	sp, #20
    3cf4:	9001      	str	r0, [sp, #4]
    3cf6:	000e      	movs	r6, r1
    3cf8:	9200      	str	r2, [sp, #0]
	int n = 0;
	TCHAR c, *p = buff;
    3cfa:	0007      	movs	r7, r0
	int n = 0;
    3cfc:	2400      	movs	r4, #0
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
    3cfe:	1e73      	subs	r3, r6, #1
    3d00:	429c      	cmp	r4, r3
    3d02:	da14      	bge.n	3d2e <f_gets+0x3e>
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
    3d04:	ab02      	add	r3, sp, #8
    3d06:	2201      	movs	r2, #1
    3d08:	a903      	add	r1, sp, #12
    3d0a:	9800      	ldr	r0, [sp, #0]
    3d0c:	4d0c      	ldr	r5, [pc, #48]	; (3d40 <f_gets+0x50>)
    3d0e:	47a8      	blx	r5
		if (rc != 1) break;
    3d10:	9b02      	ldr	r3, [sp, #8]
    3d12:	2b01      	cmp	r3, #1
    3d14:	d10b      	bne.n	3d2e <f_gets+0x3e>
		c = s[0];
    3d16:	ab03      	add	r3, sp, #12
    3d18:	781b      	ldrb	r3, [r3, #0]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
    3d1a:	2b0d      	cmp	r3, #13
    3d1c:	d0ef      	beq.n	3cfe <f_gets+0xe>
		*p++ = c;
    3d1e:	1c7a      	adds	r2, r7, #1
    3d20:	703b      	strb	r3, [r7, #0]
		n++;
    3d22:	3401      	adds	r4, #1
		if (c == '\n') break;		/* Break on EOL */
    3d24:	2b0a      	cmp	r3, #10
    3d26:	d001      	beq.n	3d2c <f_gets+0x3c>
		*p++ = c;
    3d28:	0017      	movs	r7, r2
    3d2a:	e7e8      	b.n	3cfe <f_gets+0xe>
    3d2c:	0017      	movs	r7, r2
	}
	*p = 0;
    3d2e:	2300      	movs	r3, #0
    3d30:	703b      	strb	r3, [r7, #0]
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
    3d32:	2c00      	cmp	r4, #0
    3d34:	d002      	beq.n	3d3c <f_gets+0x4c>
    3d36:	9801      	ldr	r0, [sp, #4]
}
    3d38:	b005      	add	sp, #20
    3d3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
    3d3c:	2000      	movs	r0, #0
    3d3e:	e7fb      	b.n	3d38 <f_gets+0x48>
    3d40:	00003879 	.word	0x00003879

00003d44 <main>:
 *
 * Note:
 *
 ******************************************************************************/
int main(void)
{
    3d44:	b510      	push	{r4, lr}
	// CMSIS compliant function not used
	//SystemInit();
	
	// Application hardware and software initialization 
	AppInit();
    3d46:	4b02      	ldr	r3, [pc, #8]	; (3d50 <main+0xc>)
    3d48:	4798      	blx	r3

	// Super loop
	while(1)
	{
		// Run your application
		AppRun();
    3d4a:	4b02      	ldr	r3, [pc, #8]	; (3d54 <main+0x10>)
    3d4c:	4798      	blx	r3
    3d4e:	e7fc      	b.n	3d4a <main+0x6>
    3d50:	00002115 	.word	0x00002115
    3d54:	00002185 	.word	0x00002185

00003d58 <SDCard_InitSpeed>:

/*-----------------------------------------------------------------------*/
/* Set Slow SPI Speed                                                    */
/*-----------------------------------------------------------------------*/
void SDCard_InitSpeed(void)
{
    3d58:	b510      	push	{r4, lr}
	SPI_Initialize_Slow();
    3d5a:	4b01      	ldr	r3, [pc, #4]	; (3d60 <SDCard_InitSpeed+0x8>)
    3d5c:	4798      	blx	r3
}
    3d5e:	bd10      	pop	{r4, pc}
    3d60:	0000458d 	.word	0x0000458d

00003d64 <SDCard_RunSpeed>:

/*-----------------------------------------------------------------------*/
/* Set Fast SPI Speed                                                    */
/*-----------------------------------------------------------------------*/
void SDCard_RunSpeed(void)
{
    3d64:	b510      	push	{r4, lr}
	SPI_Initialize_Fast();
    3d66:	4b01      	ldr	r3, [pc, #4]	; (3d6c <SDCard_RunSpeed+0x8>)
    3d68:	4798      	blx	r3
} // SDCard_RunSpeed()
    3d6a:	bd10      	pop	{r4, pc}
    3d6c:	000044a9 	.word	0x000044a9

00003d70 <SDCard_SS>:
/*-----------------------------------------------------------------------*/
/* Slave Select Function                                                 */
/*-----------------------------------------------------------------------*/
void SDCard_SS(uint8_t cs)
{
	if (cs == 1)
    3d70:	2801      	cmp	r0, #1
    3d72:	d004      	beq.n	3d7e <SDCard_SS+0xe>
	{
		SPI_CS_HIGH();
	}
	else
	{
		SPI_CS_LOW();
    3d74:	2280      	movs	r2, #128	; 0x80
    3d76:	0192      	lsls	r2, r2, #6
    3d78:	4b03      	ldr	r3, [pc, #12]	; (3d88 <SDCard_SS+0x18>)
    3d7a:	615a      	str	r2, [r3, #20]
	}
} // SDCard_SS()
    3d7c:	4770      	bx	lr
		SPI_CS_HIGH();
    3d7e:	2280      	movs	r2, #128	; 0x80
    3d80:	0192      	lsls	r2, r2, #6
    3d82:	4b01      	ldr	r3, [pc, #4]	; (3d88 <SDCard_SS+0x18>)
    3d84:	619a      	str	r2, [r3, #24]
    3d86:	e7f9      	b.n	3d7c <SDCard_SS+0xc>
    3d88:	41004400 	.word	0x41004400

00003d8c <SDCard_WaitRead>:

/*-----------------------------------------------------------------------*/
/* Wait for SD Card to Read                                              */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WaitRead(void)
{
    3d8c:	b510      	push	{r4, lr}
	uint32_t cnt = 0x00FFFFF;
    3d8e:	4c06      	ldr	r4, [pc, #24]	; (3da8 <SDCard_WaitRead+0x1c>)
	uint8_t  res;

	do
	{
		res = SPI_SD_Send_Byte(0xFF);
    3d90:	20ff      	movs	r0, #255	; 0xff
    3d92:	4b06      	ldr	r3, [pc, #24]	; (3dac <SDCard_WaitRead+0x20>)
    3d94:	4798      	blx	r3

		if (res == 0xFF)
    3d96:	28ff      	cmp	r0, #255	; 0xff
    3d98:	d004      	beq.n	3da4 <SDCard_WaitRead+0x18>
		{
			return 0;
		}
		cnt--;
    3d9a:	3c01      	subs	r4, #1

	} while (cnt);
    3d9c:	2c00      	cmp	r4, #0
    3d9e:	d1f7      	bne.n	3d90 <SDCard_WaitRead+0x4>

	return 1;
    3da0:	2001      	movs	r0, #1
    3da2:	e000      	b.n	3da6 <SDCard_WaitRead+0x1a>
			return 0;
    3da4:	2000      	movs	r0, #0
} // SDCard_WaitRead()
    3da6:	bd10      	pop	{r4, pc}
    3da8:	000fffff 	.word	0x000fffff
    3dac:	00004691 	.word	0x00004691

00003db0 <itoa>:

/*-----------------------------------------------------------------------*/
/* Initialize the SD Card                                                */
/*-----------------------------------------------------------------------*/
void itoa(int num, char *str)
{
    3db0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3db2:	0005      	movs	r5, r0
    3db4:	000e      	movs	r6, r1
	int i = 0;
	if (num == 0)
    3db6:	2800      	cmp	r0, #0
    3db8:	d001      	beq.n	3dbe <itoa+0xe>
    3dba:	2400      	movs	r4, #0
    3dbc:	e012      	b.n	3de4 <itoa+0x34>
	{
		str[i++] = '0';
    3dbe:	2330      	movs	r3, #48	; 0x30
    3dc0:	700b      	strb	r3, [r1, #0]
		str[i] = '\0';
    3dc2:	2300      	movs	r3, #0
    3dc4:	704b      	strb	r3, [r1, #1]
		return;
    3dc6:	e01e      	b.n	3e06 <itoa+0x56>
	}

	while (num != 0)
	{
		str[i++] = (num % 10) + '0';
    3dc8:	1c67      	adds	r7, r4, #1
    3dca:	1934      	adds	r4, r6, r4
    3dcc:	210a      	movs	r1, #10
    3dce:	0028      	movs	r0, r5
    3dd0:	4b0d      	ldr	r3, [pc, #52]	; (3e08 <itoa+0x58>)
    3dd2:	4798      	blx	r3
    3dd4:	3130      	adds	r1, #48	; 0x30
    3dd6:	7021      	strb	r1, [r4, #0]
		num /= 10;
    3dd8:	210a      	movs	r1, #10
    3dda:	0028      	movs	r0, r5
    3ddc:	4b0b      	ldr	r3, [pc, #44]	; (3e0c <itoa+0x5c>)
    3dde:	4798      	blx	r3
    3de0:	0005      	movs	r5, r0
		str[i++] = (num % 10) + '0';
    3de2:	003c      	movs	r4, r7
	while (num != 0)
    3de4:	2d00      	cmp	r5, #0
    3de6:	d1ef      	bne.n	3dc8 <itoa+0x18>
	}
	str[i] = '\0';
    3de8:	1932      	adds	r2, r6, r4
    3dea:	2100      	movs	r1, #0
    3dec:	7011      	strb	r1, [r2, #0]

	// Reverse the string
	int start = 0;
	int end = i - 1;
    3dee:	1e63      	subs	r3, r4, #1
	while (start < end)
    3df0:	e007      	b.n	3e02 <itoa+0x52>
	{
		char temp = str[start];
    3df2:	1971      	adds	r1, r6, r5
    3df4:	7808      	ldrb	r0, [r1, #0]
		str[start] = str[end];
    3df6:	18f2      	adds	r2, r6, r3
    3df8:	7814      	ldrb	r4, [r2, #0]
    3dfa:	700c      	strb	r4, [r1, #0]
		str[end] = temp;
    3dfc:	7010      	strb	r0, [r2, #0]
		start++;
    3dfe:	3501      	adds	r5, #1
		end--;
    3e00:	3b01      	subs	r3, #1
	while (start < end)
    3e02:	429d      	cmp	r5, r3
    3e04:	dbf5      	blt.n	3df2 <itoa+0x42>
	}
}
    3e06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3e08:	00004a6d 	.word	0x00004a6d
    3e0c:	000048a1 	.word	0x000048a1

00003e10 <SDCard_WriteCmd>:

/*-----------------------------------------------------------------------*/
/* Write a command to the card                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteCmd(uint8_t cmd, uint32_t arg, uint8_t crc)
{
    3e10:	b5f0      	push	{r4, r5, r6, r7, lr}
    3e12:	b083      	sub	sp, #12
    3e14:	0006      	movs	r6, r0
    3e16:	000d      	movs	r5, r1
    3e18:	9201      	str	r2, [sp, #4]
	UART3_Write_Text("SDCardWrite_Cmd started!\r\n");
    3e1a:	4829      	ldr	r0, [pc, #164]	; (3ec0 <SDCard_WriteCmd+0xb0>)
    3e1c:	4c29      	ldr	r4, [pc, #164]	; (3ec4 <SDCard_WriteCmd+0xb4>)
    3e1e:	47a0      	blx	r4
	uint16_t cnt = 512;
	uint8_t  res;

	// toggle line and transmit data
	UART3_Write_Text("Toggle Line and transmit data\r\n");
    3e20:	4829      	ldr	r0, [pc, #164]	; (3ec8 <SDCard_WriteCmd+0xb8>)
    3e22:	47a0      	blx	r4
	SDCard_SS(1);
    3e24:	2001      	movs	r0, #1
    3e26:	4f29      	ldr	r7, [pc, #164]	; (3ecc <SDCard_WriteCmd+0xbc>)
    3e28:	47b8      	blx	r7
	SPI_SD_Send_Byte(0xFF);
    3e2a:	20ff      	movs	r0, #255	; 0xff
    3e2c:	4b28      	ldr	r3, [pc, #160]	; (3ed0 <SDCard_WriteCmd+0xc0>)
    3e2e:	4798      	blx	r3
	SDCard_SS(0);
    3e30:	2000      	movs	r0, #0
    3e32:	47b8      	blx	r7
	
	UART3_Write_Text("Card is selected!\r\n");
    3e34:	4827      	ldr	r0, [pc, #156]	; (3ed4 <SDCard_WriteCmd+0xc4>)
    3e36:	47a0      	blx	r4
	UART3_Write_Text("SD_SS to 0\r\n");
    3e38:	4827      	ldr	r0, [pc, #156]	; (3ed8 <SDCard_WriteCmd+0xc8>)
    3e3a:	47a0      	blx	r4
	SDCard_SS(0);
    3e3c:	2000      	movs	r0, #0
    3e3e:	47b8      	blx	r7
	UART3_Write_Text("Check if SDCard_WaitRead = 0\r\n");
    3e40:	4826      	ldr	r0, [pc, #152]	; (3edc <SDCard_WriteCmd+0xcc>)
    3e42:	47a0      	blx	r4
	if (SDCard_WaitRead() == 0)
    3e44:	4b26      	ldr	r3, [pc, #152]	; (3ee0 <SDCard_WriteCmd+0xd0>)
    3e46:	4798      	blx	r3
    3e48:	2800      	cmp	r0, #0
    3e4a:	d104      	bne.n	3e56 <SDCard_WriteCmd+0x46>
	if (SDCard_EnableSelect()) // Select the card and wait for ready except to stop multiple block read
    3e4c:	2800      	cmp	r0, #0
    3e4e:	d00d      	beq.n	3e6c <SDCard_WriteCmd+0x5c>
	{
		return 0xFF;
    3e50:	20ff      	movs	r0, #255	; 0xff
		res = SPI_SD_Send_Byte(0xFF);
		cnt--;
	} while ((cnt) && (res == 0xFF));

	return res; // Return with a response value
} // SDCard_WriteCmd()
    3e52:	b003      	add	sp, #12
    3e54:	bdf0      	pop	{r4, r5, r6, r7, pc}
	UART3_Write_Text("SDCard Disable Select\r\n");
    3e56:	4823      	ldr	r0, [pc, #140]	; (3ee4 <SDCard_WriteCmd+0xd4>)
    3e58:	4b1a      	ldr	r3, [pc, #104]	; (3ec4 <SDCard_WriteCmd+0xb4>)
    3e5a:	4798      	blx	r3
	SDCard_SS(1);
    3e5c:	2001      	movs	r0, #1
    3e5e:	4b1b      	ldr	r3, [pc, #108]	; (3ecc <SDCard_WriteCmd+0xbc>)
    3e60:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    3e62:	20ff      	movs	r0, #255	; 0xff
    3e64:	4b1a      	ldr	r3, [pc, #104]	; (3ed0 <SDCard_WriteCmd+0xc0>)
    3e66:	4798      	blx	r3
	return 1;
    3e68:	2001      	movs	r0, #1
    3e6a:	e7ef      	b.n	3e4c <SDCard_WriteCmd+0x3c>
	UART3_Write_Text("start command and index\r\n");
    3e6c:	481e      	ldr	r0, [pc, #120]	; (3ee8 <SDCard_WriteCmd+0xd8>)
    3e6e:	4f15      	ldr	r7, [pc, #84]	; (3ec4 <SDCard_WriteCmd+0xb4>)
    3e70:	47b8      	blx	r7
	SPI_SD_Send_Byte(cmd | 0x40);          // start command and index
    3e72:	2040      	movs	r0, #64	; 0x40
    3e74:	4330      	orrs	r0, r6
    3e76:	b2c0      	uxtb	r0, r0
    3e78:	4c15      	ldr	r4, [pc, #84]	; (3ed0 <SDCard_WriteCmd+0xc0>)
    3e7a:	47a0      	blx	r4
	UART3_Write_Text("Argument [31..24]\r\n");
    3e7c:	481b      	ldr	r0, [pc, #108]	; (3eec <SDCard_WriteCmd+0xdc>)
    3e7e:	47b8      	blx	r7
	SPI_SD_Send_Byte((uint8_t)(arg >> 24));  // argument [31..24]
    3e80:	0e28      	lsrs	r0, r5, #24
    3e82:	47a0      	blx	r4
	UART3_Write_Text("Argument [23..16]\r\n");
    3e84:	481a      	ldr	r0, [pc, #104]	; (3ef0 <SDCard_WriteCmd+0xe0>)
    3e86:	47b8      	blx	r7
	SPI_SD_Send_Byte((uint8_t)(arg >> 16));  // argument [23..16]
    3e88:	0c28      	lsrs	r0, r5, #16
    3e8a:	b2c0      	uxtb	r0, r0
    3e8c:	47a0      	blx	r4
	UART3_Write_Text("Argument [15..8]\r\n");
    3e8e:	4819      	ldr	r0, [pc, #100]	; (3ef4 <SDCard_WriteCmd+0xe4>)
    3e90:	47b8      	blx	r7
	SPI_SD_Send_Byte((uint8_t)(arg >> 8));   // argument [15..8]
    3e92:	0a28      	lsrs	r0, r5, #8
    3e94:	b2c0      	uxtb	r0, r0
    3e96:	47a0      	blx	r4
	UART3_Write_Text("Argument [7..0]\r\n");
    3e98:	4817      	ldr	r0, [pc, #92]	; (3ef8 <SDCard_WriteCmd+0xe8>)
    3e9a:	47b8      	blx	r7
	SPI_SD_Send_Byte((uint8_t)(arg));      // argument [7..0]
    3e9c:	b2e8      	uxtb	r0, r5
    3e9e:	47a0      	blx	r4
	UART3_Write_Text("Send Valid CRC and Stop!\r\n");
    3ea0:	4816      	ldr	r0, [pc, #88]	; (3efc <SDCard_WriteCmd+0xec>)
    3ea2:	47b8      	blx	r7
	SPI_SD_Send_Byte(crc);                 // Send valid CRC and stop
    3ea4:	9801      	ldr	r0, [sp, #4]
    3ea6:	47a0      	blx	r4
	uint16_t cnt = 512;
    3ea8:	2480      	movs	r4, #128	; 0x80
    3eaa:	00a4      	lsls	r4, r4, #2
		res = SPI_SD_Send_Byte(0xFF);
    3eac:	20ff      	movs	r0, #255	; 0xff
    3eae:	4b08      	ldr	r3, [pc, #32]	; (3ed0 <SDCard_WriteCmd+0xc0>)
    3eb0:	4798      	blx	r3
		cnt--;
    3eb2:	3c01      	subs	r4, #1
    3eb4:	b2a4      	uxth	r4, r4
	} while ((cnt) && (res == 0xFF));
    3eb6:	2c00      	cmp	r4, #0
    3eb8:	d0cb      	beq.n	3e52 <SDCard_WriteCmd+0x42>
    3eba:	28ff      	cmp	r0, #255	; 0xff
    3ebc:	d0f6      	beq.n	3eac <SDCard_WriteCmd+0x9c>
    3ebe:	e7c8      	b.n	3e52 <SDCard_WriteCmd+0x42>
    3ec0:	000050b4 	.word	0x000050b4
    3ec4:	00004771 	.word	0x00004771
    3ec8:	000050d0 	.word	0x000050d0
    3ecc:	00003d71 	.word	0x00003d71
    3ed0:	00004691 	.word	0x00004691
    3ed4:	000050f0 	.word	0x000050f0
    3ed8:	00005104 	.word	0x00005104
    3edc:	00005114 	.word	0x00005114
    3ee0:	00003d8d 	.word	0x00003d8d
    3ee4:	00005134 	.word	0x00005134
    3ee8:	0000514c 	.word	0x0000514c
    3eec:	00005168 	.word	0x00005168
    3ef0:	0000517c 	.word	0x0000517c
    3ef4:	00005190 	.word	0x00005190
    3ef8:	000051a4 	.word	0x000051a4
    3efc:	000051b8 	.word	0x000051b8

00003f00 <SDCard_Init>:
{
    3f00:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f02:	46c6      	mov	lr, r8
    3f04:	b500      	push	{lr}
    3f06:	b084      	sub	sp, #16
	UART3_Write_Text("Starting SD Card Initialization\r\n");
    3f08:	486b      	ldr	r0, [pc, #428]	; (40b8 <SDCard_Init+0x1b8>)
    3f0a:	4c6c      	ldr	r4, [pc, #432]	; (40bc <SDCard_Init+0x1bc>)
    3f0c:	47a0      	blx	r4
	SDCard_InitSpeed();
    3f0e:	4b6c      	ldr	r3, [pc, #432]	; (40c0 <SDCard_Init+0x1c0>)
    3f10:	4798      	blx	r3
	UART3_Write_Text("SD Card Initialized to Slow Speed\r\n");
    3f12:	486c      	ldr	r0, [pc, #432]	; (40c4 <SDCard_Init+0x1c4>)
    3f14:	47a0      	blx	r4
	delay_ms(100);
    3f16:	486c      	ldr	r0, [pc, #432]	; (40c8 <SDCard_Init+0x1c8>)
    3f18:	4b6c      	ldr	r3, [pc, #432]	; (40cc <SDCard_Init+0x1cc>)
    3f1a:	4798      	blx	r3
	SDCard_SS(1);
    3f1c:	2001      	movs	r0, #1
    3f1e:	4b6c      	ldr	r3, [pc, #432]	; (40d0 <SDCard_Init+0x1d0>)
    3f20:	4798      	blx	r3
	for (tvar = 0; tvar < 100; tvar++)
    3f22:	2400      	movs	r4, #0
    3f24:	e004      	b.n	3f30 <SDCard_Init+0x30>
		SPI_SD_Send_Byte(0xFF);  // send dummy clocks
    3f26:	20ff      	movs	r0, #255	; 0xff
    3f28:	4b6a      	ldr	r3, [pc, #424]	; (40d4 <SDCard_Init+0x1d4>)
    3f2a:	4798      	blx	r3
	for (tvar = 0; tvar < 100; tvar++)
    3f2c:	3401      	adds	r4, #1
    3f2e:	b2e4      	uxtb	r4, r4
    3f30:	2c63      	cmp	r4, #99	; 0x63
    3f32:	d9f8      	bls.n	3f26 <SDCard_Init+0x26>
	UART3_Write_Text("Sent 100 dummy clocks\r\n");
    3f34:	4868      	ldr	r0, [pc, #416]	; (40d8 <SDCard_Init+0x1d8>)
    3f36:	4c61      	ldr	r4, [pc, #388]	; (40bc <SDCard_Init+0x1bc>)
    3f38:	47a0      	blx	r4
	SDCard_SS(0);
    3f3a:	2000      	movs	r0, #0
    3f3c:	4b64      	ldr	r3, [pc, #400]	; (40d0 <SDCard_Init+0x1d0>)
    3f3e:	4798      	blx	r3
	UART3_Write_Text("CS set to LOW\r\n");
    3f40:	4866      	ldr	r0, [pc, #408]	; (40dc <SDCard_Init+0x1dc>)
    3f42:	47a0      	blx	r4
	delay_ms(20);
    3f44:	4866      	ldr	r0, [pc, #408]	; (40e0 <SDCard_Init+0x1e0>)
    3f46:	4b61      	ldr	r3, [pc, #388]	; (40cc <SDCard_Init+0x1cc>)
    3f48:	4798      	blx	r3
	lvar = 0;
    3f4a:	2200      	movs	r2, #0
    3f4c:	4b65      	ldr	r3, [pc, #404]	; (40e4 <SDCard_Init+0x1e4>)
    3f4e:	701a      	strb	r2, [r3, #0]
		tmp_0 = SDCard_WriteCmd(CMD0, 0x00, 0x95);
    3f50:	2295      	movs	r2, #149	; 0x95
    3f52:	2100      	movs	r1, #0
    3f54:	2040      	movs	r0, #64	; 0x40
    3f56:	4b64      	ldr	r3, [pc, #400]	; (40e8 <SDCard_Init+0x1e8>)
    3f58:	4798      	blx	r3
    3f5a:	4d62      	ldr	r5, [pc, #392]	; (40e4 <SDCard_Init+0x1e4>)
    3f5c:	7068      	strb	r0, [r5, #1]
		lvar++;
    3f5e:	7828      	ldrb	r0, [r5, #0]
    3f60:	3001      	adds	r0, #1
    3f62:	b2c0      	uxtb	r0, r0
    3f64:	7028      	strb	r0, [r5, #0]
		itoa(lvar, numStr);
    3f66:	a901      	add	r1, sp, #4
    3f68:	4f60      	ldr	r7, [pc, #384]	; (40ec <SDCard_Init+0x1ec>)
    3f6a:	47b8      	blx	r7
		UART3_Write_Text("Attempting CMD0 Reset, attempt: ");
    3f6c:	4860      	ldr	r0, [pc, #384]	; (40f0 <SDCard_Init+0x1f0>)
    3f6e:	4c53      	ldr	r4, [pc, #332]	; (40bc <SDCard_Init+0x1bc>)
    3f70:	47a0      	blx	r4
		UART3_Write_Text(numStr);
    3f72:	a801      	add	r0, sp, #4
    3f74:	47a0      	blx	r4
		UART3_Write_Text("\r\n");
    3f76:	4e5f      	ldr	r6, [pc, #380]	; (40f4 <SDCard_Init+0x1f4>)
    3f78:	0030      	movs	r0, r6
    3f7a:	47a0      	blx	r4
		UART3_Write_Text("CMD0 Response: ");
    3f7c:	485e      	ldr	r0, [pc, #376]	; (40f8 <SDCard_Init+0x1f8>)
    3f7e:	47a0      	blx	r4
		itoa(tmp_0, numStr);
    3f80:	7868      	ldrb	r0, [r5, #1]
    3f82:	a901      	add	r1, sp, #4
    3f84:	47b8      	blx	r7
		UART3_Write_Text(numStr);
    3f86:	a801      	add	r0, sp, #4
    3f88:	47a0      	blx	r4
		UART3_Write_Text("\r\n");
    3f8a:	0030      	movs	r0, r6
    3f8c:	47a0      	blx	r4
		delay_ms(10); // Add a delay between each attempt
    3f8e:	485b      	ldr	r0, [pc, #364]	; (40fc <SDCard_Init+0x1fc>)
    3f90:	4b4e      	ldr	r3, [pc, #312]	; (40cc <SDCard_Init+0x1cc>)
    3f92:	4798      	blx	r3
	} while ((tmp_0 != 1) && (lvar < 500));  // Retry limit 500
    3f94:	786c      	ldrb	r4, [r5, #1]
    3f96:	2c01      	cmp	r4, #1
    3f98:	d1da      	bne.n	3f50 <SDCard_Init+0x50>
	UART3_Write_Text("Card Reset Successful\r\n");
    3f9a:	4859      	ldr	r0, [pc, #356]	; (4100 <SDCard_Init+0x200>)
    3f9c:	4e47      	ldr	r6, [pc, #284]	; (40bc <SDCard_Init+0x1bc>)
    3f9e:	47b0      	blx	r6
	tmp_8 = SDCard_WriteCmd(CMD8, 0x1AA, 0x87);
    3fa0:	2287      	movs	r2, #135	; 0x87
    3fa2:	21d5      	movs	r1, #213	; 0xd5
    3fa4:	0049      	lsls	r1, r1, #1
    3fa6:	2048      	movs	r0, #72	; 0x48
    3fa8:	4b4f      	ldr	r3, [pc, #316]	; (40e8 <SDCard_Init+0x1e8>)
    3faa:	4798      	blx	r3
    3fac:	4d4d      	ldr	r5, [pc, #308]	; (40e4 <SDCard_Init+0x1e4>)
    3fae:	70a8      	strb	r0, [r5, #2]
	UART3_Write_Text("CMD8 Sent\r\n");
    3fb0:	4854      	ldr	r0, [pc, #336]	; (4104 <SDCard_Init+0x204>)
    3fb2:	47b0      	blx	r6
	if (tmp_8 == 1)
    3fb4:	78ab      	ldrb	r3, [r5, #2]
    3fb6:	4698      	mov	r8, r3
    3fb8:	2b01      	cmp	r3, #1
    3fba:	d174      	bne.n	40a6 <SDCard_Init+0x1a6>
    3fbc:	2400      	movs	r4, #0
    3fbe:	e005      	b.n	3fcc <SDCard_Init+0xcc>
			dataBuff[tvar] = SPI_SD_Read_Byte();
    3fc0:	4b51      	ldr	r3, [pc, #324]	; (4108 <SDCard_Init+0x208>)
    3fc2:	4798      	blx	r3
    3fc4:	4b51      	ldr	r3, [pc, #324]	; (410c <SDCard_Init+0x20c>)
    3fc6:	5518      	strb	r0, [r3, r4]
		for (tvar = 0; tvar < 4; tvar++)
    3fc8:	3401      	adds	r4, #1
    3fca:	b2e4      	uxtb	r4, r4
    3fcc:	2c03      	cmp	r4, #3
    3fce:	d9f7      	bls.n	3fc0 <SDCard_Init+0xc0>
		if (dataBuff[3] != 0xAA)
    3fd0:	4b4e      	ldr	r3, [pc, #312]	; (410c <SDCard_Init+0x20c>)
    3fd2:	78db      	ldrb	r3, [r3, #3]
    3fd4:	2baa      	cmp	r3, #170	; 0xaa
    3fd6:	d003      	beq.n	3fe0 <SDCard_Init+0xe0>
			UART3_Write_Text("CMD8 Failed: Card does not support required voltage\r\n");
    3fd8:	484d      	ldr	r0, [pc, #308]	; (4110 <SDCard_Init+0x210>)
    3fda:	4b38      	ldr	r3, [pc, #224]	; (40bc <SDCard_Init+0x1bc>)
    3fdc:	4798      	blx	r3
			return 1;
    3fde:	e066      	b.n	40ae <SDCard_Init+0x1ae>
		UART3_Write_Text("CMD8 Response Valid\r\n");
    3fe0:	484c      	ldr	r0, [pc, #304]	; (4114 <SDCard_Init+0x214>)
    3fe2:	4b36      	ldr	r3, [pc, #216]	; (40bc <SDCard_Init+0x1bc>)
    3fe4:	4798      	blx	r3
		cnt = 0xFFFF;
    3fe6:	4c4c      	ldr	r4, [pc, #304]	; (4118 <SDCard_Init+0x218>)
			tmp_55 = SDCard_WriteCmd(CMD55, 0, 0xFF);
    3fe8:	22ff      	movs	r2, #255	; 0xff
    3fea:	2100      	movs	r1, #0
    3fec:	2077      	movs	r0, #119	; 0x77
    3fee:	4f3e      	ldr	r7, [pc, #248]	; (40e8 <SDCard_Init+0x1e8>)
    3ff0:	47b8      	blx	r7
    3ff2:	4d3c      	ldr	r5, [pc, #240]	; (40e4 <SDCard_Init+0x1e4>)
    3ff4:	70e8      	strb	r0, [r5, #3]
			UART3_Write_Text("CMD55 Sent\r\n");
    3ff6:	4849      	ldr	r0, [pc, #292]	; (411c <SDCard_Init+0x21c>)
    3ff8:	4e30      	ldr	r6, [pc, #192]	; (40bc <SDCard_Init+0x1bc>)
    3ffa:	47b0      	blx	r6
			tmp_41 = SDCard_WriteCmd(CMD41, 0x40000000, 0xFF);
    3ffc:	22ff      	movs	r2, #255	; 0xff
    3ffe:	2180      	movs	r1, #128	; 0x80
    4000:	05c9      	lsls	r1, r1, #23
    4002:	2069      	movs	r0, #105	; 0x69
    4004:	47b8      	blx	r7
    4006:	7128      	strb	r0, [r5, #4]
			UART3_Write_Text("ACMD41 Sent\r\n");
    4008:	4845      	ldr	r0, [pc, #276]	; (4120 <SDCard_Init+0x220>)
    400a:	47b0      	blx	r6
			cnt--;
    400c:	3c01      	subs	r4, #1
    400e:	b2a4      	uxth	r4, r4
		} while ((tmp_41) && (cnt));
    4010:	792b      	ldrb	r3, [r5, #4]
    4012:	2b00      	cmp	r3, #0
    4014:	d001      	beq.n	401a <SDCard_Init+0x11a>
    4016:	2c00      	cmp	r4, #0
    4018:	d1e6      	bne.n	3fe8 <SDCard_Init+0xe8>
		if (cnt == 0)
    401a:	2c00      	cmp	r4, #0
    401c:	d010      	beq.n	4040 <SDCard_Init+0x140>
		UART3_Write_Text("Card Initialization Complete\r\n");
    401e:	4841      	ldr	r0, [pc, #260]	; (4124 <SDCard_Init+0x224>)
    4020:	4d26      	ldr	r5, [pc, #152]	; (40bc <SDCard_Init+0x1bc>)
    4022:	47a8      	blx	r5
		tmp_58 = SDCard_WriteCmd(CMD58, 0, 0xFF);
    4024:	22ff      	movs	r2, #255	; 0xff
    4026:	2100      	movs	r1, #0
    4028:	207a      	movs	r0, #122	; 0x7a
    402a:	4b2f      	ldr	r3, [pc, #188]	; (40e8 <SDCard_Init+0x1e8>)
    402c:	4798      	blx	r3
    402e:	4c2d      	ldr	r4, [pc, #180]	; (40e4 <SDCard_Init+0x1e4>)
    4030:	7160      	strb	r0, [r4, #5]
		UART3_Write_Text("CMD58 Sent\r\n");
    4032:	483d      	ldr	r0, [pc, #244]	; (4128 <SDCard_Init+0x228>)
    4034:	47a8      	blx	r5
		if (tmp_58 != 0x00)
    4036:	7965      	ldrb	r5, [r4, #5]
    4038:	2d00      	cmp	r5, #0
    403a:	d108      	bne.n	404e <SDCard_Init+0x14e>
    403c:	002c      	movs	r4, r5
    403e:	e013      	b.n	4068 <SDCard_Init+0x168>
			UART3_Write_Text("ACMD41 Timeout\r\n");
    4040:	483a      	ldr	r0, [pc, #232]	; (412c <SDCard_Init+0x22c>)
    4042:	4b1e      	ldr	r3, [pc, #120]	; (40bc <SDCard_Init+0x1bc>)
    4044:	4798      	blx	r3
			SDCard_SS(1);
    4046:	2001      	movs	r0, #1
    4048:	4b21      	ldr	r3, [pc, #132]	; (40d0 <SDCard_Init+0x1d0>)
    404a:	4798      	blx	r3
			return 1;
    404c:	e02f      	b.n	40ae <SDCard_Init+0x1ae>
			SDCard_SS(1);
    404e:	2001      	movs	r0, #1
    4050:	4b1f      	ldr	r3, [pc, #124]	; (40d0 <SDCard_Init+0x1d0>)
    4052:	4798      	blx	r3
			UART3_Write_Text("Problem reading OCR data\r\n");
    4054:	4836      	ldr	r0, [pc, #216]	; (4130 <SDCard_Init+0x230>)
    4056:	4b19      	ldr	r3, [pc, #100]	; (40bc <SDCard_Init+0x1bc>)
    4058:	4798      	blx	r3
			return 1;
    405a:	e028      	b.n	40ae <SDCard_Init+0x1ae>
			dataBuff[tvar] = SPI_SD_Read_Byte();
    405c:	4b2a      	ldr	r3, [pc, #168]	; (4108 <SDCard_Init+0x208>)
    405e:	4798      	blx	r3
    4060:	4b2a      	ldr	r3, [pc, #168]	; (410c <SDCard_Init+0x20c>)
    4062:	5518      	strb	r0, [r3, r4]
		for (tvar = 0; tvar < 4; tvar++)
    4064:	3401      	adds	r4, #1
    4066:	b2e4      	uxtb	r4, r4
    4068:	2c03      	cmp	r4, #3
    406a:	d9f7      	bls.n	405c <SDCard_Init+0x15c>
		if (dataBuff[0] & 0x40)
    406c:	4b27      	ldr	r3, [pc, #156]	; (410c <SDCard_Init+0x20c>)
    406e:	781b      	ldrb	r3, [r3, #0]
    4070:	065b      	lsls	r3, r3, #25
    4072:	d511      	bpl.n	4098 <SDCard_Init+0x198>
			SD_Type = SD_TYPE_V2HC;
    4074:	2204      	movs	r2, #4
    4076:	4b1b      	ldr	r3, [pc, #108]	; (40e4 <SDCard_Init+0x1e4>)
    4078:	719a      	strb	r2, [r3, #6]
			UART3_Write_Text("Card: V2.0 SDHC\r\n");
    407a:	482e      	ldr	r0, [pc, #184]	; (4134 <SDCard_Init+0x234>)
    407c:	4b0f      	ldr	r3, [pc, #60]	; (40bc <SDCard_Init+0x1bc>)
    407e:	4798      	blx	r3
	UART3_Write_Text("Initialization Complete \r\n");
    4080:	482d      	ldr	r0, [pc, #180]	; (4138 <SDCard_Init+0x238>)
    4082:	4c0e      	ldr	r4, [pc, #56]	; (40bc <SDCard_Init+0x1bc>)
    4084:	47a0      	blx	r4
	SDCard_RunSpeed();
    4086:	4b2d      	ldr	r3, [pc, #180]	; (413c <SDCard_Init+0x23c>)
    4088:	4798      	blx	r3
	UART3_Write_Text("Switched to Fast Speed\r\n");
    408a:	482d      	ldr	r0, [pc, #180]	; (4140 <SDCard_Init+0x240>)
    408c:	47a0      	blx	r4
	SDCard_SS(1);
    408e:	2001      	movs	r0, #1
    4090:	4b0f      	ldr	r3, [pc, #60]	; (40d0 <SDCard_Init+0x1d0>)
    4092:	4798      	blx	r3
	return 0;
    4094:	46a8      	mov	r8, r5
    4096:	e00a      	b.n	40ae <SDCard_Init+0x1ae>
			SD_Type = SD_TYPE_V2;
    4098:	2202      	movs	r2, #2
    409a:	4b12      	ldr	r3, [pc, #72]	; (40e4 <SDCard_Init+0x1e4>)
    409c:	719a      	strb	r2, [r3, #6]
			UART3_Write_Text("Card Type: V2.0 Standard Capacity\r\n");
    409e:	4829      	ldr	r0, [pc, #164]	; (4144 <SDCard_Init+0x244>)
    40a0:	4b06      	ldr	r3, [pc, #24]	; (40bc <SDCard_Init+0x1bc>)
    40a2:	4798      	blx	r3
    40a4:	e7ec      	b.n	4080 <SDCard_Init+0x180>
		UART3_Write_Text("CMD8 Failed, Card Not Supported\r\n");
    40a6:	4828      	ldr	r0, [pc, #160]	; (4148 <SDCard_Init+0x248>)
    40a8:	4b04      	ldr	r3, [pc, #16]	; (40bc <SDCard_Init+0x1bc>)
    40aa:	4798      	blx	r3
		return 1;
    40ac:	46a0      	mov	r8, r4
}
    40ae:	4640      	mov	r0, r8
    40b0:	b004      	add	sp, #16
    40b2:	bc04      	pop	{r2}
    40b4:	4690      	mov	r8, r2
    40b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40b8:	000051d4 	.word	0x000051d4
    40bc:	00004771 	.word	0x00004771
    40c0:	00003d59 	.word	0x00003d59
    40c4:	000051f8 	.word	0x000051f8
    40c8:	000a7693 	.word	0x000a7693
    40cc:	00002441 	.word	0x00002441
    40d0:	00003d71 	.word	0x00003d71
    40d4:	00004691 	.word	0x00004691
    40d8:	0000521c 	.word	0x0000521c
    40dc:	00005234 	.word	0x00005234
    40e0:	000217b7 	.word	0x000217b7
    40e4:	2000045e 	.word	0x2000045e
    40e8:	00003e11 	.word	0x00003e11
    40ec:	00003db1 	.word	0x00003db1
    40f0:	00005244 	.word	0x00005244
    40f4:	00005094 	.word	0x00005094
    40f8:	00005268 	.word	0x00005268
    40fc:	00010bdc 	.word	0x00010bdc
    4100:	00005278 	.word	0x00005278
    4104:	00005290 	.word	0x00005290
    4108:	0000469d 	.word	0x0000469d
    410c:	200008c8 	.word	0x200008c8
    4110:	0000529c 	.word	0x0000529c
    4114:	000052d4 	.word	0x000052d4
    4118:	0000ffff 	.word	0x0000ffff
    411c:	000052ec 	.word	0x000052ec
    4120:	000052fc 	.word	0x000052fc
    4124:	00005320 	.word	0x00005320
    4128:	00005340 	.word	0x00005340
    412c:	0000530c 	.word	0x0000530c
    4130:	00005350 	.word	0x00005350
    4134:	0000536c 	.word	0x0000536c
    4138:	000053c8 	.word	0x000053c8
    413c:	00003d65 	.word	0x00003d65
    4140:	000053e4 	.word	0x000053e4
    4144:	00005380 	.word	0x00005380
    4148:	000053a4 	.word	0x000053a4

0000414c <SDCard_CardID>:

/*-----------------------------------------------------------------------*/
/* Get the SD Card ID                                                    */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_CardID(uint8_t cmd, uint8_t *buf)
{
    414c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    414e:	000e      	movs	r6, r1
	uint8_t i;

	if (SDCard_WriteCmd(cmd, 0x00, 0xFF) != 0x00)
    4150:	22ff      	movs	r2, #255	; 0xff
    4152:	2100      	movs	r1, #0
    4154:	4b09      	ldr	r3, [pc, #36]	; (417c <SDCard_CardID+0x30>)
    4156:	4798      	blx	r3
    4158:	1e05      	subs	r5, r0, #0
    415a:	d10d      	bne.n	4178 <SDCard_CardID+0x2c>
    415c:	0004      	movs	r4, r0
    415e:	e007      	b.n	4170 <SDCard_CardID+0x24>
		return 1;
	}

	for (i = 0; i < 16; i++)
	{
		*buf++ = SPI_SD_Send_Byte(0xFF);
    4160:	1c77      	adds	r7, r6, #1
    4162:	20ff      	movs	r0, #255	; 0xff
    4164:	4b06      	ldr	r3, [pc, #24]	; (4180 <SDCard_CardID+0x34>)
    4166:	4798      	blx	r3
    4168:	7030      	strb	r0, [r6, #0]
	for (i = 0; i < 16; i++)
    416a:	3401      	adds	r4, #1
    416c:	b2e4      	uxtb	r4, r4
		*buf++ = SPI_SD_Send_Byte(0xFF);
    416e:	003e      	movs	r6, r7
	for (i = 0; i < 16; i++)
    4170:	2c0f      	cmp	r4, #15
    4172:	d9f5      	bls.n	4160 <SDCard_CardID+0x14>
	}

	return 0;
}
    4174:	0028      	movs	r0, r5
    4176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;
    4178:	2501      	movs	r5, #1
    417a:	e7fb      	b.n	4174 <SDCard_CardID+0x28>
    417c:	00003e11 	.word	0x00003e11
    4180:	00004691 	.word	0x00004691

00004184 <SDCard_ReadSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Read a single block of Data                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadSingleBlock(uint32_t addr, uint8_t *buf)
{
    4184:	b570      	push	{r4, r5, r6, lr}
    4186:	0004      	movs	r4, r0
    4188:	000e      	movs	r6, r1
	uint16_t i;

	if(SD_Type != SD_TYPE_V2HC)
    418a:	4b23      	ldr	r3, [pc, #140]	; (4218 <SDCard_ReadSingleBlock+0x94>)
    418c:	799b      	ldrb	r3, [r3, #6]
    418e:	2b04      	cmp	r3, #4
    4190:	d003      	beq.n	419a <SDCard_ReadSingleBlock+0x16>
	{
		UART3_Write_Text("Not SD_TYPE_V2HC\r\n");
    4192:	4822      	ldr	r0, [pc, #136]	; (421c <SDCard_ReadSingleBlock+0x98>)
    4194:	4b22      	ldr	r3, [pc, #136]	; (4220 <SDCard_ReadSingleBlock+0x9c>)
    4196:	4798      	blx	r3
		addr = addr << 9;
    4198:	0264      	lsls	r4, r4, #9
	}

	tmp17 = SDCard_WriteCmd(CMD17, addr, 0x01);
    419a:	2201      	movs	r2, #1
    419c:	0021      	movs	r1, r4
    419e:	2051      	movs	r0, #81	; 0x51
    41a0:	4b20      	ldr	r3, [pc, #128]	; (4224 <SDCard_ReadSingleBlock+0xa0>)
    41a2:	4798      	blx	r3
    41a4:	4b1c      	ldr	r3, [pc, #112]	; (4218 <SDCard_ReadSingleBlock+0x94>)
    41a6:	71d8      	strb	r0, [r3, #7]

	while(tmp17 != 0)
    41a8:	e009      	b.n	41be <SDCard_ReadSingleBlock+0x3a>
	{
		UART3_Write_Text("Read block address\r\n");
    41aa:	481f      	ldr	r0, [pc, #124]	; (4228 <SDCard_ReadSingleBlock+0xa4>)
    41ac:	4b1c      	ldr	r3, [pc, #112]	; (4220 <SDCard_ReadSingleBlock+0x9c>)
    41ae:	4798      	blx	r3
		tmp17 = SDCard_WriteCmd(CMD17, addr, 0x01);
    41b0:	2201      	movs	r2, #1
    41b2:	0021      	movs	r1, r4
    41b4:	2051      	movs	r0, #81	; 0x51
    41b6:	4b1b      	ldr	r3, [pc, #108]	; (4224 <SDCard_ReadSingleBlock+0xa0>)
    41b8:	4798      	blx	r3
    41ba:	4b17      	ldr	r3, [pc, #92]	; (4218 <SDCard_ReadSingleBlock+0x94>)
    41bc:	71d8      	strb	r0, [r3, #7]
	while(tmp17 != 0)
    41be:	4b16      	ldr	r3, [pc, #88]	; (4218 <SDCard_ReadSingleBlock+0x94>)
    41c0:	79db      	ldrb	r3, [r3, #7]
    41c2:	2b00      	cmp	r3, #0
    41c4:	d1f1      	bne.n	41aa <SDCard_ReadSingleBlock+0x26>
	}
	delay_ms(1);
    41c6:	4819      	ldr	r0, [pc, #100]	; (422c <SDCard_ReadSingleBlock+0xa8>)
    41c8:	4b19      	ldr	r3, [pc, #100]	; (4230 <SDCard_ReadSingleBlock+0xac>)
    41ca:	4798      	blx	r3

	while (SPI_SD_Read_Byte() != 0xFE)
    41cc:	4b19      	ldr	r3, [pc, #100]	; (4234 <SDCard_ReadSingleBlock+0xb0>)
    41ce:	4798      	blx	r3
    41d0:	28fe      	cmp	r0, #254	; 0xfe
    41d2:	d1fb      	bne.n	41cc <SDCard_ReadSingleBlock+0x48>
	{
	}

	if(tmp17 == 0)
    41d4:	4b10      	ldr	r3, [pc, #64]	; (4218 <SDCard_ReadSingleBlock+0x94>)
    41d6:	79db      	ldrb	r3, [r3, #7]
    41d8:	2b00      	cmp	r3, #0
    41da:	d00c      	beq.n	41f6 <SDCard_ReadSingleBlock+0x72>
			buf[i] = SPI_SD_Send_Byte(0xFF);
		}
	}

	// Done reading
	UART3_Write_Text("Read complete\r\n");
    41dc:	4816      	ldr	r0, [pc, #88]	; (4238 <SDCard_ReadSingleBlock+0xb4>)
    41de:	4b10      	ldr	r3, [pc, #64]	; (4220 <SDCard_ReadSingleBlock+0x9c>)
    41e0:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    41e2:	20ff      	movs	r0, #255	; 0xff
    41e4:	4c15      	ldr	r4, [pc, #84]	; (423c <SDCard_ReadSingleBlock+0xb8>)
    41e6:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFF);
    41e8:	20ff      	movs	r0, #255	; 0xff
    41ea:	47a0      	blx	r4
	SDCard_SS(1);
    41ec:	2001      	movs	r0, #1
    41ee:	4b14      	ldr	r3, [pc, #80]	; (4240 <SDCard_ReadSingleBlock+0xbc>)
    41f0:	4798      	blx	r3
	return 0;
}
    41f2:	2000      	movs	r0, #0
    41f4:	bd70      	pop	{r4, r5, r6, pc}
		UART3_Write_Text("Reading\r\n");
    41f6:	4813      	ldr	r0, [pc, #76]	; (4244 <SDCard_ReadSingleBlock+0xc0>)
    41f8:	4b09      	ldr	r3, [pc, #36]	; (4220 <SDCard_ReadSingleBlock+0x9c>)
    41fa:	4798      	blx	r3
		for (i = 0; i < 512; i++)
    41fc:	2400      	movs	r4, #0
    41fe:	e006      	b.n	420e <SDCard_ReadSingleBlock+0x8a>
			buf[i] = SPI_SD_Send_Byte(0xFF);
    4200:	1935      	adds	r5, r6, r4
    4202:	20ff      	movs	r0, #255	; 0xff
    4204:	4b0d      	ldr	r3, [pc, #52]	; (423c <SDCard_ReadSingleBlock+0xb8>)
    4206:	4798      	blx	r3
    4208:	7028      	strb	r0, [r5, #0]
		for (i = 0; i < 512; i++)
    420a:	3401      	adds	r4, #1
    420c:	b2a4      	uxth	r4, r4
    420e:	4b0e      	ldr	r3, [pc, #56]	; (4248 <SDCard_ReadSingleBlock+0xc4>)
    4210:	429c      	cmp	r4, r3
    4212:	d9f5      	bls.n	4200 <SDCard_ReadSingleBlock+0x7c>
    4214:	e7e2      	b.n	41dc <SDCard_ReadSingleBlock+0x58>
    4216:	46c0      	nop			; (mov r8, r8)
    4218:	2000045e 	.word	0x2000045e
    421c:	00005400 	.word	0x00005400
    4220:	00004771 	.word	0x00004771
    4224:	00003e11 	.word	0x00003e11
    4228:	00005414 	.word	0x00005414
    422c:	00001aca 	.word	0x00001aca
    4230:	00002441 	.word	0x00002441
    4234:	0000469d 	.word	0x0000469d
    4238:	00005438 	.word	0x00005438
    423c:	00004691 	.word	0x00004691
    4240:	00003d71 	.word	0x00003d71
    4244:	0000542c 	.word	0x0000542c
    4248:	000001ff 	.word	0x000001ff

0000424c <SDCard_ReadMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Read multiple blocks of Data                                          */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadMultipleBlock(uint32_t addr, uint8_t *buf, uint8_t count)
{
    424c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    424e:	000d      	movs	r5, r1
    4250:	0017      	movs	r7, r2
	uint16_t i;

	if(SD_Type != SD_TYPE_V2HC)
    4252:	4b1c      	ldr	r3, [pc, #112]	; (42c4 <SDCard_ReadMultipleBlock+0x78>)
    4254:	799b      	ldrb	r3, [r3, #6]
    4256:	2b04      	cmp	r3, #4
    4258:	d000      	beq.n	425c <SDCard_ReadMultipleBlock+0x10>
	{
		addr = addr << 9;
    425a:	0240      	lsls	r0, r0, #9
	}

	if (SDCard_WriteCmd(CMD18, addr, 0xFF) != 0x00)
    425c:	22ff      	movs	r2, #255	; 0xff
    425e:	0001      	movs	r1, r0
    4260:	2052      	movs	r0, #82	; 0x52
    4262:	4b19      	ldr	r3, [pc, #100]	; (42c8 <SDCard_ReadMultipleBlock+0x7c>)
    4264:	4798      	blx	r3
    4266:	2800      	cmp	r0, #0
    4268:	d001      	beq.n	426e <SDCard_ReadMultipleBlock+0x22>
	{
		return 1;
    426a:	2001      	movs	r0, #1

	// Force stop transmission after multiple block read
	SDCard_WriteCmd(CMD12, 0x00, 0xFF);
	SPI_SD_Send_Byte(0xFF);
	return 0;
}
    426c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SDCard_SS(0);
    426e:	4b17      	ldr	r3, [pc, #92]	; (42cc <SDCard_ReadMultipleBlock+0x80>)
    4270:	4798      	blx	r3
    4272:	e013      	b.n	429c <SDCard_ReadMultipleBlock+0x50>
			*buf++ = SPI_SD_Send_Byte(0xFF);
    4274:	1c6e      	adds	r6, r5, #1
    4276:	20ff      	movs	r0, #255	; 0xff
    4278:	4b15      	ldr	r3, [pc, #84]	; (42d0 <SDCard_ReadMultipleBlock+0x84>)
    427a:	4798      	blx	r3
    427c:	7028      	strb	r0, [r5, #0]
		for (i = 0; i < 512; i++)
    427e:	3401      	adds	r4, #1
    4280:	b2a4      	uxth	r4, r4
			*buf++ = SPI_SD_Send_Byte(0xFF);
    4282:	0035      	movs	r5, r6
		for (i = 0; i < 512; i++)
    4284:	4b13      	ldr	r3, [pc, #76]	; (42d4 <SDCard_ReadMultipleBlock+0x88>)
    4286:	429c      	cmp	r4, r3
    4288:	d9f4      	bls.n	4274 <SDCard_ReadMultipleBlock+0x28>
		SPI_SD_Send_Byte(0xFF);
    428a:	20ff      	movs	r0, #255	; 0xff
    428c:	4c10      	ldr	r4, [pc, #64]	; (42d0 <SDCard_ReadMultipleBlock+0x84>)
    428e:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    4290:	20ff      	movs	r0, #255	; 0xff
    4292:	47a0      	blx	r4
	} while (--count);
    4294:	3f01      	subs	r7, #1
    4296:	b2ff      	uxtb	r7, r7
    4298:	2f00      	cmp	r7, #0
    429a:	d006      	beq.n	42aa <SDCard_ReadMultipleBlock+0x5e>
		while(SPI_SD_Send_Byte(0xFF) != 0xFE);
    429c:	20ff      	movs	r0, #255	; 0xff
    429e:	4b0c      	ldr	r3, [pc, #48]	; (42d0 <SDCard_ReadMultipleBlock+0x84>)
    42a0:	4798      	blx	r3
    42a2:	28fe      	cmp	r0, #254	; 0xfe
    42a4:	d1fa      	bne.n	429c <SDCard_ReadMultipleBlock+0x50>
    42a6:	2400      	movs	r4, #0
    42a8:	e7ec      	b.n	4284 <SDCard_ReadMultipleBlock+0x38>
	SDCard_SS(1);
    42aa:	2001      	movs	r0, #1
    42ac:	4b07      	ldr	r3, [pc, #28]	; (42cc <SDCard_ReadMultipleBlock+0x80>)
    42ae:	4798      	blx	r3
	SDCard_WriteCmd(CMD12, 0x00, 0xFF);
    42b0:	22ff      	movs	r2, #255	; 0xff
    42b2:	2100      	movs	r1, #0
    42b4:	204c      	movs	r0, #76	; 0x4c
    42b6:	4b04      	ldr	r3, [pc, #16]	; (42c8 <SDCard_ReadMultipleBlock+0x7c>)
    42b8:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    42ba:	20ff      	movs	r0, #255	; 0xff
    42bc:	4b04      	ldr	r3, [pc, #16]	; (42d0 <SDCard_ReadMultipleBlock+0x84>)
    42be:	4798      	blx	r3
	return 0;
    42c0:	0038      	movs	r0, r7
    42c2:	e7d3      	b.n	426c <SDCard_ReadMultipleBlock+0x20>
    42c4:	2000045e 	.word	0x2000045e
    42c8:	00003e11 	.word	0x00003e11
    42cc:	00003d71 	.word	0x00003d71
    42d0:	00004691 	.word	0x00004691
    42d4:	000001ff 	.word	0x000001ff

000042d8 <SDCard_WriteSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Single Block of Data                                            */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteSingleBlock(uint32_t addr, const uint8_t *buf)
{
    42d8:	b570      	push	{r4, r5, r6, lr}
    42da:	0004      	movs	r4, r0
    42dc:	000d      	movs	r5, r1
	uint8_t  temp;
	uint16_t retry = 0;
	uint16_t i;

	if(SD_Type != SD_TYPE_V2HC)
    42de:	4b2e      	ldr	r3, [pc, #184]	; (4398 <SDCard_WriteSingleBlock+0xc0>)
    42e0:	799b      	ldrb	r3, [r3, #6]
    42e2:	2b04      	cmp	r3, #4
    42e4:	d000      	beq.n	42e8 <SDCard_WriteSingleBlock+0x10>
	{
		addr = addr << 9;
    42e6:	0244      	lsls	r4, r0, #9
	}

	tmp_24 = SDCard_WriteCmd(CMD24, addr, 0x01);
    42e8:	2201      	movs	r2, #1
    42ea:	0021      	movs	r1, r4
    42ec:	2058      	movs	r0, #88	; 0x58
    42ee:	4b2b      	ldr	r3, [pc, #172]	; (439c <SDCard_WriteSingleBlock+0xc4>)
    42f0:	4798      	blx	r3
    42f2:	4b29      	ldr	r3, [pc, #164]	; (4398 <SDCard_WriteSingleBlock+0xc0>)
    42f4:	7218      	strb	r0, [r3, #8]

	while(tmp_24 != 0)
    42f6:	e006      	b.n	4306 <SDCard_WriteSingleBlock+0x2e>
	{
		tmp_24 = SDCard_WriteCmd(CMD24, addr, 0x01);
    42f8:	2201      	movs	r2, #1
    42fa:	0021      	movs	r1, r4
    42fc:	2058      	movs	r0, #88	; 0x58
    42fe:	4b27      	ldr	r3, [pc, #156]	; (439c <SDCard_WriteSingleBlock+0xc4>)
    4300:	4798      	blx	r3
    4302:	4b25      	ldr	r3, [pc, #148]	; (4398 <SDCard_WriteSingleBlock+0xc0>)
    4304:	7218      	strb	r0, [r3, #8]
	while(tmp_24 != 0)
    4306:	4b24      	ldr	r3, [pc, #144]	; (4398 <SDCard_WriteSingleBlock+0xc0>)
    4308:	7a1e      	ldrb	r6, [r3, #8]
    430a:	2e00      	cmp	r6, #0
    430c:	d1f4      	bne.n	42f8 <SDCard_WriteSingleBlock+0x20>
	{
		UART3_Write_Text("Reading\r\n");
		return 1;
	}

	SDCard_SS(0);
    430e:	2000      	movs	r0, #0
    4310:	4b23      	ldr	r3, [pc, #140]	; (43a0 <SDCard_WriteSingleBlock+0xc8>)
    4312:	4798      	blx	r3

	// Wait until SD Card is ready
	SPI_SD_Send_Byte(0xFF);
    4314:	20ff      	movs	r0, #255	; 0xff
    4316:	4c23      	ldr	r4, [pc, #140]	; (43a4 <SDCard_WriteSingleBlock+0xcc>)
    4318:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFF);
    431a:	20ff      	movs	r0, #255	; 0xff
    431c:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFF);
    431e:	20ff      	movs	r0, #255	; 0xff
    4320:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFE);
    4322:	20fe      	movs	r0, #254	; 0xfe
    4324:	47a0      	blx	r4

	for (i = 0; i < 512; i++)
    4326:	2400      	movs	r4, #0
    4328:	e004      	b.n	4334 <SDCard_WriteSingleBlock+0x5c>
	{
		SPI_SD_Send_Byte(buf[i]);
    432a:	5d28      	ldrb	r0, [r5, r4]
    432c:	4b1d      	ldr	r3, [pc, #116]	; (43a4 <SDCard_WriteSingleBlock+0xcc>)
    432e:	4798      	blx	r3
	for (i = 0; i < 512; i++)
    4330:	3401      	adds	r4, #1
    4332:	b2a4      	uxth	r4, r4
    4334:	4b1c      	ldr	r3, [pc, #112]	; (43a8 <SDCard_WriteSingleBlock+0xd0>)
    4336:	429c      	cmp	r4, r3
    4338:	d9f7      	bls.n	432a <SDCard_WriteSingleBlock+0x52>
	}

	// Send CRC Info (dummy)
	SPI_SD_Send_Byte(0xFF);
    433a:	20ff      	movs	r0, #255	; 0xff
    433c:	4c19      	ldr	r4, [pc, #100]	; (43a4 <SDCard_WriteSingleBlock+0xcc>)
    433e:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFF);
    4340:	20ff      	movs	r0, #255	; 0xff
    4342:	47a0      	blx	r4
	temp = SPI_SD_Send_Byte(0xFF);
    4344:	20ff      	movs	r0, #255	; 0xff
    4346:	47a0      	blx	r4
	temp &= 0x1F;
    4348:	231f      	movs	r3, #31
    434a:	4018      	ands	r0, r3

	if (temp != 0x05)
    434c:	2805      	cmp	r0, #5
    434e:	d10f      	bne.n	4370 <SDCard_WriteSingleBlock+0x98>
    4350:	2400      	movs	r4, #0
		UART3_Write_Text("CRC Write Fail\r\n");
		SDCard_SS(1);
		return 1;
	}

	while (SPI_SD_Send_Byte(0xFF) == 0x00)
    4352:	20ff      	movs	r0, #255	; 0xff
    4354:	4b13      	ldr	r3, [pc, #76]	; (43a4 <SDCard_WriteSingleBlock+0xcc>)
    4356:	4798      	blx	r3
    4358:	2800      	cmp	r0, #0
    435a:	d111      	bne.n	4380 <SDCard_WriteSingleBlock+0xa8>
	{
		retry++;
    435c:	3401      	adds	r4, #1
    435e:	b2a4      	uxth	r4, r4
		if(retry > 0xfffe)
    4360:	4b12      	ldr	r3, [pc, #72]	; (43ac <SDCard_WriteSingleBlock+0xd4>)
    4362:	429c      	cmp	r4, r3
    4364:	d1f5      	bne.n	4352 <SDCard_WriteSingleBlock+0x7a>
		{
			SDCard_SS(1);
    4366:	2001      	movs	r0, #1
    4368:	4b0d      	ldr	r3, [pc, #52]	; (43a0 <SDCard_WriteSingleBlock+0xc8>)
    436a:	4798      	blx	r3
			return 1;
    436c:	2601      	movs	r6, #1
    436e:	e010      	b.n	4392 <SDCard_WriteSingleBlock+0xba>
		UART3_Write_Text("CRC Write Fail\r\n");
    4370:	480f      	ldr	r0, [pc, #60]	; (43b0 <SDCard_WriteSingleBlock+0xd8>)
    4372:	4b10      	ldr	r3, [pc, #64]	; (43b4 <SDCard_WriteSingleBlock+0xdc>)
    4374:	4798      	blx	r3
		SDCard_SS(1);
    4376:	2001      	movs	r0, #1
    4378:	4b09      	ldr	r3, [pc, #36]	; (43a0 <SDCard_WriteSingleBlock+0xc8>)
    437a:	4798      	blx	r3
		return 1;
    437c:	2601      	movs	r6, #1
    437e:	e008      	b.n	4392 <SDCard_WriteSingleBlock+0xba>
		}
	}

	SDCard_SS(1);
    4380:	2001      	movs	r0, #1
    4382:	4b07      	ldr	r3, [pc, #28]	; (43a0 <SDCard_WriteSingleBlock+0xc8>)
    4384:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    4386:	20ff      	movs	r0, #255	; 0xff
    4388:	4b06      	ldr	r3, [pc, #24]	; (43a4 <SDCard_WriteSingleBlock+0xcc>)
    438a:	4798      	blx	r3
	UART3_Write_Text("Write Complete\r\n");
    438c:	480a      	ldr	r0, [pc, #40]	; (43b8 <SDCard_WriteSingleBlock+0xe0>)
    438e:	4b09      	ldr	r3, [pc, #36]	; (43b4 <SDCard_WriteSingleBlock+0xdc>)
    4390:	4798      	blx	r3
	return 0;
}
    4392:	0030      	movs	r0, r6
    4394:	bd70      	pop	{r4, r5, r6, pc}
    4396:	46c0      	nop			; (mov r8, r8)
    4398:	2000045e 	.word	0x2000045e
    439c:	00003e11 	.word	0x00003e11
    43a0:	00003d71 	.word	0x00003d71
    43a4:	00004691 	.word	0x00004691
    43a8:	000001ff 	.word	0x000001ff
    43ac:	0000ffff 	.word	0x0000ffff
    43b0:	00005448 	.word	0x00005448
    43b4:	00004771 	.word	0x00004771
    43b8:	0000545c 	.word	0x0000545c

000043bc <SDCard_WriteMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Multiple Blocks of Data                                         */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteMultipleBlock(uint32_t addr, const uint8_t *buf, uint8_t count)
{
    43bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    43be:	0004      	movs	r4, r0
    43c0:	000d      	movs	r5, r1
    43c2:	0017      	movs	r7, r2
	uint16_t i;
	uint8_t tmp;

	if(SD_Type != SD_TYPE_V2HC)
    43c4:	4b2f      	ldr	r3, [pc, #188]	; (4484 <SDCard_WriteMultipleBlock+0xc8>)
    43c6:	799b      	ldrb	r3, [r3, #6]
    43c8:	2b04      	cmp	r3, #4
    43ca:	d000      	beq.n	43ce <SDCard_WriteMultipleBlock+0x12>
	{
		addr = addr << 9;
    43cc:	0244      	lsls	r4, r0, #9
	}

	if(SD_Type != SD_TYPE_MMC)
    43ce:	2b00      	cmp	r3, #0
    43d0:	d10f      	bne.n	43f2 <SDCard_WriteMultipleBlock+0x36>
	{
		// pre-erase write sector
		tmp = SDCard_WriteCmd(CMD23, count, 0x00);
	}

	if (SDCard_WriteCmd(CMD25, addr, 0xFF) != 0x00)
    43d2:	22ff      	movs	r2, #255	; 0xff
    43d4:	0021      	movs	r1, r4
    43d6:	2059      	movs	r0, #89	; 0x59
    43d8:	4b2b      	ldr	r3, [pc, #172]	; (4488 <SDCard_WriteMultipleBlock+0xcc>)
    43da:	4798      	blx	r3
    43dc:	2800      	cmp	r0, #0
    43de:	d10e      	bne.n	43fe <SDCard_WriteMultipleBlock+0x42>
	{
		UART3_Write_Text("Write Multiple Block Address Failed\r\n");
		return 1;
	}

	SDCard_SS(0);
    43e0:	2000      	movs	r0, #0
    43e2:	4b2a      	ldr	r3, [pc, #168]	; (448c <SDCard_WriteMultipleBlock+0xd0>)
    43e4:	4798      	blx	r3

	// Wait until SD Card is ready
	SPI_SD_Send_Byte(0xFF);
    43e6:	20ff      	movs	r0, #255	; 0xff
    43e8:	4c29      	ldr	r4, [pc, #164]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    43ea:	47a0      	blx	r4
	SPI_SD_Send_Byte(0xFF);
    43ec:	20ff      	movs	r0, #255	; 0xff
    43ee:	47a0      	blx	r4
    43f0:	e028      	b.n	4444 <SDCard_WriteMultipleBlock+0x88>
		tmp = SDCard_WriteCmd(CMD23, count, 0x00);
    43f2:	2200      	movs	r2, #0
    43f4:	0039      	movs	r1, r7
    43f6:	2057      	movs	r0, #87	; 0x57
    43f8:	4b23      	ldr	r3, [pc, #140]	; (4488 <SDCard_WriteMultipleBlock+0xcc>)
    43fa:	4798      	blx	r3
    43fc:	e7e9      	b.n	43d2 <SDCard_WriteMultipleBlock+0x16>
		UART3_Write_Text("Write Multiple Block Address Failed\r\n");
    43fe:	4825      	ldr	r0, [pc, #148]	; (4494 <SDCard_WriteMultipleBlock+0xd8>)
    4400:	4b25      	ldr	r3, [pc, #148]	; (4498 <SDCard_WriteMultipleBlock+0xdc>)
    4402:	4798      	blx	r3
		return 1;
    4404:	2001      	movs	r0, #1
	// done writing
	SDCard_SS(1);
	SPI_SD_Send_Byte(0xFF);
	UART3_Write_Text("Write Multiple Complete\r\n");
	return 0;
}
    4406:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			SPI_SD_Send_Byte(*buf++);
    4408:	1c6e      	adds	r6, r5, #1
    440a:	7828      	ldrb	r0, [r5, #0]
    440c:	4b20      	ldr	r3, [pc, #128]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    440e:	4798      	blx	r3
		for (i = 0; i < 512; i++)
    4410:	3401      	adds	r4, #1
    4412:	b2a4      	uxth	r4, r4
			SPI_SD_Send_Byte(*buf++);
    4414:	0035      	movs	r5, r6
		for (i = 0; i < 512; i++)
    4416:	4b21      	ldr	r3, [pc, #132]	; (449c <SDCard_WriteMultipleBlock+0xe0>)
    4418:	429c      	cmp	r4, r3
    441a:	d9f5      	bls.n	4408 <SDCard_WriteMultipleBlock+0x4c>
		SPI_SD_Send_Byte(0xFF);
    441c:	20ff      	movs	r0, #255	; 0xff
    441e:	4c1c      	ldr	r4, [pc, #112]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4420:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    4422:	20ff      	movs	r0, #255	; 0xff
    4424:	47a0      	blx	r4
		tmp = SPI_SD_Send_Byte(0xFF);
    4426:	20ff      	movs	r0, #255	; 0xff
    4428:	47a0      	blx	r4
		tmp &= 0x1F;
    442a:	231f      	movs	r3, #31
    442c:	4018      	ands	r0, r3
		if(tmp != 0x05)
    442e:	2805      	cmp	r0, #5
    4430:	d10d      	bne.n	444e <SDCard_WriteMultipleBlock+0x92>
		while(SPI_SD_Send_Byte(0xFF) == 0x00);
    4432:	20ff      	movs	r0, #255	; 0xff
    4434:	4b16      	ldr	r3, [pc, #88]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4436:	4798      	blx	r3
    4438:	2800      	cmp	r0, #0
    443a:	d0fa      	beq.n	4432 <SDCard_WriteMultipleBlock+0x76>
	} while (--count);
    443c:	3f01      	subs	r7, #1
    443e:	b2ff      	uxtb	r7, r7
    4440:	2f00      	cmp	r7, #0
    4442:	d00c      	beq.n	445e <SDCard_WriteMultipleBlock+0xa2>
		SPI_SD_Send_Byte(0xFC);
    4444:	20fc      	movs	r0, #252	; 0xfc
    4446:	4b12      	ldr	r3, [pc, #72]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4448:	4798      	blx	r3
		for (i = 0; i < 512; i++)
    444a:	2400      	movs	r4, #0
    444c:	e7e3      	b.n	4416 <SDCard_WriteMultipleBlock+0x5a>
			UART3_Write_Text("CRC Multiple Write Failed\r\n");
    444e:	4814      	ldr	r0, [pc, #80]	; (44a0 <SDCard_WriteMultipleBlock+0xe4>)
    4450:	4b11      	ldr	r3, [pc, #68]	; (4498 <SDCard_WriteMultipleBlock+0xdc>)
    4452:	4798      	blx	r3
			SDCard_SS(1);
    4454:	2001      	movs	r0, #1
    4456:	4b0d      	ldr	r3, [pc, #52]	; (448c <SDCard_WriteMultipleBlock+0xd0>)
    4458:	4798      	blx	r3
			return 1;
    445a:	2001      	movs	r0, #1
    445c:	e7d3      	b.n	4406 <SDCard_WriteMultipleBlock+0x4a>
	SPI_SD_Send_Byte(0xFD);
    445e:	20fd      	movs	r0, #253	; 0xfd
    4460:	4b0b      	ldr	r3, [pc, #44]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4462:	4798      	blx	r3
	while (SPI_SD_Send_Byte(0xFF) == 0x00)
    4464:	20ff      	movs	r0, #255	; 0xff
    4466:	4b0a      	ldr	r3, [pc, #40]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4468:	4798      	blx	r3
    446a:	2800      	cmp	r0, #0
    446c:	d0fa      	beq.n	4464 <SDCard_WriteMultipleBlock+0xa8>
	SDCard_SS(1);
    446e:	2001      	movs	r0, #1
    4470:	4b06      	ldr	r3, [pc, #24]	; (448c <SDCard_WriteMultipleBlock+0xd0>)
    4472:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    4474:	20ff      	movs	r0, #255	; 0xff
    4476:	4b06      	ldr	r3, [pc, #24]	; (4490 <SDCard_WriteMultipleBlock+0xd4>)
    4478:	4798      	blx	r3
	UART3_Write_Text("Write Multiple Complete\r\n");
    447a:	480a      	ldr	r0, [pc, #40]	; (44a4 <SDCard_WriteMultipleBlock+0xe8>)
    447c:	4b06      	ldr	r3, [pc, #24]	; (4498 <SDCard_WriteMultipleBlock+0xdc>)
    447e:	4798      	blx	r3
	return 0;
    4480:	0038      	movs	r0, r7
    4482:	e7c0      	b.n	4406 <SDCard_WriteMultipleBlock+0x4a>
    4484:	2000045e 	.word	0x2000045e
    4488:	00003e11 	.word	0x00003e11
    448c:	00003d71 	.word	0x00003d71
    4490:	00004691 	.word	0x00004691
    4494:	00005470 	.word	0x00005470
    4498:	00004771 	.word	0x00004771
    449c:	000001ff 	.word	0x000001ff
    44a0:	00005498 	.word	0x00005498
    44a4:	000054b4 	.word	0x000054b4

000044a8 <SPI_Initialize_Fast>:
 * Overview:        This function initializes the SPI bus at 12 MHz baud
 *                  
 * Note:            Needed for SPI initial slow function
 ******************************************************************************/
void SPI_Initialize_Fast(void)
{
    44a8:	b510      	push	{r4, lr}
    // Wait Sync
    while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    44aa:	4b32      	ldr	r3, [pc, #200]	; (4574 <SPI_Initialize_Fast+0xcc>)
    44ac:	69db      	ldr	r3, [r3, #28]
    44ae:	079b      	lsls	r3, r3, #30
    44b0:	d4fb      	bmi.n	44aa <SPI_Initialize_Fast+0x2>

    /* -------------------------------------------------
     * 1) Enable bus clock to APBC mask
     */
    PM->APBCMASK.reg |= PM_APBCMASK_SERCOM4;
    44b2:	4a31      	ldr	r2, [pc, #196]	; (4578 <SPI_Initialize_Fast+0xd0>)
    44b4:	6a13      	ldr	r3, [r2, #32]
    44b6:	2140      	movs	r1, #64	; 0x40
    44b8:	430b      	orrs	r3, r1
    44ba:	6213      	str	r3, [r2, #32]

    /* -------------------------------------------------
     * 2) select SPI clock
     */
    GCLK->CLKCTRL.reg = 
    44bc:	4a2f      	ldr	r2, [pc, #188]	; (457c <SPI_Initialize_Fast+0xd4>)
    44be:	4b30      	ldr	r3, [pc, #192]	; (4580 <SPI_Initialize_Fast+0xd8>)
    44c0:	805a      	strh	r2, [r3, #2]
        GCLK_CLKCTRL_ID(SERCOM4_GCLK_ID_CORE) |
        GCLK_CLKCTRL_CLKEN |
        GCLK_CLKCTRL_GEN(0);

    while(GCLK->STATUS.bit.SYNCBUSY);
    44c2:	4b2f      	ldr	r3, [pc, #188]	; (4580 <SPI_Initialize_Fast+0xd8>)
    44c4:	785b      	ldrb	r3, [r3, #1]
    44c6:	09db      	lsrs	r3, r3, #7
    44c8:	d1fb      	bne.n	44c2 <SPI_Initialize_Fast+0x1a>

    /* -------------------------------------------------
     * 3) setup pins
     */
    // Assign SS, MOSI, SCK as OUTPUT and MISO as INPUT
    PORT->Group[0].DIRSET.reg = PORT_PA13 | PORT_PA10 | PORT_PA11;  // Set SS, MOSI, SCK as output
    44ca:	4b2e      	ldr	r3, [pc, #184]	; (4584 <SPI_Initialize_Fast+0xdc>)
    44cc:	22b0      	movs	r2, #176	; 0xb0
    44ce:	0192      	lsls	r2, r2, #6
    44d0:	609a      	str	r2, [r3, #8]
    PORT->Group[0].DIRCLR.reg = PORT_PA12;  // Set MISO as input
    44d2:	2280      	movs	r2, #128	; 0x80
    44d4:	0152      	lsls	r2, r2, #5
    44d6:	605a      	str	r2, [r3, #4]

    // Set SS OFF
    PORT->Group[0].OUTSET.reg = PORT_PA13;
    44d8:	2280      	movs	r2, #128	; 0x80
    44da:	0192      	lsls	r2, r2, #6
    44dc:	619a      	str	r2, [r3, #24]

    // Set the PMUX for PA10 (MOSI), PA11 (SCK), PA12 (MISO), PA13 (SS)
    PORT->Group[0].PINCFG[10].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA10 (MOSI)
    44de:	224a      	movs	r2, #74	; 0x4a
    44e0:	5c99      	ldrb	r1, [r3, r2]
    44e2:	2001      	movs	r0, #1
    44e4:	4301      	orrs	r1, r0
    44e6:	b2c9      	uxtb	r1, r1
    44e8:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[11].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA11 (SCK)
    44ea:	3201      	adds	r2, #1
    44ec:	5c99      	ldrb	r1, [r3, r2]
    44ee:	4301      	orrs	r1, r0
    44f0:	b2c9      	uxtb	r1, r1
    44f2:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[12].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA12 (MISO)
    44f4:	3201      	adds	r2, #1
    44f6:	5c99      	ldrb	r1, [r3, r2]
    44f8:	4301      	orrs	r1, r0
    44fa:	b2c9      	uxtb	r1, r1
    44fc:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[13].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA13 (SS)
    44fe:	214d      	movs	r1, #77	; 0x4d
    4500:	5c5a      	ldrb	r2, [r3, r1]
    4502:	4302      	orrs	r2, r0
    4504:	b2d2      	uxtb	r2, r2
    4506:	545a      	strb	r2, [r3, r1]

    // Set the PMUX value for pins (each pair shares a PMUX register)
    PORT->Group[0].PMUX[5].reg = PORT_PMUX_PMUXO_C | PORT_PMUX_PMUXE_C; // PA10 (MOSI) and PA11 (SCK) to SERCOM4
    4508:	392b      	subs	r1, #43	; 0x2b
    450a:	2235      	movs	r2, #53	; 0x35
    450c:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PMUX[6].reg = PORT_PMUX_PMUXE_C;                     // PA12 (MISO) to SERCOM4
    450e:	3114      	adds	r1, #20
    4510:	2002      	movs	r0, #2
    4512:	5458      	strb	r0, [r3, r1]
    PORT->Group[0].PMUX[6].reg |= PORT_PMUX_PMUXO_C;                    // PA13 (SS) to SERCOM4
    4514:	5c5a      	ldrb	r2, [r3, r1]
    4516:	2420      	movs	r4, #32
    4518:	4322      	orrs	r2, r4
    451a:	b2d2      	uxtb	r2, r2
    451c:	545a      	strb	r2, [r3, r1]

    /* -------------------------------------------------
     * 4) Configure SPI Module
     */
    // Disable the SERCOM SPI module
    SERCOM4->SPI.CTRLA.bit.ENABLE = 0;
    451e:	4b15      	ldr	r3, [pc, #84]	; (4574 <SPI_Initialize_Fast+0xcc>)
    4520:	6819      	ldr	r1, [r3, #0]
    4522:	000a      	movs	r2, r1
    4524:	4382      	bics	r2, r0
    4526:	601a      	str	r2, [r3, #0]

    // Wait for synchronization
    while(SERCOM4->SPI.SYNCBUSY.bit.SWRST)
    4528:	4b12      	ldr	r3, [pc, #72]	; (4574 <SPI_Initialize_Fast+0xcc>)
    452a:	69db      	ldr	r3, [r3, #28]
    452c:	07db      	lsls	r3, r3, #31
    452e:	d4fb      	bmi.n	4528 <SPI_Initialize_Fast+0x80>
    {
    }

    // Perform a software reset
    SERCOM4->SPI.CTRLA.bit.SWRST = 1;
    4530:	4a10      	ldr	r2, [pc, #64]	; (4574 <SPI_Initialize_Fast+0xcc>)
    4532:	6811      	ldr	r1, [r2, #0]
    4534:	2301      	movs	r3, #1
    4536:	430b      	orrs	r3, r1
    4538:	6013      	str	r3, [r2, #0]

    // Wait for synchronization
    while(SERCOM4->SPI.CTRLA.bit.SWRST)
    453a:	4b0e      	ldr	r3, [pc, #56]	; (4574 <SPI_Initialize_Fast+0xcc>)
    453c:	681b      	ldr	r3, [r3, #0]
    453e:	07db      	lsls	r3, r3, #31
    4540:	d4fb      	bmi.n	453a <SPI_Initialize_Fast+0x92>
    {
    }

    // Wait for synchronization
    while(SERCOM4->SPI.SYNCBUSY.bit.SWRST || SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    4542:	4b0c      	ldr	r3, [pc, #48]	; (4574 <SPI_Initialize_Fast+0xcc>)
    4544:	69db      	ldr	r3, [r3, #28]
    4546:	07db      	lsls	r3, r3, #31
    4548:	d4fb      	bmi.n	4542 <SPI_Initialize_Fast+0x9a>
    454a:	4b0a      	ldr	r3, [pc, #40]	; (4574 <SPI_Initialize_Fast+0xcc>)
    454c:	69db      	ldr	r3, [r3, #28]
    454e:	079b      	lsls	r3, r3, #30
    4550:	d4f7      	bmi.n	4542 <SPI_Initialize_Fast+0x9a>

    SERCOM4->SPI.CTRLA.reg = 
    4552:	4b08      	ldr	r3, [pc, #32]	; (4574 <SPI_Initialize_Fast+0xcc>)
    4554:	4a0c      	ldr	r2, [pc, #48]	; (4588 <SPI_Initialize_Fast+0xe0>)
    4556:	601a      	str	r2, [r3, #0]
        SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
        SERCOM_SPI_CTRLA_DIPO(0) |           // PAD0 is used as data input (MISO)
        SERCOM_SPI_CTRLA_DOPO(1);            // PAD2 is used as data output (MOSI), PAD3 is SCK

    SERCOM4->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    4558:	2280      	movs	r2, #128	; 0x80
    455a:	0292      	lsls	r2, r2, #10
    455c:	605a      	str	r2, [r3, #4]

    /* -------------------------------------------------
     * 5) Set the baud rate
     */
    uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 12000000)) - 1; // Calculate BAUD value
    SERCOM4->SPI.BAUD.reg = SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    455e:	2201      	movs	r2, #1
    4560:	731a      	strb	r2, [r3, #12]

    /* -------------------------------------------------
     * 6) Enable SPI Module
     */
    // Enable SPI receive
    SERCOM4->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE; // Enable the SPI
    4562:	681a      	ldr	r2, [r3, #0]
    4564:	2102      	movs	r1, #2
    4566:	430a      	orrs	r2, r1
    4568:	601a      	str	r2, [r3, #0]
    while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    456a:	4b02      	ldr	r3, [pc, #8]	; (4574 <SPI_Initialize_Fast+0xcc>)
    456c:	69db      	ldr	r3, [r3, #28]
    456e:	079b      	lsls	r3, r3, #30
    4570:	d4fb      	bmi.n	456a <SPI_Initialize_Fast+0xc2>
}
    4572:	bd10      	pop	{r4, pc}
    4574:	42001800 	.word	0x42001800
    4578:	40000400 	.word	0x40000400
    457c:	00004018 	.word	0x00004018
    4580:	40000c00 	.word	0x40000c00
    4584:	41004400 	.word	0x41004400
    4588:	0001000c 	.word	0x0001000c

0000458c <SPI_Initialize_Slow>:
 * Side Effects:    None
 *
 * Overview:        This function initializes the SPI bus at 400 kHz baud
 ******************************************************************************/
void SPI_Initialize_Slow(void)
{
    458c:	b510      	push	{r4, lr}
    // Wait Sync
    while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    458e:	4b32      	ldr	r3, [pc, #200]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4590:	69db      	ldr	r3, [r3, #28]
    4592:	079b      	lsls	r3, r3, #30
    4594:	d4fb      	bmi.n	458e <SPI_Initialize_Slow+0x2>

    /* -------------------------------------------------
     * 1) Enable bus clock to APBC mask
     */
    PM->APBCMASK.reg |= PM_APBCMASK_SERCOM4;
    4596:	4a31      	ldr	r2, [pc, #196]	; (465c <SPI_Initialize_Slow+0xd0>)
    4598:	6a13      	ldr	r3, [r2, #32]
    459a:	2140      	movs	r1, #64	; 0x40
    459c:	430b      	orrs	r3, r1
    459e:	6213      	str	r3, [r2, #32]

    /* -------------------------------------------------
     * 2) select SPI clock
     */
    GCLK->CLKCTRL.reg = 
    45a0:	4a2f      	ldr	r2, [pc, #188]	; (4660 <SPI_Initialize_Slow+0xd4>)
    45a2:	4b30      	ldr	r3, [pc, #192]	; (4664 <SPI_Initialize_Slow+0xd8>)
    45a4:	805a      	strh	r2, [r3, #2]
        GCLK_CLKCTRL_ID(SERCOM4_GCLK_ID_CORE) |
        GCLK_CLKCTRL_CLKEN |
        GCLK_CLKCTRL_GEN(0);

    while(GCLK->STATUS.bit.SYNCBUSY);
    45a6:	4b2f      	ldr	r3, [pc, #188]	; (4664 <SPI_Initialize_Slow+0xd8>)
    45a8:	785b      	ldrb	r3, [r3, #1]
    45aa:	09db      	lsrs	r3, r3, #7
    45ac:	d1fb      	bne.n	45a6 <SPI_Initialize_Slow+0x1a>

    /* -------------------------------------------------
     * 3) setup pins
     */
    // Assign SS, MOSI, SCK as OUTPUT and MISO as INPUT
    PORT->Group[0].DIRSET.reg = PORT_PA13 | PORT_PA10 | PORT_PA11;  // Set SS, MOSI, SCK as output
    45ae:	4b2e      	ldr	r3, [pc, #184]	; (4668 <SPI_Initialize_Slow+0xdc>)
    45b0:	22b0      	movs	r2, #176	; 0xb0
    45b2:	0192      	lsls	r2, r2, #6
    45b4:	609a      	str	r2, [r3, #8]
    PORT->Group[0].DIRCLR.reg = PORT_PA12;  // Set MISO as input
    45b6:	2280      	movs	r2, #128	; 0x80
    45b8:	0152      	lsls	r2, r2, #5
    45ba:	605a      	str	r2, [r3, #4]

    // Set SS OFF
    PORT->Group[0].OUTSET.reg = PORT_PA13;
    45bc:	2280      	movs	r2, #128	; 0x80
    45be:	0192      	lsls	r2, r2, #6
    45c0:	619a      	str	r2, [r3, #24]

    // Set the PMUX for PA10 (MOSI), PA11 (SCK), PA12 (MISO), PA13 (SS)
    PORT->Group[0].PINCFG[10].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA10 (MOSI)
    45c2:	224a      	movs	r2, #74	; 0x4a
    45c4:	5c99      	ldrb	r1, [r3, r2]
    45c6:	2001      	movs	r0, #1
    45c8:	4301      	orrs	r1, r0
    45ca:	b2c9      	uxtb	r1, r1
    45cc:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[11].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA11 (SCK)
    45ce:	3201      	adds	r2, #1
    45d0:	5c99      	ldrb	r1, [r3, r2]
    45d2:	4301      	orrs	r1, r0
    45d4:	b2c9      	uxtb	r1, r1
    45d6:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[12].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA12 (MISO)
    45d8:	3201      	adds	r2, #1
    45da:	5c99      	ldrb	r1, [r3, r2]
    45dc:	4301      	orrs	r1, r0
    45de:	b2c9      	uxtb	r1, r1
    45e0:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PINCFG[13].reg |= PORT_PINCFG_PMUXEN;  // Enable PMUX for PA13 (SS)
    45e2:	214d      	movs	r1, #77	; 0x4d
    45e4:	5c5a      	ldrb	r2, [r3, r1]
    45e6:	4302      	orrs	r2, r0
    45e8:	b2d2      	uxtb	r2, r2
    45ea:	545a      	strb	r2, [r3, r1]

    // Set the PMUX value for pins (each pair shares a PMUX register)
    PORT->Group[0].PMUX[5].reg = PORT_PMUX_PMUXO_C | PORT_PMUX_PMUXE_C; // PA10 (MOSI) and PA11 (SCK) to SERCOM4
    45ec:	392b      	subs	r1, #43	; 0x2b
    45ee:	2235      	movs	r2, #53	; 0x35
    45f0:	5499      	strb	r1, [r3, r2]
    PORT->Group[0].PMUX[6].reg = PORT_PMUX_PMUXE_C;                     // PA12 (MISO) to SERCOM4
    45f2:	3114      	adds	r1, #20
    45f4:	2002      	movs	r0, #2
    45f6:	5458      	strb	r0, [r3, r1]
    PORT->Group[0].PMUX[6].reg |= PORT_PMUX_PMUXO_C;                    // PA13 (SS) to SERCOM4
    45f8:	5c5a      	ldrb	r2, [r3, r1]
    45fa:	2420      	movs	r4, #32
    45fc:	4322      	orrs	r2, r4
    45fe:	b2d2      	uxtb	r2, r2
    4600:	545a      	strb	r2, [r3, r1]

    /* -------------------------------------------------
     * 4) Configure SPI Module
     */
    // Disable the SERCOM SPI module
    SERCOM4->SPI.CTRLA.bit.ENABLE = 0;
    4602:	4b15      	ldr	r3, [pc, #84]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4604:	6819      	ldr	r1, [r3, #0]
    4606:	000a      	movs	r2, r1
    4608:	4382      	bics	r2, r0
    460a:	601a      	str	r2, [r3, #0]

    // Wait for synchronization
    while(SERCOM4->SPI.SYNCBUSY.bit.SWRST)
    460c:	4b12      	ldr	r3, [pc, #72]	; (4658 <SPI_Initialize_Slow+0xcc>)
    460e:	69db      	ldr	r3, [r3, #28]
    4610:	07db      	lsls	r3, r3, #31
    4612:	d4fb      	bmi.n	460c <SPI_Initialize_Slow+0x80>
    {
    }

    // Perform a software reset
    SERCOM4->SPI.CTRLA.bit.SWRST = 1;
    4614:	4a10      	ldr	r2, [pc, #64]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4616:	6811      	ldr	r1, [r2, #0]
    4618:	2301      	movs	r3, #1
    461a:	430b      	orrs	r3, r1
    461c:	6013      	str	r3, [r2, #0]

    // Wait for synchronization
    while(SERCOM4->SPI.CTRLA.bit.SWRST)
    461e:	4b0e      	ldr	r3, [pc, #56]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4620:	681b      	ldr	r3, [r3, #0]
    4622:	07db      	lsls	r3, r3, #31
    4624:	d4fb      	bmi.n	461e <SPI_Initialize_Slow+0x92>
    {
    }

    // Wait for synchronization
    while(SERCOM4->SPI.SYNCBUSY.bit.SWRST || SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    4626:	4b0c      	ldr	r3, [pc, #48]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4628:	69db      	ldr	r3, [r3, #28]
    462a:	07db      	lsls	r3, r3, #31
    462c:	d4fb      	bmi.n	4626 <SPI_Initialize_Slow+0x9a>
    462e:	4b0a      	ldr	r3, [pc, #40]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4630:	69db      	ldr	r3, [r3, #28]
    4632:	079b      	lsls	r3, r3, #30
    4634:	d4f7      	bmi.n	4626 <SPI_Initialize_Slow+0x9a>

    SERCOM4->SPI.CTRLA.reg = 
    4636:	4b08      	ldr	r3, [pc, #32]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4638:	4a0c      	ldr	r2, [pc, #48]	; (466c <SPI_Initialize_Slow+0xe0>)
    463a:	601a      	str	r2, [r3, #0]
        SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
        SERCOM_SPI_CTRLA_DIPO(0) |           // PAD0 is used as data input (MISO)
        SERCOM_SPI_CTRLA_DOPO(1);            // PAD2 is used as data output (MOSI), PAD3 is SCK

    SERCOM4->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    463c:	2280      	movs	r2, #128	; 0x80
    463e:	0292      	lsls	r2, r2, #10
    4640:	605a      	str	r2, [r3, #4]

    /* -------------------------------------------------
     * 5) Set the baud rate
     */
    uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 400000)) - 1; // Calculate BAUD value
    SERCOM4->SPI.BAUD.reg = SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    4642:	223b      	movs	r2, #59	; 0x3b
    4644:	731a      	strb	r2, [r3, #12]

    /* -------------------------------------------------
     * 6) Enable SPI Module
     */
    // Enable SPI receive
    SERCOM4->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE; // Enable the SPI
    4646:	681a      	ldr	r2, [r3, #0]
    4648:	2102      	movs	r1, #2
    464a:	430a      	orrs	r2, r1
    464c:	601a      	str	r2, [r3, #0]
    while(SERCOM4->SPI.SYNCBUSY.bit.ENABLE);
    464e:	4b02      	ldr	r3, [pc, #8]	; (4658 <SPI_Initialize_Slow+0xcc>)
    4650:	69db      	ldr	r3, [r3, #28]
    4652:	079b      	lsls	r3, r3, #30
    4654:	d4fb      	bmi.n	464e <SPI_Initialize_Slow+0xc2>
}
    4656:	bd10      	pop	{r4, pc}
    4658:	42001800 	.word	0x42001800
    465c:	40000400 	.word	0x40000400
    4660:	00004018 	.word	0x00004018
    4664:	40000c00 	.word	0x40000c00
    4668:	41004400 	.word	0x41004400
    466c:	0001000c 	.word	0x0001000c

00004670 <SPI_Exchange8bit>:
 *
 * Overview:        This function exchanges a byte of data on the SPI Bus
 ******************************************************************************/
uint8_t SPI_Exchange8bit(uint8_t data)
{
    while(SERCOM4->SPI.INTFLAG.bit.DRE == 0);
    4670:	4b06      	ldr	r3, [pc, #24]	; (468c <SPI_Exchange8bit+0x1c>)
    4672:	7e1b      	ldrb	r3, [r3, #24]
    4674:	07db      	lsls	r3, r3, #31
    4676:	d5fb      	bpl.n	4670 <SPI_Exchange8bit>
    SERCOM4->SPI.DATA.reg = data;
    4678:	4b04      	ldr	r3, [pc, #16]	; (468c <SPI_Exchange8bit+0x1c>)
    467a:	6298      	str	r0, [r3, #40]	; 0x28

    while(SERCOM4->SPI.INTFLAG.bit.RXC == 0);
    467c:	4b03      	ldr	r3, [pc, #12]	; (468c <SPI_Exchange8bit+0x1c>)
    467e:	7e1b      	ldrb	r3, [r3, #24]
    4680:	075b      	lsls	r3, r3, #29
    4682:	d5fb      	bpl.n	467c <SPI_Exchange8bit+0xc>
    return (uint8_t)SERCOM4->SPI.DATA.reg;
    4684:	4b01      	ldr	r3, [pc, #4]	; (468c <SPI_Exchange8bit+0x1c>)
    4686:	6a98      	ldr	r0, [r3, #40]	; 0x28
    4688:	b2c0      	uxtb	r0, r0
}
    468a:	4770      	bx	lr
    468c:	42001800 	.word	0x42001800

00004690 <SPI_SD_Send_Byte>:
 * Side Effects:    None
 *
 * Overview:        This function sends a byte of data to the SD Card
 ******************************************************************************/
uint8_t SPI_SD_Send_Byte(uint8_t byte_val)
{
    4690:	b510      	push	{r4, lr}
    uint8_t data;

    data = SPI_Exchange8bit(byte_val);
    4692:	4b01      	ldr	r3, [pc, #4]	; (4698 <SPI_SD_Send_Byte+0x8>)
    4694:	4798      	blx	r3
    return data;
}
    4696:	bd10      	pop	{r4, pc}
    4698:	00004671 	.word	0x00004671

0000469c <SPI_SD_Read_Byte>:
 * Side Effects:    None
 *
 * Overview:        This function reads a byte of data from the SPI Module
 ******************************************************************************/
uint8_t SPI_SD_Read_Byte(void)
{
    469c:	b510      	push	{r4, lr}
    uint8_t data;

    data = SPI_Exchange8bit(0xff);
    469e:	20ff      	movs	r0, #255	; 0xff
    46a0:	4b01      	ldr	r3, [pc, #4]	; (46a8 <SPI_SD_Read_Byte+0xc>)
    46a2:	4798      	blx	r3
    return data;
}
    46a4:	bd10      	pop	{r4, pc}
    46a6:	46c0      	nop			; (mov r8, r8)
    46a8:	00004671 	.word	0x00004671

000046ac <UART3_Init>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Init(uint32_t baud)
{
    46ac:	b570      	push	{r4, r5, r6, lr}
	
	/* -------------------------------------------------
	* 1) Enable bus clock to APBC mask
	*/
	REG_PM_APBCMASK |=  PM_APBCMASK_SERCOM3;
    46ae:	4a22      	ldr	r2, [pc, #136]	; (4738 <UART3_Init+0x8c>)
    46b0:	6813      	ldr	r3, [r2, #0]
    46b2:	2120      	movs	r1, #32
    46b4:	430b      	orrs	r3, r1
    46b6:	6013      	str	r3, [r2, #0]
	
    /* -------------------------------------------------
	* 2) select UART clock
	*/
	GCLK->CLKCTRL.reg =  
    46b8:	4a20      	ldr	r2, [pc, #128]	; (473c <UART3_Init+0x90>)
    46ba:	4b21      	ldr	r3, [pc, #132]	; (4740 <UART3_Init+0x94>)
    46bc:	805a      	strh	r2, [r3, #2]
	
	/* --------------------------------------------------
	* 3) Configure PA22 as TX Pin
	*/
	// Set pin direction to output
	PORT->Group[0].DIRSET.reg = (1 << 22);     
    46be:	4b21      	ldr	r3, [pc, #132]	; (4744 <UART3_Init+0x98>)
    46c0:	2280      	movs	r2, #128	; 0x80
    46c2:	03d2      	lsls	r2, r2, #15
    46c4:	609a      	str	r2, [r3, #8]
	
    // Enable PMUX
	PORT->Group[0].PINCFG[22].reg |= PORT_PINCFG_PMUXEN;   
    46c6:	2256      	movs	r2, #86	; 0x56
    46c8:	5c99      	ldrb	r1, [r3, r2]
    46ca:	2601      	movs	r6, #1
    46cc:	4331      	orrs	r1, r6
    46ce:	b2c9      	uxtb	r1, r1
    46d0:	5499      	strb	r1, [r3, r2]
	
	// Enable PMUX and set the PMUX bit, since pin is even we use PMUXE
	PORT->Group[0].PMUX[22>>1].bit.PMUXE = PORT_PMUX_PMUXE_C_Val;
    46d2:	243b      	movs	r4, #59	; 0x3b
    46d4:	5d19      	ldrb	r1, [r3, r4]
    46d6:	3a47      	subs	r2, #71	; 0x47
    46d8:	4391      	bics	r1, r2
    46da:	2202      	movs	r2, #2
    46dc:	4311      	orrs	r1, r2
    46de:	5519      	strb	r1, [r3, r4]
	
	/* ---------------------------------------------------
	* 4) Configure PA23 as RX Pin
	*/
	// Set pin direction to input
	PORT->Group[0].DIRCLR.reg = (1 << 23);       
    46e0:	2280      	movs	r2, #128	; 0x80
    46e2:	0412      	lsls	r2, r2, #16
    46e4:	605a      	str	r2, [r3, #4]

	// Enable pull down resistor
	PORT->Group[0].PINCFG[23].reg &= ~PORT_PINCFG_PULLEN;   
    46e6:	2157      	movs	r1, #87	; 0x57
    46e8:	5c5d      	ldrb	r5, [r3, r1]
    46ea:	2204      	movs	r2, #4
    46ec:	4395      	bics	r5, r2
    46ee:	545d      	strb	r5, [r3, r1]
	
	// Enable PMUX and set the PMUX bit, since pin is odd we use PMUX0
	PORT->Group[0].PINCFG[23].reg |= PORT_PINCFG_PMUXEN; 
    46f0:	5c5a      	ldrb	r2, [r3, r1]
    46f2:	4332      	orrs	r2, r6
    46f4:	b2d2      	uxtb	r2, r2
    46f6:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PMUX[23>>1].bit.PMUXO = PORT_PMUX_PMUXO_C_Val; 
    46f8:	5d19      	ldrb	r1, [r3, r4]
    46fa:	220f      	movs	r2, #15
    46fc:	400a      	ands	r2, r1
    46fe:	2120      	movs	r1, #32
    4700:	430a      	orrs	r2, r1
    4702:	551a      	strb	r2, [r3, r4]
	
	
	/* ----------------------------------------------------
	* 5) Configure USART via Control A and Control B 
	*/
	SERCOM3->USART.CTRLA.reg =                  // USART is ASYNCHRONOUS
    4704:	4c10      	ldr	r4, [pc, #64]	; (4748 <UART3_Init+0x9c>)
    4706:	4b11      	ldr	r3, [pc, #68]	; (474c <UART3_Init+0xa0>)
    4708:	6023      	str	r3, [r4, #0]
	   SERCOM_USART_CTRLA_MODE_USART_INT_CLK |  // Set Internal Clock 
	   SERCOM_USART_CTRLA_RXPO(1) |             // Use SERCOM pad 1 for data reception
	   SERCOM_USART_CTRLA_TXPO(0/*PAD0*/);      // Set SERCOM pad 0 for data transmission
	
	
	SERCOM3->USART.CTRLB.reg =        // We don't use PARITY
    470a:	23c0      	movs	r3, #192	; 0xc0
    470c:	029b      	lsls	r3, r3, #10
    470e:	6063      	str	r3, [r4, #4]
	
	/* -----------------------------------------------------
	* 6) Set USART Baud Rate
	*/
	// Baud rate is (65536) * (CPU_CLock - 16 * wanted baud) / CPU_Clock
	uint64_t baudRate = (uint64_t)65536 * (F_CPU - 16 * baud) / F_CPU;
    4710:	0703      	lsls	r3, r0, #28
    4712:	1a1b      	subs	r3, r3, r0
    4714:	0118      	lsls	r0, r3, #4
    4716:	4b0e      	ldr	r3, [pc, #56]	; (4750 <UART3_Init+0xa4>)
    4718:	469c      	mov	ip, r3
    471a:	4460      	add	r0, ip
    471c:	0c01      	lsrs	r1, r0, #16
    471e:	0400      	lsls	r0, r0, #16
    4720:	4a0b      	ldr	r2, [pc, #44]	; (4750 <UART3_Init+0xa4>)
    4722:	2300      	movs	r3, #0
    4724:	4d0b      	ldr	r5, [pc, #44]	; (4754 <UART3_Init+0xa8>)
    4726:	47a8      	blx	r5
	
	// Set Baud Rate
	SERCOM3->USART.BAUD.reg = (uint32_t)baudRate;
    4728:	b280      	uxth	r0, r0
    472a:	81a0      	strh	r0, [r4, #12]

    /* ------------------------------------------------------
	* 7) Enable the USART
	*/
	// SERCOM3 peripheral enabled
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    472c:	6823      	ldr	r3, [r4, #0]
    472e:	2202      	movs	r2, #2
    4730:	4313      	orrs	r3, r2
    4732:	6023      	str	r3, [r4, #0]
}  // UART3_Init()
    4734:	bd70      	pop	{r4, r5, r6, pc}
    4736:	46c0      	nop			; (mov r8, r8)
    4738:	40000420 	.word	0x40000420
    473c:	00004017 	.word	0x00004017
    4740:	40000c00 	.word	0x40000c00
    4744:	41004400 	.word	0x41004400
    4748:	42001400 	.word	0x42001400
    474c:	40100004 	.word	0x40100004
    4750:	02dc6c00 	.word	0x02dc6c00
    4754:	00004a79 	.word	0x00004a79

00004758 <UART3_Write>:
 *
 ******************************************************************************/
void UART3_Write(char data)
{
	// Wait on interrupt flag and Write some data
	while(!(REG_SERCOM3_USART_INTFLAG) & 1)
    4758:	4b03      	ldr	r3, [pc, #12]	; (4768 <UART3_Write+0x10>)
    475a:	781b      	ldrb	r3, [r3, #0]
    475c:	2b00      	cmp	r3, #0
    475e:	d0fb      	beq.n	4758 <UART3_Write>
	{
		
	}
	
	REG_SERCOM3_USART_DATA = data;
    4760:	b280      	uxth	r0, r0
    4762:	4b02      	ldr	r3, [pc, #8]	; (476c <UART3_Write+0x14>)
    4764:	8018      	strh	r0, [r3, #0]
} //UART3_Write()
    4766:	4770      	bx	lr
    4768:	42001418 	.word	0x42001418
    476c:	42001428 	.word	0x42001428

00004770 <UART3_Write_Text>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Write_Text(char *text)
{
    4770:	b570      	push	{r4, r5, r6, lr}
    4772:	0005      	movs	r5, r0
	// we write text until we reach EOL
	for(int i=0;text[i]!='\0';i++)
    4774:	2400      	movs	r4, #0
    4776:	e002      	b.n	477e <UART3_Write_Text+0xe>
	{
		UART3_Write(text[i]);
    4778:	4b03      	ldr	r3, [pc, #12]	; (4788 <UART3_Write_Text+0x18>)
    477a:	4798      	blx	r3
	for(int i=0;text[i]!='\0';i++)
    477c:	3401      	adds	r4, #1
    477e:	5d28      	ldrb	r0, [r5, r4]
    4780:	2800      	cmp	r0, #0
    4782:	d1f9      	bne.n	4778 <UART3_Write_Text+0x8>
	}
	
} // UART3_Write_Text()
    4784:	bd70      	pop	{r4, r5, r6, pc}
    4786:	46c0      	nop			; (mov r8, r8)
    4788:	00004759 	.word	0x00004759

0000478c <__udivsi3>:
    478c:	2200      	movs	r2, #0
    478e:	0843      	lsrs	r3, r0, #1
    4790:	428b      	cmp	r3, r1
    4792:	d374      	bcc.n	487e <__udivsi3+0xf2>
    4794:	0903      	lsrs	r3, r0, #4
    4796:	428b      	cmp	r3, r1
    4798:	d35f      	bcc.n	485a <__udivsi3+0xce>
    479a:	0a03      	lsrs	r3, r0, #8
    479c:	428b      	cmp	r3, r1
    479e:	d344      	bcc.n	482a <__udivsi3+0x9e>
    47a0:	0b03      	lsrs	r3, r0, #12
    47a2:	428b      	cmp	r3, r1
    47a4:	d328      	bcc.n	47f8 <__udivsi3+0x6c>
    47a6:	0c03      	lsrs	r3, r0, #16
    47a8:	428b      	cmp	r3, r1
    47aa:	d30d      	bcc.n	47c8 <__udivsi3+0x3c>
    47ac:	22ff      	movs	r2, #255	; 0xff
    47ae:	0209      	lsls	r1, r1, #8
    47b0:	ba12      	rev	r2, r2
    47b2:	0c03      	lsrs	r3, r0, #16
    47b4:	428b      	cmp	r3, r1
    47b6:	d302      	bcc.n	47be <__udivsi3+0x32>
    47b8:	1212      	asrs	r2, r2, #8
    47ba:	0209      	lsls	r1, r1, #8
    47bc:	d065      	beq.n	488a <__udivsi3+0xfe>
    47be:	0b03      	lsrs	r3, r0, #12
    47c0:	428b      	cmp	r3, r1
    47c2:	d319      	bcc.n	47f8 <__udivsi3+0x6c>
    47c4:	e000      	b.n	47c8 <__udivsi3+0x3c>
    47c6:	0a09      	lsrs	r1, r1, #8
    47c8:	0bc3      	lsrs	r3, r0, #15
    47ca:	428b      	cmp	r3, r1
    47cc:	d301      	bcc.n	47d2 <__udivsi3+0x46>
    47ce:	03cb      	lsls	r3, r1, #15
    47d0:	1ac0      	subs	r0, r0, r3
    47d2:	4152      	adcs	r2, r2
    47d4:	0b83      	lsrs	r3, r0, #14
    47d6:	428b      	cmp	r3, r1
    47d8:	d301      	bcc.n	47de <__udivsi3+0x52>
    47da:	038b      	lsls	r3, r1, #14
    47dc:	1ac0      	subs	r0, r0, r3
    47de:	4152      	adcs	r2, r2
    47e0:	0b43      	lsrs	r3, r0, #13
    47e2:	428b      	cmp	r3, r1
    47e4:	d301      	bcc.n	47ea <__udivsi3+0x5e>
    47e6:	034b      	lsls	r3, r1, #13
    47e8:	1ac0      	subs	r0, r0, r3
    47ea:	4152      	adcs	r2, r2
    47ec:	0b03      	lsrs	r3, r0, #12
    47ee:	428b      	cmp	r3, r1
    47f0:	d301      	bcc.n	47f6 <__udivsi3+0x6a>
    47f2:	030b      	lsls	r3, r1, #12
    47f4:	1ac0      	subs	r0, r0, r3
    47f6:	4152      	adcs	r2, r2
    47f8:	0ac3      	lsrs	r3, r0, #11
    47fa:	428b      	cmp	r3, r1
    47fc:	d301      	bcc.n	4802 <__udivsi3+0x76>
    47fe:	02cb      	lsls	r3, r1, #11
    4800:	1ac0      	subs	r0, r0, r3
    4802:	4152      	adcs	r2, r2
    4804:	0a83      	lsrs	r3, r0, #10
    4806:	428b      	cmp	r3, r1
    4808:	d301      	bcc.n	480e <__udivsi3+0x82>
    480a:	028b      	lsls	r3, r1, #10
    480c:	1ac0      	subs	r0, r0, r3
    480e:	4152      	adcs	r2, r2
    4810:	0a43      	lsrs	r3, r0, #9
    4812:	428b      	cmp	r3, r1
    4814:	d301      	bcc.n	481a <__udivsi3+0x8e>
    4816:	024b      	lsls	r3, r1, #9
    4818:	1ac0      	subs	r0, r0, r3
    481a:	4152      	adcs	r2, r2
    481c:	0a03      	lsrs	r3, r0, #8
    481e:	428b      	cmp	r3, r1
    4820:	d301      	bcc.n	4826 <__udivsi3+0x9a>
    4822:	020b      	lsls	r3, r1, #8
    4824:	1ac0      	subs	r0, r0, r3
    4826:	4152      	adcs	r2, r2
    4828:	d2cd      	bcs.n	47c6 <__udivsi3+0x3a>
    482a:	09c3      	lsrs	r3, r0, #7
    482c:	428b      	cmp	r3, r1
    482e:	d301      	bcc.n	4834 <__udivsi3+0xa8>
    4830:	01cb      	lsls	r3, r1, #7
    4832:	1ac0      	subs	r0, r0, r3
    4834:	4152      	adcs	r2, r2
    4836:	0983      	lsrs	r3, r0, #6
    4838:	428b      	cmp	r3, r1
    483a:	d301      	bcc.n	4840 <__udivsi3+0xb4>
    483c:	018b      	lsls	r3, r1, #6
    483e:	1ac0      	subs	r0, r0, r3
    4840:	4152      	adcs	r2, r2
    4842:	0943      	lsrs	r3, r0, #5
    4844:	428b      	cmp	r3, r1
    4846:	d301      	bcc.n	484c <__udivsi3+0xc0>
    4848:	014b      	lsls	r3, r1, #5
    484a:	1ac0      	subs	r0, r0, r3
    484c:	4152      	adcs	r2, r2
    484e:	0903      	lsrs	r3, r0, #4
    4850:	428b      	cmp	r3, r1
    4852:	d301      	bcc.n	4858 <__udivsi3+0xcc>
    4854:	010b      	lsls	r3, r1, #4
    4856:	1ac0      	subs	r0, r0, r3
    4858:	4152      	adcs	r2, r2
    485a:	08c3      	lsrs	r3, r0, #3
    485c:	428b      	cmp	r3, r1
    485e:	d301      	bcc.n	4864 <__udivsi3+0xd8>
    4860:	00cb      	lsls	r3, r1, #3
    4862:	1ac0      	subs	r0, r0, r3
    4864:	4152      	adcs	r2, r2
    4866:	0883      	lsrs	r3, r0, #2
    4868:	428b      	cmp	r3, r1
    486a:	d301      	bcc.n	4870 <__udivsi3+0xe4>
    486c:	008b      	lsls	r3, r1, #2
    486e:	1ac0      	subs	r0, r0, r3
    4870:	4152      	adcs	r2, r2
    4872:	0843      	lsrs	r3, r0, #1
    4874:	428b      	cmp	r3, r1
    4876:	d301      	bcc.n	487c <__udivsi3+0xf0>
    4878:	004b      	lsls	r3, r1, #1
    487a:	1ac0      	subs	r0, r0, r3
    487c:	4152      	adcs	r2, r2
    487e:	1a41      	subs	r1, r0, r1
    4880:	d200      	bcs.n	4884 <__udivsi3+0xf8>
    4882:	4601      	mov	r1, r0
    4884:	4152      	adcs	r2, r2
    4886:	4610      	mov	r0, r2
    4888:	4770      	bx	lr
    488a:	e7ff      	b.n	488c <__udivsi3+0x100>
    488c:	b501      	push	{r0, lr}
    488e:	2000      	movs	r0, #0
    4890:	f000 f8f0 	bl	4a74 <__aeabi_idiv0>
    4894:	bd02      	pop	{r1, pc}
    4896:	46c0      	nop			; (mov r8, r8)

00004898 <__aeabi_uidivmod>:
    4898:	2900      	cmp	r1, #0
    489a:	d0f7      	beq.n	488c <__udivsi3+0x100>
    489c:	e776      	b.n	478c <__udivsi3>
    489e:	4770      	bx	lr

000048a0 <__divsi3>:
    48a0:	4603      	mov	r3, r0
    48a2:	430b      	orrs	r3, r1
    48a4:	d47f      	bmi.n	49a6 <__divsi3+0x106>
    48a6:	2200      	movs	r2, #0
    48a8:	0843      	lsrs	r3, r0, #1
    48aa:	428b      	cmp	r3, r1
    48ac:	d374      	bcc.n	4998 <__divsi3+0xf8>
    48ae:	0903      	lsrs	r3, r0, #4
    48b0:	428b      	cmp	r3, r1
    48b2:	d35f      	bcc.n	4974 <__divsi3+0xd4>
    48b4:	0a03      	lsrs	r3, r0, #8
    48b6:	428b      	cmp	r3, r1
    48b8:	d344      	bcc.n	4944 <__divsi3+0xa4>
    48ba:	0b03      	lsrs	r3, r0, #12
    48bc:	428b      	cmp	r3, r1
    48be:	d328      	bcc.n	4912 <__divsi3+0x72>
    48c0:	0c03      	lsrs	r3, r0, #16
    48c2:	428b      	cmp	r3, r1
    48c4:	d30d      	bcc.n	48e2 <__divsi3+0x42>
    48c6:	22ff      	movs	r2, #255	; 0xff
    48c8:	0209      	lsls	r1, r1, #8
    48ca:	ba12      	rev	r2, r2
    48cc:	0c03      	lsrs	r3, r0, #16
    48ce:	428b      	cmp	r3, r1
    48d0:	d302      	bcc.n	48d8 <__divsi3+0x38>
    48d2:	1212      	asrs	r2, r2, #8
    48d4:	0209      	lsls	r1, r1, #8
    48d6:	d065      	beq.n	49a4 <__divsi3+0x104>
    48d8:	0b03      	lsrs	r3, r0, #12
    48da:	428b      	cmp	r3, r1
    48dc:	d319      	bcc.n	4912 <__divsi3+0x72>
    48de:	e000      	b.n	48e2 <__divsi3+0x42>
    48e0:	0a09      	lsrs	r1, r1, #8
    48e2:	0bc3      	lsrs	r3, r0, #15
    48e4:	428b      	cmp	r3, r1
    48e6:	d301      	bcc.n	48ec <__divsi3+0x4c>
    48e8:	03cb      	lsls	r3, r1, #15
    48ea:	1ac0      	subs	r0, r0, r3
    48ec:	4152      	adcs	r2, r2
    48ee:	0b83      	lsrs	r3, r0, #14
    48f0:	428b      	cmp	r3, r1
    48f2:	d301      	bcc.n	48f8 <__divsi3+0x58>
    48f4:	038b      	lsls	r3, r1, #14
    48f6:	1ac0      	subs	r0, r0, r3
    48f8:	4152      	adcs	r2, r2
    48fa:	0b43      	lsrs	r3, r0, #13
    48fc:	428b      	cmp	r3, r1
    48fe:	d301      	bcc.n	4904 <__divsi3+0x64>
    4900:	034b      	lsls	r3, r1, #13
    4902:	1ac0      	subs	r0, r0, r3
    4904:	4152      	adcs	r2, r2
    4906:	0b03      	lsrs	r3, r0, #12
    4908:	428b      	cmp	r3, r1
    490a:	d301      	bcc.n	4910 <__divsi3+0x70>
    490c:	030b      	lsls	r3, r1, #12
    490e:	1ac0      	subs	r0, r0, r3
    4910:	4152      	adcs	r2, r2
    4912:	0ac3      	lsrs	r3, r0, #11
    4914:	428b      	cmp	r3, r1
    4916:	d301      	bcc.n	491c <__divsi3+0x7c>
    4918:	02cb      	lsls	r3, r1, #11
    491a:	1ac0      	subs	r0, r0, r3
    491c:	4152      	adcs	r2, r2
    491e:	0a83      	lsrs	r3, r0, #10
    4920:	428b      	cmp	r3, r1
    4922:	d301      	bcc.n	4928 <__divsi3+0x88>
    4924:	028b      	lsls	r3, r1, #10
    4926:	1ac0      	subs	r0, r0, r3
    4928:	4152      	adcs	r2, r2
    492a:	0a43      	lsrs	r3, r0, #9
    492c:	428b      	cmp	r3, r1
    492e:	d301      	bcc.n	4934 <__divsi3+0x94>
    4930:	024b      	lsls	r3, r1, #9
    4932:	1ac0      	subs	r0, r0, r3
    4934:	4152      	adcs	r2, r2
    4936:	0a03      	lsrs	r3, r0, #8
    4938:	428b      	cmp	r3, r1
    493a:	d301      	bcc.n	4940 <__divsi3+0xa0>
    493c:	020b      	lsls	r3, r1, #8
    493e:	1ac0      	subs	r0, r0, r3
    4940:	4152      	adcs	r2, r2
    4942:	d2cd      	bcs.n	48e0 <__divsi3+0x40>
    4944:	09c3      	lsrs	r3, r0, #7
    4946:	428b      	cmp	r3, r1
    4948:	d301      	bcc.n	494e <__divsi3+0xae>
    494a:	01cb      	lsls	r3, r1, #7
    494c:	1ac0      	subs	r0, r0, r3
    494e:	4152      	adcs	r2, r2
    4950:	0983      	lsrs	r3, r0, #6
    4952:	428b      	cmp	r3, r1
    4954:	d301      	bcc.n	495a <__divsi3+0xba>
    4956:	018b      	lsls	r3, r1, #6
    4958:	1ac0      	subs	r0, r0, r3
    495a:	4152      	adcs	r2, r2
    495c:	0943      	lsrs	r3, r0, #5
    495e:	428b      	cmp	r3, r1
    4960:	d301      	bcc.n	4966 <__divsi3+0xc6>
    4962:	014b      	lsls	r3, r1, #5
    4964:	1ac0      	subs	r0, r0, r3
    4966:	4152      	adcs	r2, r2
    4968:	0903      	lsrs	r3, r0, #4
    496a:	428b      	cmp	r3, r1
    496c:	d301      	bcc.n	4972 <__divsi3+0xd2>
    496e:	010b      	lsls	r3, r1, #4
    4970:	1ac0      	subs	r0, r0, r3
    4972:	4152      	adcs	r2, r2
    4974:	08c3      	lsrs	r3, r0, #3
    4976:	428b      	cmp	r3, r1
    4978:	d301      	bcc.n	497e <__divsi3+0xde>
    497a:	00cb      	lsls	r3, r1, #3
    497c:	1ac0      	subs	r0, r0, r3
    497e:	4152      	adcs	r2, r2
    4980:	0883      	lsrs	r3, r0, #2
    4982:	428b      	cmp	r3, r1
    4984:	d301      	bcc.n	498a <__divsi3+0xea>
    4986:	008b      	lsls	r3, r1, #2
    4988:	1ac0      	subs	r0, r0, r3
    498a:	4152      	adcs	r2, r2
    498c:	0843      	lsrs	r3, r0, #1
    498e:	428b      	cmp	r3, r1
    4990:	d301      	bcc.n	4996 <__divsi3+0xf6>
    4992:	004b      	lsls	r3, r1, #1
    4994:	1ac0      	subs	r0, r0, r3
    4996:	4152      	adcs	r2, r2
    4998:	1a41      	subs	r1, r0, r1
    499a:	d200      	bcs.n	499e <__divsi3+0xfe>
    499c:	4601      	mov	r1, r0
    499e:	4152      	adcs	r2, r2
    49a0:	4610      	mov	r0, r2
    49a2:	4770      	bx	lr
    49a4:	e05d      	b.n	4a62 <__divsi3+0x1c2>
    49a6:	0fca      	lsrs	r2, r1, #31
    49a8:	d000      	beq.n	49ac <__divsi3+0x10c>
    49aa:	4249      	negs	r1, r1
    49ac:	1003      	asrs	r3, r0, #32
    49ae:	d300      	bcc.n	49b2 <__divsi3+0x112>
    49b0:	4240      	negs	r0, r0
    49b2:	4053      	eors	r3, r2
    49b4:	2200      	movs	r2, #0
    49b6:	469c      	mov	ip, r3
    49b8:	0903      	lsrs	r3, r0, #4
    49ba:	428b      	cmp	r3, r1
    49bc:	d32d      	bcc.n	4a1a <__divsi3+0x17a>
    49be:	0a03      	lsrs	r3, r0, #8
    49c0:	428b      	cmp	r3, r1
    49c2:	d312      	bcc.n	49ea <__divsi3+0x14a>
    49c4:	22fc      	movs	r2, #252	; 0xfc
    49c6:	0189      	lsls	r1, r1, #6
    49c8:	ba12      	rev	r2, r2
    49ca:	0a03      	lsrs	r3, r0, #8
    49cc:	428b      	cmp	r3, r1
    49ce:	d30c      	bcc.n	49ea <__divsi3+0x14a>
    49d0:	0189      	lsls	r1, r1, #6
    49d2:	1192      	asrs	r2, r2, #6
    49d4:	428b      	cmp	r3, r1
    49d6:	d308      	bcc.n	49ea <__divsi3+0x14a>
    49d8:	0189      	lsls	r1, r1, #6
    49da:	1192      	asrs	r2, r2, #6
    49dc:	428b      	cmp	r3, r1
    49de:	d304      	bcc.n	49ea <__divsi3+0x14a>
    49e0:	0189      	lsls	r1, r1, #6
    49e2:	d03a      	beq.n	4a5a <__divsi3+0x1ba>
    49e4:	1192      	asrs	r2, r2, #6
    49e6:	e000      	b.n	49ea <__divsi3+0x14a>
    49e8:	0989      	lsrs	r1, r1, #6
    49ea:	09c3      	lsrs	r3, r0, #7
    49ec:	428b      	cmp	r3, r1
    49ee:	d301      	bcc.n	49f4 <__divsi3+0x154>
    49f0:	01cb      	lsls	r3, r1, #7
    49f2:	1ac0      	subs	r0, r0, r3
    49f4:	4152      	adcs	r2, r2
    49f6:	0983      	lsrs	r3, r0, #6
    49f8:	428b      	cmp	r3, r1
    49fa:	d301      	bcc.n	4a00 <__divsi3+0x160>
    49fc:	018b      	lsls	r3, r1, #6
    49fe:	1ac0      	subs	r0, r0, r3
    4a00:	4152      	adcs	r2, r2
    4a02:	0943      	lsrs	r3, r0, #5
    4a04:	428b      	cmp	r3, r1
    4a06:	d301      	bcc.n	4a0c <__divsi3+0x16c>
    4a08:	014b      	lsls	r3, r1, #5
    4a0a:	1ac0      	subs	r0, r0, r3
    4a0c:	4152      	adcs	r2, r2
    4a0e:	0903      	lsrs	r3, r0, #4
    4a10:	428b      	cmp	r3, r1
    4a12:	d301      	bcc.n	4a18 <__divsi3+0x178>
    4a14:	010b      	lsls	r3, r1, #4
    4a16:	1ac0      	subs	r0, r0, r3
    4a18:	4152      	adcs	r2, r2
    4a1a:	08c3      	lsrs	r3, r0, #3
    4a1c:	428b      	cmp	r3, r1
    4a1e:	d301      	bcc.n	4a24 <__divsi3+0x184>
    4a20:	00cb      	lsls	r3, r1, #3
    4a22:	1ac0      	subs	r0, r0, r3
    4a24:	4152      	adcs	r2, r2
    4a26:	0883      	lsrs	r3, r0, #2
    4a28:	428b      	cmp	r3, r1
    4a2a:	d301      	bcc.n	4a30 <__divsi3+0x190>
    4a2c:	008b      	lsls	r3, r1, #2
    4a2e:	1ac0      	subs	r0, r0, r3
    4a30:	4152      	adcs	r2, r2
    4a32:	d2d9      	bcs.n	49e8 <__divsi3+0x148>
    4a34:	0843      	lsrs	r3, r0, #1
    4a36:	428b      	cmp	r3, r1
    4a38:	d301      	bcc.n	4a3e <__divsi3+0x19e>
    4a3a:	004b      	lsls	r3, r1, #1
    4a3c:	1ac0      	subs	r0, r0, r3
    4a3e:	4152      	adcs	r2, r2
    4a40:	1a41      	subs	r1, r0, r1
    4a42:	d200      	bcs.n	4a46 <__divsi3+0x1a6>
    4a44:	4601      	mov	r1, r0
    4a46:	4663      	mov	r3, ip
    4a48:	4152      	adcs	r2, r2
    4a4a:	105b      	asrs	r3, r3, #1
    4a4c:	4610      	mov	r0, r2
    4a4e:	d301      	bcc.n	4a54 <__divsi3+0x1b4>
    4a50:	4240      	negs	r0, r0
    4a52:	2b00      	cmp	r3, #0
    4a54:	d500      	bpl.n	4a58 <__divsi3+0x1b8>
    4a56:	4249      	negs	r1, r1
    4a58:	4770      	bx	lr
    4a5a:	4663      	mov	r3, ip
    4a5c:	105b      	asrs	r3, r3, #1
    4a5e:	d300      	bcc.n	4a62 <__divsi3+0x1c2>
    4a60:	4240      	negs	r0, r0
    4a62:	b501      	push	{r0, lr}
    4a64:	2000      	movs	r0, #0
    4a66:	f000 f805 	bl	4a74 <__aeabi_idiv0>
    4a6a:	bd02      	pop	{r1, pc}

00004a6c <__aeabi_idivmod>:
    4a6c:	2900      	cmp	r1, #0
    4a6e:	d0f8      	beq.n	4a62 <__divsi3+0x1c2>
    4a70:	e716      	b.n	48a0 <__divsi3>
    4a72:	4770      	bx	lr

00004a74 <__aeabi_idiv0>:
    4a74:	4770      	bx	lr
    4a76:	46c0      	nop			; (mov r8, r8)

00004a78 <__aeabi_uldivmod>:
    4a78:	2b00      	cmp	r3, #0
    4a7a:	d111      	bne.n	4aa0 <__aeabi_uldivmod+0x28>
    4a7c:	2a00      	cmp	r2, #0
    4a7e:	d10f      	bne.n	4aa0 <__aeabi_uldivmod+0x28>
    4a80:	2900      	cmp	r1, #0
    4a82:	d100      	bne.n	4a86 <__aeabi_uldivmod+0xe>
    4a84:	2800      	cmp	r0, #0
    4a86:	d002      	beq.n	4a8e <__aeabi_uldivmod+0x16>
    4a88:	2100      	movs	r1, #0
    4a8a:	43c9      	mvns	r1, r1
    4a8c:	1c08      	adds	r0, r1, #0
    4a8e:	b407      	push	{r0, r1, r2}
    4a90:	4802      	ldr	r0, [pc, #8]	; (4a9c <__aeabi_uldivmod+0x24>)
    4a92:	a102      	add	r1, pc, #8	; (adr r1, 4a9c <__aeabi_uldivmod+0x24>)
    4a94:	1840      	adds	r0, r0, r1
    4a96:	9002      	str	r0, [sp, #8]
    4a98:	bd03      	pop	{r0, r1, pc}
    4a9a:	46c0      	nop			; (mov r8, r8)
    4a9c:	ffffffd9 	.word	0xffffffd9
    4aa0:	b403      	push	{r0, r1}
    4aa2:	4668      	mov	r0, sp
    4aa4:	b501      	push	{r0, lr}
    4aa6:	9802      	ldr	r0, [sp, #8]
    4aa8:	f000 f806 	bl	4ab8 <__udivmoddi4>
    4aac:	9b01      	ldr	r3, [sp, #4]
    4aae:	469e      	mov	lr, r3
    4ab0:	b002      	add	sp, #8
    4ab2:	bc0c      	pop	{r2, r3}
    4ab4:	4770      	bx	lr
    4ab6:	46c0      	nop			; (mov r8, r8)

00004ab8 <__udivmoddi4>:
    4ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
    4aba:	4657      	mov	r7, sl
    4abc:	464e      	mov	r6, r9
    4abe:	4645      	mov	r5, r8
    4ac0:	46de      	mov	lr, fp
    4ac2:	b5e0      	push	{r5, r6, r7, lr}
    4ac4:	0004      	movs	r4, r0
    4ac6:	b083      	sub	sp, #12
    4ac8:	000d      	movs	r5, r1
    4aca:	4692      	mov	sl, r2
    4acc:	4699      	mov	r9, r3
    4ace:	428b      	cmp	r3, r1
    4ad0:	d82f      	bhi.n	4b32 <__udivmoddi4+0x7a>
    4ad2:	d02c      	beq.n	4b2e <__udivmoddi4+0x76>
    4ad4:	4649      	mov	r1, r9
    4ad6:	4650      	mov	r0, sl
    4ad8:	f000 f8ae 	bl	4c38 <__clzdi2>
    4adc:	0029      	movs	r1, r5
    4ade:	0006      	movs	r6, r0
    4ae0:	0020      	movs	r0, r4
    4ae2:	f000 f8a9 	bl	4c38 <__clzdi2>
    4ae6:	1a33      	subs	r3, r6, r0
    4ae8:	4698      	mov	r8, r3
    4aea:	3b20      	subs	r3, #32
    4aec:	469b      	mov	fp, r3
    4aee:	d500      	bpl.n	4af2 <__udivmoddi4+0x3a>
    4af0:	e074      	b.n	4bdc <__udivmoddi4+0x124>
    4af2:	4653      	mov	r3, sl
    4af4:	465a      	mov	r2, fp
    4af6:	4093      	lsls	r3, r2
    4af8:	001f      	movs	r7, r3
    4afa:	4653      	mov	r3, sl
    4afc:	4642      	mov	r2, r8
    4afe:	4093      	lsls	r3, r2
    4b00:	001e      	movs	r6, r3
    4b02:	42af      	cmp	r7, r5
    4b04:	d829      	bhi.n	4b5a <__udivmoddi4+0xa2>
    4b06:	d026      	beq.n	4b56 <__udivmoddi4+0x9e>
    4b08:	465b      	mov	r3, fp
    4b0a:	1ba4      	subs	r4, r4, r6
    4b0c:	41bd      	sbcs	r5, r7
    4b0e:	2b00      	cmp	r3, #0
    4b10:	da00      	bge.n	4b14 <__udivmoddi4+0x5c>
    4b12:	e079      	b.n	4c08 <__udivmoddi4+0x150>
    4b14:	2200      	movs	r2, #0
    4b16:	2300      	movs	r3, #0
    4b18:	9200      	str	r2, [sp, #0]
    4b1a:	9301      	str	r3, [sp, #4]
    4b1c:	2301      	movs	r3, #1
    4b1e:	465a      	mov	r2, fp
    4b20:	4093      	lsls	r3, r2
    4b22:	9301      	str	r3, [sp, #4]
    4b24:	2301      	movs	r3, #1
    4b26:	4642      	mov	r2, r8
    4b28:	4093      	lsls	r3, r2
    4b2a:	9300      	str	r3, [sp, #0]
    4b2c:	e019      	b.n	4b62 <__udivmoddi4+0xaa>
    4b2e:	4282      	cmp	r2, r0
    4b30:	d9d0      	bls.n	4ad4 <__udivmoddi4+0x1c>
    4b32:	2200      	movs	r2, #0
    4b34:	2300      	movs	r3, #0
    4b36:	9200      	str	r2, [sp, #0]
    4b38:	9301      	str	r3, [sp, #4]
    4b3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4b3c:	2b00      	cmp	r3, #0
    4b3e:	d001      	beq.n	4b44 <__udivmoddi4+0x8c>
    4b40:	601c      	str	r4, [r3, #0]
    4b42:	605d      	str	r5, [r3, #4]
    4b44:	9800      	ldr	r0, [sp, #0]
    4b46:	9901      	ldr	r1, [sp, #4]
    4b48:	b003      	add	sp, #12
    4b4a:	bc3c      	pop	{r2, r3, r4, r5}
    4b4c:	4690      	mov	r8, r2
    4b4e:	4699      	mov	r9, r3
    4b50:	46a2      	mov	sl, r4
    4b52:	46ab      	mov	fp, r5
    4b54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4b56:	42a3      	cmp	r3, r4
    4b58:	d9d6      	bls.n	4b08 <__udivmoddi4+0x50>
    4b5a:	2200      	movs	r2, #0
    4b5c:	2300      	movs	r3, #0
    4b5e:	9200      	str	r2, [sp, #0]
    4b60:	9301      	str	r3, [sp, #4]
    4b62:	4643      	mov	r3, r8
    4b64:	2b00      	cmp	r3, #0
    4b66:	d0e8      	beq.n	4b3a <__udivmoddi4+0x82>
    4b68:	07fb      	lsls	r3, r7, #31
    4b6a:	0872      	lsrs	r2, r6, #1
    4b6c:	431a      	orrs	r2, r3
    4b6e:	4646      	mov	r6, r8
    4b70:	087b      	lsrs	r3, r7, #1
    4b72:	e00e      	b.n	4b92 <__udivmoddi4+0xda>
    4b74:	42ab      	cmp	r3, r5
    4b76:	d101      	bne.n	4b7c <__udivmoddi4+0xc4>
    4b78:	42a2      	cmp	r2, r4
    4b7a:	d80c      	bhi.n	4b96 <__udivmoddi4+0xde>
    4b7c:	1aa4      	subs	r4, r4, r2
    4b7e:	419d      	sbcs	r5, r3
    4b80:	2001      	movs	r0, #1
    4b82:	1924      	adds	r4, r4, r4
    4b84:	416d      	adcs	r5, r5
    4b86:	2100      	movs	r1, #0
    4b88:	3e01      	subs	r6, #1
    4b8a:	1824      	adds	r4, r4, r0
    4b8c:	414d      	adcs	r5, r1
    4b8e:	2e00      	cmp	r6, #0
    4b90:	d006      	beq.n	4ba0 <__udivmoddi4+0xe8>
    4b92:	42ab      	cmp	r3, r5
    4b94:	d9ee      	bls.n	4b74 <__udivmoddi4+0xbc>
    4b96:	3e01      	subs	r6, #1
    4b98:	1924      	adds	r4, r4, r4
    4b9a:	416d      	adcs	r5, r5
    4b9c:	2e00      	cmp	r6, #0
    4b9e:	d1f8      	bne.n	4b92 <__udivmoddi4+0xda>
    4ba0:	465b      	mov	r3, fp
    4ba2:	9800      	ldr	r0, [sp, #0]
    4ba4:	9901      	ldr	r1, [sp, #4]
    4ba6:	1900      	adds	r0, r0, r4
    4ba8:	4169      	adcs	r1, r5
    4baa:	2b00      	cmp	r3, #0
    4bac:	db22      	blt.n	4bf4 <__udivmoddi4+0x13c>
    4bae:	002b      	movs	r3, r5
    4bb0:	465a      	mov	r2, fp
    4bb2:	40d3      	lsrs	r3, r2
    4bb4:	002a      	movs	r2, r5
    4bb6:	4644      	mov	r4, r8
    4bb8:	40e2      	lsrs	r2, r4
    4bba:	001c      	movs	r4, r3
    4bbc:	465b      	mov	r3, fp
    4bbe:	0015      	movs	r5, r2
    4bc0:	2b00      	cmp	r3, #0
    4bc2:	db2c      	blt.n	4c1e <__udivmoddi4+0x166>
    4bc4:	0026      	movs	r6, r4
    4bc6:	409e      	lsls	r6, r3
    4bc8:	0033      	movs	r3, r6
    4bca:	0026      	movs	r6, r4
    4bcc:	4647      	mov	r7, r8
    4bce:	40be      	lsls	r6, r7
    4bd0:	0032      	movs	r2, r6
    4bd2:	1a80      	subs	r0, r0, r2
    4bd4:	4199      	sbcs	r1, r3
    4bd6:	9000      	str	r0, [sp, #0]
    4bd8:	9101      	str	r1, [sp, #4]
    4bda:	e7ae      	b.n	4b3a <__udivmoddi4+0x82>
    4bdc:	4642      	mov	r2, r8
    4bde:	2320      	movs	r3, #32
    4be0:	1a9b      	subs	r3, r3, r2
    4be2:	4652      	mov	r2, sl
    4be4:	40da      	lsrs	r2, r3
    4be6:	4641      	mov	r1, r8
    4be8:	0013      	movs	r3, r2
    4bea:	464a      	mov	r2, r9
    4bec:	408a      	lsls	r2, r1
    4bee:	0017      	movs	r7, r2
    4bf0:	431f      	orrs	r7, r3
    4bf2:	e782      	b.n	4afa <__udivmoddi4+0x42>
    4bf4:	4642      	mov	r2, r8
    4bf6:	2320      	movs	r3, #32
    4bf8:	1a9b      	subs	r3, r3, r2
    4bfa:	002a      	movs	r2, r5
    4bfc:	4646      	mov	r6, r8
    4bfe:	409a      	lsls	r2, r3
    4c00:	0023      	movs	r3, r4
    4c02:	40f3      	lsrs	r3, r6
    4c04:	4313      	orrs	r3, r2
    4c06:	e7d5      	b.n	4bb4 <__udivmoddi4+0xfc>
    4c08:	4642      	mov	r2, r8
    4c0a:	2320      	movs	r3, #32
    4c0c:	2100      	movs	r1, #0
    4c0e:	1a9b      	subs	r3, r3, r2
    4c10:	2200      	movs	r2, #0
    4c12:	9100      	str	r1, [sp, #0]
    4c14:	9201      	str	r2, [sp, #4]
    4c16:	2201      	movs	r2, #1
    4c18:	40da      	lsrs	r2, r3
    4c1a:	9201      	str	r2, [sp, #4]
    4c1c:	e782      	b.n	4b24 <__udivmoddi4+0x6c>
    4c1e:	4642      	mov	r2, r8
    4c20:	2320      	movs	r3, #32
    4c22:	0026      	movs	r6, r4
    4c24:	1a9b      	subs	r3, r3, r2
    4c26:	40de      	lsrs	r6, r3
    4c28:	002f      	movs	r7, r5
    4c2a:	46b4      	mov	ip, r6
    4c2c:	4097      	lsls	r7, r2
    4c2e:	4666      	mov	r6, ip
    4c30:	003b      	movs	r3, r7
    4c32:	4333      	orrs	r3, r6
    4c34:	e7c9      	b.n	4bca <__udivmoddi4+0x112>
    4c36:	46c0      	nop			; (mov r8, r8)

00004c38 <__clzdi2>:
    4c38:	b510      	push	{r4, lr}
    4c3a:	2900      	cmp	r1, #0
    4c3c:	d103      	bne.n	4c46 <__clzdi2+0xe>
    4c3e:	f000 f807 	bl	4c50 <__clzsi2>
    4c42:	3020      	adds	r0, #32
    4c44:	e002      	b.n	4c4c <__clzdi2+0x14>
    4c46:	1c08      	adds	r0, r1, #0
    4c48:	f000 f802 	bl	4c50 <__clzsi2>
    4c4c:	bd10      	pop	{r4, pc}
    4c4e:	46c0      	nop			; (mov r8, r8)

00004c50 <__clzsi2>:
    4c50:	211c      	movs	r1, #28
    4c52:	2301      	movs	r3, #1
    4c54:	041b      	lsls	r3, r3, #16
    4c56:	4298      	cmp	r0, r3
    4c58:	d301      	bcc.n	4c5e <__clzsi2+0xe>
    4c5a:	0c00      	lsrs	r0, r0, #16
    4c5c:	3910      	subs	r1, #16
    4c5e:	0a1b      	lsrs	r3, r3, #8
    4c60:	4298      	cmp	r0, r3
    4c62:	d301      	bcc.n	4c68 <__clzsi2+0x18>
    4c64:	0a00      	lsrs	r0, r0, #8
    4c66:	3908      	subs	r1, #8
    4c68:	091b      	lsrs	r3, r3, #4
    4c6a:	4298      	cmp	r0, r3
    4c6c:	d301      	bcc.n	4c72 <__clzsi2+0x22>
    4c6e:	0900      	lsrs	r0, r0, #4
    4c70:	3904      	subs	r1, #4
    4c72:	a202      	add	r2, pc, #8	; (adr r2, 4c7c <__clzsi2+0x2c>)
    4c74:	5c10      	ldrb	r0, [r2, r0]
    4c76:	1840      	adds	r0, r0, r1
    4c78:	4770      	bx	lr
    4c7a:	46c0      	nop			; (mov r8, r8)
    4c7c:	02020304 	.word	0x02020304
    4c80:	01010101 	.word	0x01010101
	...

00004c8c <__libc_init_array>:
    4c8c:	b570      	push	{r4, r5, r6, lr}
    4c8e:	4e0d      	ldr	r6, [pc, #52]	; (4cc4 <__libc_init_array+0x38>)
    4c90:	4d0d      	ldr	r5, [pc, #52]	; (4cc8 <__libc_init_array+0x3c>)
    4c92:	2400      	movs	r4, #0
    4c94:	1bad      	subs	r5, r5, r6
    4c96:	10ad      	asrs	r5, r5, #2
    4c98:	d005      	beq.n	4ca6 <__libc_init_array+0x1a>
    4c9a:	00a3      	lsls	r3, r4, #2
    4c9c:	58f3      	ldr	r3, [r6, r3]
    4c9e:	3401      	adds	r4, #1
    4ca0:	4798      	blx	r3
    4ca2:	42a5      	cmp	r5, r4
    4ca4:	d1f9      	bne.n	4c9a <__libc_init_array+0xe>
    4ca6:	f000 fc15 	bl	54d4 <_init>
    4caa:	4e08      	ldr	r6, [pc, #32]	; (4ccc <__libc_init_array+0x40>)
    4cac:	4d08      	ldr	r5, [pc, #32]	; (4cd0 <__libc_init_array+0x44>)
    4cae:	2400      	movs	r4, #0
    4cb0:	1bad      	subs	r5, r5, r6
    4cb2:	10ad      	asrs	r5, r5, #2
    4cb4:	d005      	beq.n	4cc2 <__libc_init_array+0x36>
    4cb6:	00a3      	lsls	r3, r4, #2
    4cb8:	58f3      	ldr	r3, [r6, r3]
    4cba:	3401      	adds	r4, #1
    4cbc:	4798      	blx	r3
    4cbe:	42a5      	cmp	r5, r4
    4cc0:	d1f9      	bne.n	4cb6 <__libc_init_array+0x2a>
    4cc2:	bd70      	pop	{r4, r5, r6, pc}
    4cc4:	000054e0 	.word	0x000054e0
    4cc8:	000054e0 	.word	0x000054e0
    4ccc:	000054e0 	.word	0x000054e0
    4cd0:	000054e8 	.word	0x000054e8

00004cd4 <register_fini>:
    4cd4:	4b03      	ldr	r3, [pc, #12]	; (4ce4 <register_fini+0x10>)
    4cd6:	b510      	push	{r4, lr}
    4cd8:	2b00      	cmp	r3, #0
    4cda:	d002      	beq.n	4ce2 <register_fini+0xe>
    4cdc:	4802      	ldr	r0, [pc, #8]	; (4ce8 <register_fini+0x14>)
    4cde:	f000 f805 	bl	4cec <atexit>
    4ce2:	bd10      	pop	{r4, pc}
    4ce4:	00000000 	.word	0x00000000
    4ce8:	00004cfd 	.word	0x00004cfd

00004cec <atexit>:
    4cec:	b510      	push	{r4, lr}
    4cee:	0001      	movs	r1, r0
    4cf0:	2300      	movs	r3, #0
    4cf2:	2200      	movs	r2, #0
    4cf4:	2000      	movs	r0, #0
    4cf6:	f000 f81f 	bl	4d38 <__register_exitproc>
    4cfa:	bd10      	pop	{r4, pc}

00004cfc <__libc_fini_array>:
    4cfc:	b570      	push	{r4, r5, r6, lr}
    4cfe:	4b09      	ldr	r3, [pc, #36]	; (4d24 <__libc_fini_array+0x28>)
    4d00:	4c09      	ldr	r4, [pc, #36]	; (4d28 <__libc_fini_array+0x2c>)
    4d02:	1ae4      	subs	r4, r4, r3
    4d04:	10a4      	asrs	r4, r4, #2
    4d06:	d009      	beq.n	4d1c <__libc_fini_array+0x20>
    4d08:	4a08      	ldr	r2, [pc, #32]	; (4d2c <__libc_fini_array+0x30>)
    4d0a:	18a5      	adds	r5, r4, r2
    4d0c:	00ad      	lsls	r5, r5, #2
    4d0e:	18ed      	adds	r5, r5, r3
    4d10:	682b      	ldr	r3, [r5, #0]
    4d12:	3c01      	subs	r4, #1
    4d14:	4798      	blx	r3
    4d16:	3d04      	subs	r5, #4
    4d18:	2c00      	cmp	r4, #0
    4d1a:	d1f9      	bne.n	4d10 <__libc_fini_array+0x14>
    4d1c:	f000 fbe4 	bl	54e8 <_fini>
    4d20:	bd70      	pop	{r4, r5, r6, pc}
    4d22:	46c0      	nop			; (mov r8, r8)
    4d24:	000054f4 	.word	0x000054f4
    4d28:	000054f8 	.word	0x000054f8
    4d2c:	3fffffff 	.word	0x3fffffff

00004d30 <__retarget_lock_acquire_recursive>:
    4d30:	4770      	bx	lr
    4d32:	46c0      	nop			; (mov r8, r8)

00004d34 <__retarget_lock_release_recursive>:
    4d34:	4770      	bx	lr
    4d36:	46c0      	nop			; (mov r8, r8)

00004d38 <__register_exitproc>:
    4d38:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d3a:	464e      	mov	r6, r9
    4d3c:	4645      	mov	r5, r8
    4d3e:	46de      	mov	lr, fp
    4d40:	4657      	mov	r7, sl
    4d42:	b5e0      	push	{r5, r6, r7, lr}
    4d44:	4d36      	ldr	r5, [pc, #216]	; (4e20 <__register_exitproc+0xe8>)
    4d46:	b083      	sub	sp, #12
    4d48:	0006      	movs	r6, r0
    4d4a:	6828      	ldr	r0, [r5, #0]
    4d4c:	4698      	mov	r8, r3
    4d4e:	000f      	movs	r7, r1
    4d50:	4691      	mov	r9, r2
    4d52:	f7ff ffed 	bl	4d30 <__retarget_lock_acquire_recursive>
    4d56:	4b33      	ldr	r3, [pc, #204]	; (4e24 <__register_exitproc+0xec>)
    4d58:	681c      	ldr	r4, [r3, #0]
    4d5a:	23a4      	movs	r3, #164	; 0xa4
    4d5c:	005b      	lsls	r3, r3, #1
    4d5e:	58e0      	ldr	r0, [r4, r3]
    4d60:	2800      	cmp	r0, #0
    4d62:	d052      	beq.n	4e0a <__register_exitproc+0xd2>
    4d64:	6843      	ldr	r3, [r0, #4]
    4d66:	2b1f      	cmp	r3, #31
    4d68:	dc13      	bgt.n	4d92 <__register_exitproc+0x5a>
    4d6a:	1c5a      	adds	r2, r3, #1
    4d6c:	9201      	str	r2, [sp, #4]
    4d6e:	2e00      	cmp	r6, #0
    4d70:	d128      	bne.n	4dc4 <__register_exitproc+0x8c>
    4d72:	9a01      	ldr	r2, [sp, #4]
    4d74:	3302      	adds	r3, #2
    4d76:	009b      	lsls	r3, r3, #2
    4d78:	6042      	str	r2, [r0, #4]
    4d7a:	501f      	str	r7, [r3, r0]
    4d7c:	6828      	ldr	r0, [r5, #0]
    4d7e:	f7ff ffd9 	bl	4d34 <__retarget_lock_release_recursive>
    4d82:	2000      	movs	r0, #0
    4d84:	b003      	add	sp, #12
    4d86:	bc3c      	pop	{r2, r3, r4, r5}
    4d88:	4690      	mov	r8, r2
    4d8a:	4699      	mov	r9, r3
    4d8c:	46a2      	mov	sl, r4
    4d8e:	46ab      	mov	fp, r5
    4d90:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4d92:	4b25      	ldr	r3, [pc, #148]	; (4e28 <__register_exitproc+0xf0>)
    4d94:	2b00      	cmp	r3, #0
    4d96:	d03d      	beq.n	4e14 <__register_exitproc+0xdc>
    4d98:	20c8      	movs	r0, #200	; 0xc8
    4d9a:	0040      	lsls	r0, r0, #1
    4d9c:	e000      	b.n	4da0 <__register_exitproc+0x68>
    4d9e:	bf00      	nop
    4da0:	2800      	cmp	r0, #0
    4da2:	d037      	beq.n	4e14 <__register_exitproc+0xdc>
    4da4:	22a4      	movs	r2, #164	; 0xa4
    4da6:	2300      	movs	r3, #0
    4da8:	0052      	lsls	r2, r2, #1
    4daa:	58a1      	ldr	r1, [r4, r2]
    4dac:	6043      	str	r3, [r0, #4]
    4dae:	6001      	str	r1, [r0, #0]
    4db0:	50a0      	str	r0, [r4, r2]
    4db2:	3240      	adds	r2, #64	; 0x40
    4db4:	5083      	str	r3, [r0, r2]
    4db6:	3204      	adds	r2, #4
    4db8:	5083      	str	r3, [r0, r2]
    4dba:	3301      	adds	r3, #1
    4dbc:	9301      	str	r3, [sp, #4]
    4dbe:	2300      	movs	r3, #0
    4dc0:	2e00      	cmp	r6, #0
    4dc2:	d0d6      	beq.n	4d72 <__register_exitproc+0x3a>
    4dc4:	009a      	lsls	r2, r3, #2
    4dc6:	4692      	mov	sl, r2
    4dc8:	4482      	add	sl, r0
    4dca:	464a      	mov	r2, r9
    4dcc:	2188      	movs	r1, #136	; 0x88
    4dce:	4654      	mov	r4, sl
    4dd0:	5062      	str	r2, [r4, r1]
    4dd2:	22c4      	movs	r2, #196	; 0xc4
    4dd4:	0052      	lsls	r2, r2, #1
    4dd6:	4691      	mov	r9, r2
    4dd8:	4481      	add	r9, r0
    4dda:	464a      	mov	r2, r9
    4ddc:	3987      	subs	r1, #135	; 0x87
    4dde:	4099      	lsls	r1, r3
    4de0:	6812      	ldr	r2, [r2, #0]
    4de2:	468b      	mov	fp, r1
    4de4:	430a      	orrs	r2, r1
    4de6:	4694      	mov	ip, r2
    4de8:	464a      	mov	r2, r9
    4dea:	4661      	mov	r1, ip
    4dec:	6011      	str	r1, [r2, #0]
    4dee:	2284      	movs	r2, #132	; 0x84
    4df0:	4641      	mov	r1, r8
    4df2:	0052      	lsls	r2, r2, #1
    4df4:	50a1      	str	r1, [r4, r2]
    4df6:	2e02      	cmp	r6, #2
    4df8:	d1bb      	bne.n	4d72 <__register_exitproc+0x3a>
    4dfa:	0002      	movs	r2, r0
    4dfc:	465c      	mov	r4, fp
    4dfe:	328d      	adds	r2, #141	; 0x8d
    4e00:	32ff      	adds	r2, #255	; 0xff
    4e02:	6811      	ldr	r1, [r2, #0]
    4e04:	430c      	orrs	r4, r1
    4e06:	6014      	str	r4, [r2, #0]
    4e08:	e7b3      	b.n	4d72 <__register_exitproc+0x3a>
    4e0a:	0020      	movs	r0, r4
    4e0c:	304d      	adds	r0, #77	; 0x4d
    4e0e:	30ff      	adds	r0, #255	; 0xff
    4e10:	50e0      	str	r0, [r4, r3]
    4e12:	e7a7      	b.n	4d64 <__register_exitproc+0x2c>
    4e14:	6828      	ldr	r0, [r5, #0]
    4e16:	f7ff ff8d 	bl	4d34 <__retarget_lock_release_recursive>
    4e1a:	2001      	movs	r0, #1
    4e1c:	4240      	negs	r0, r0
    4e1e:	e7b1      	b.n	4d84 <__register_exitproc+0x4c>
    4e20:	20000438 	.word	0x20000438
    4e24:	000054d0 	.word	0x000054d0
    4e28:	00000000 	.word	0x00000000
    4e2c:	54524155 	.word	0x54524155
    4e30:	6e492033 	.word	0x6e492033
    4e34:	61697469 	.word	0x61697469
    4e38:	657a696c 	.word	0x657a696c
    4e3c:	000a0d64 	.word	0x000a0d64
    4e40:	20495053 	.word	0x20495053
    4e44:	74696e49 	.word	0x74696e49
    4e48:	696c6169 	.word	0x696c6169
    4e4c:	2064657a 	.word	0x2064657a
    4e50:	6f6c5328 	.word	0x6f6c5328
    4e54:	0a0d2977 	.word	0x0a0d2977
    4e58:	00000000 	.word	0x00000000
    4e5c:	43204453 	.word	0x43204453
    4e60:	20647261 	.word	0x20647261
    4e64:	74696e49 	.word	0x74696e49
    4e68:	696c6169 	.word	0x696c6169
    4e6c:	2064657a 	.word	0x2064657a
    4e70:	63637553 	.word	0x63637553
    4e74:	66737365 	.word	0x66737365
    4e78:	796c6c75 	.word	0x796c6c75
    4e7c:	00000a0d 	.word	0x00000a0d
    4e80:	43204453 	.word	0x43204453
    4e84:	20647261 	.word	0x20647261
    4e88:	74696e49 	.word	0x74696e49
    4e8c:	696c6169 	.word	0x696c6169
    4e90:	6974617a 	.word	0x6974617a
    4e94:	46206e6f 	.word	0x46206e6f
    4e98:	656c6961 	.word	0x656c6961
    4e9c:	000a0d64 	.word	0x000a0d64
    4ea0:	6e756f4d 	.word	0x6e756f4d
    4ea4:	676e6974 	.word	0x676e6974
    4ea8:	20445320 	.word	0x20445320
    4eac:	64726163 	.word	0x64726163
    4eb0:	0d2e2e2e 	.word	0x0d2e2e2e
    4eb4:	0000000a 	.word	0x0000000a
    4eb8:	6f727245 	.word	0x6f727245
    4ebc:	6f6d2072 	.word	0x6f6d2072
    4ec0:	69746e75 	.word	0x69746e75
    4ec4:	6620676e 	.word	0x6620676e
    4ec8:	20656c69 	.word	0x20656c69
    4ecc:	74737973 	.word	0x74737973
    4ed0:	0a0d6d65 	.word	0x0a0d6d65
    4ed4:	00000000 	.word	0x00000000
    4ed8:	63204453 	.word	0x63204453
    4edc:	20647261 	.word	0x20647261
    4ee0:	6e756f6d 	.word	0x6e756f6d
    4ee4:	20646574 	.word	0x20646574
    4ee8:	63637573 	.word	0x63637573
    4eec:	66737365 	.word	0x66737365
    4ef0:	796c6c75 	.word	0x796c6c75
    4ef4:	00000a0d 	.word	0x00000a0d
    4ef8:	6e65704f 	.word	0x6e65704f
    4efc:	20676e69 	.word	0x20676e69
    4f00:	656c6966 	.word	0x656c6966
    4f04:	726f6620 	.word	0x726f6620
    4f08:	69727720 	.word	0x69727720
    4f0c:	676e6974 	.word	0x676e6974
    4f10:	0d2e2e2e 	.word	0x0d2e2e2e
    4f14:	0000000a 	.word	0x0000000a
    4f18:	6f727245 	.word	0x6f727245
    4f1c:	706f2072 	.word	0x706f2072
    4f20:	6e696e65 	.word	0x6e696e65
    4f24:	69662067 	.word	0x69662067
    4f28:	6620656c 	.word	0x6620656c
    4f2c:	7720726f 	.word	0x7720726f
    4f30:	69746972 	.word	0x69746972
    4f34:	0a0d676e 	.word	0x0a0d676e
    4f38:	00000000 	.word	0x00000000
    4f3c:	74697257 	.word	0x74697257
    4f40:	20676e69 	.word	0x20676e69
    4f44:	61746164 	.word	0x61746164
    4f48:	206f7420 	.word	0x206f7420
    4f4c:	656c6966 	.word	0x656c6966
    4f50:	0d2e2e2e 	.word	0x0d2e2e2e
    4f54:	0000000a 	.word	0x0000000a
    4f58:	61746144 	.word	0x61746144
    4f5c:	61442c31 	.word	0x61442c31
    4f60:	2c326174 	.word	0x2c326174
    4f64:	61746144 	.word	0x61746144
    4f68:	61442c33 	.word	0x61442c33
    4f6c:	0d346174 	.word	0x0d346174
    4f70:	0000000a 	.word	0x0000000a
    4f74:	6f727245 	.word	0x6f727245
    4f78:	72772072 	.word	0x72772072
    4f7c:	6e697469 	.word	0x6e697469
    4f80:	6f742067 	.word	0x6f742067
    4f84:	6c696620 	.word	0x6c696620
    4f88:	000a0d65 	.word	0x000a0d65
    4f8c:	6f727245 	.word	0x6f727245
    4f90:	6c632072 	.word	0x6c632072
    4f94:	6e69736f 	.word	0x6e69736f
    4f98:	69662067 	.word	0x69662067
    4f9c:	6120656c 	.word	0x6120656c
    4fa0:	72657466 	.word	0x72657466
    4fa4:	69727720 	.word	0x69727720
    4fa8:	676e6974 	.word	0x676e6974
    4fac:	00000a0d 	.word	0x00000a0d
    4fb0:	656c6946 	.word	0x656c6946
    4fb4:	69727720 	.word	0x69727720
    4fb8:	6e657474 	.word	0x6e657474
    4fbc:	646e6120 	.word	0x646e6120
    4fc0:	6f6c6320 	.word	0x6f6c6320
    4fc4:	20646573 	.word	0x20646573
    4fc8:	63637573 	.word	0x63637573
    4fcc:	66737365 	.word	0x66737365
    4fd0:	796c6c75 	.word	0x796c6c75
    4fd4:	00000a0d 	.word	0x00000a0d
    4fd8:	6e65704f 	.word	0x6e65704f
    4fdc:	20676e69 	.word	0x20676e69
    4fe0:	656c6966 	.word	0x656c6966
    4fe4:	726f6620 	.word	0x726f6620
    4fe8:	61657220 	.word	0x61657220
    4fec:	676e6964 	.word	0x676e6964
    4ff0:	0d2e2e2e 	.word	0x0d2e2e2e
    4ff4:	0000000a 	.word	0x0000000a
    4ff8:	6f727245 	.word	0x6f727245
    4ffc:	706f2072 	.word	0x706f2072
    5000:	6e696e65 	.word	0x6e696e65
    5004:	69662067 	.word	0x69662067
    5008:	6620656c 	.word	0x6620656c
    500c:	7220726f 	.word	0x7220726f
    5010:	69646165 	.word	0x69646165
    5014:	0a0d676e 	.word	0x0a0d676e
    5018:	00000000 	.word	0x00000000
    501c:	64616552 	.word	0x64616552
    5020:	20676e69 	.word	0x20676e69
    5024:	656c6966 	.word	0x656c6966
    5028:	6e6f6320 	.word	0x6e6f6320
    502c:	746e6574 	.word	0x746e6574
    5030:	0a0d3a73 	.word	0x0a0d3a73
    5034:	00000000 	.word	0x00000000
    5038:	6f727245 	.word	0x6f727245
    503c:	6c632072 	.word	0x6c632072
    5040:	6e69736f 	.word	0x6e69736f
    5044:	69662067 	.word	0x69662067
    5048:	6120656c 	.word	0x6120656c
    504c:	72657466 	.word	0x72657466
    5050:	61657220 	.word	0x61657220
    5054:	676e6964 	.word	0x676e6964
    5058:	00000a0d 	.word	0x00000a0d
    505c:	656c6946 	.word	0x656c6946
    5060:	61657220 	.word	0x61657220
    5064:	6e612064 	.word	0x6e612064
    5068:	6c632064 	.word	0x6c632064
    506c:	6465736f 	.word	0x6465736f
    5070:	63757320 	.word	0x63757320
    5074:	73736563 	.word	0x73736563
    5078:	6c6c7566 	.word	0x6c6c7566
    507c:	000a0d79 	.word	0x000a0d79
    5080:	64616572 	.word	0x64616572
    5084:	0d203220 	.word	0x0d203220
    5088:	0000000a 	.word	0x0000000a
    508c:	74697277 	.word	0x74697277
    5090:	20312065 	.word	0x20312065
    5094:	00000a0d 	.word	0x00000a0d
    5098:	74697277 	.word	0x74697277
    509c:	20322065 	.word	0x20322065
    50a0:	00000a0d 	.word	0x00000a0d
    50a4:	2c2b2a22 	.word	0x2c2b2a22
    50a8:	3d3c3b3a 	.word	0x3d3c3b3a
    50ac:	5d5b3f3e 	.word	0x5d5b3f3e
    50b0:	00007f7c 	.word	0x00007f7c
    50b4:	61434453 	.word	0x61434453
    50b8:	72576472 	.word	0x72576472
    50bc:	5f657469 	.word	0x5f657469
    50c0:	20646d43 	.word	0x20646d43
    50c4:	72617473 	.word	0x72617473
    50c8:	21646574 	.word	0x21646574
    50cc:	00000a0d 	.word	0x00000a0d
    50d0:	67676f54 	.word	0x67676f54
    50d4:	4c20656c 	.word	0x4c20656c
    50d8:	20656e69 	.word	0x20656e69
    50dc:	20646e61 	.word	0x20646e61
    50e0:	6e617274 	.word	0x6e617274
    50e4:	74696d73 	.word	0x74696d73
    50e8:	74616420 	.word	0x74616420
    50ec:	000a0d61 	.word	0x000a0d61
    50f0:	64726143 	.word	0x64726143
    50f4:	20736920 	.word	0x20736920
    50f8:	656c6573 	.word	0x656c6573
    50fc:	64657463 	.word	0x64657463
    5100:	000a0d21 	.word	0x000a0d21
    5104:	535f4453 	.word	0x535f4453
    5108:	6f742053 	.word	0x6f742053
    510c:	0a0d3020 	.word	0x0a0d3020
    5110:	00000000 	.word	0x00000000
    5114:	63656843 	.word	0x63656843
    5118:	6669206b 	.word	0x6669206b
    511c:	43445320 	.word	0x43445320
    5120:	5f647261 	.word	0x5f647261
    5124:	74696157 	.word	0x74696157
    5128:	64616552 	.word	0x64616552
    512c:	30203d20 	.word	0x30203d20
    5130:	00000a0d 	.word	0x00000a0d
    5134:	61434453 	.word	0x61434453
    5138:	44206472 	.word	0x44206472
    513c:	62617369 	.word	0x62617369
    5140:	5320656c 	.word	0x5320656c
    5144:	63656c65 	.word	0x63656c65
    5148:	000a0d74 	.word	0x000a0d74
    514c:	72617473 	.word	0x72617473
    5150:	6f632074 	.word	0x6f632074
    5154:	6e616d6d 	.word	0x6e616d6d
    5158:	6e612064 	.word	0x6e612064
    515c:	6e692064 	.word	0x6e692064
    5160:	0d786564 	.word	0x0d786564
    5164:	0000000a 	.word	0x0000000a
    5168:	75677241 	.word	0x75677241
    516c:	746e656d 	.word	0x746e656d
    5170:	31335b20 	.word	0x31335b20
    5174:	34322e2e 	.word	0x34322e2e
    5178:	000a0d5d 	.word	0x000a0d5d
    517c:	75677241 	.word	0x75677241
    5180:	746e656d 	.word	0x746e656d
    5184:	33325b20 	.word	0x33325b20
    5188:	36312e2e 	.word	0x36312e2e
    518c:	000a0d5d 	.word	0x000a0d5d
    5190:	75677241 	.word	0x75677241
    5194:	746e656d 	.word	0x746e656d
    5198:	35315b20 	.word	0x35315b20
    519c:	5d382e2e 	.word	0x5d382e2e
    51a0:	00000a0d 	.word	0x00000a0d
    51a4:	75677241 	.word	0x75677241
    51a8:	746e656d 	.word	0x746e656d
    51ac:	2e375b20 	.word	0x2e375b20
    51b0:	0d5d302e 	.word	0x0d5d302e
    51b4:	0000000a 	.word	0x0000000a
    51b8:	646e6553 	.word	0x646e6553
    51bc:	6c615620 	.word	0x6c615620
    51c0:	43206469 	.word	0x43206469
    51c4:	61204352 	.word	0x61204352
    51c8:	5320646e 	.word	0x5320646e
    51cc:	21706f74 	.word	0x21706f74
    51d0:	00000a0d 	.word	0x00000a0d
    51d4:	72617453 	.word	0x72617453
    51d8:	676e6974 	.word	0x676e6974
    51dc:	20445320 	.word	0x20445320
    51e0:	64726143 	.word	0x64726143
    51e4:	696e4920 	.word	0x696e4920
    51e8:	6c616974 	.word	0x6c616974
    51ec:	74617a69 	.word	0x74617a69
    51f0:	0d6e6f69 	.word	0x0d6e6f69
    51f4:	0000000a 	.word	0x0000000a
    51f8:	43204453 	.word	0x43204453
    51fc:	20647261 	.word	0x20647261
    5200:	74696e49 	.word	0x74696e49
    5204:	696c6169 	.word	0x696c6169
    5208:	2064657a 	.word	0x2064657a
    520c:	53206f74 	.word	0x53206f74
    5210:	20776f6c 	.word	0x20776f6c
    5214:	65657053 	.word	0x65657053
    5218:	000a0d64 	.word	0x000a0d64
    521c:	746e6553 	.word	0x746e6553
    5220:	30303120 	.word	0x30303120
    5224:	6d756420 	.word	0x6d756420
    5228:	6320796d 	.word	0x6320796d
    522c:	6b636f6c 	.word	0x6b636f6c
    5230:	000a0d73 	.word	0x000a0d73
    5234:	73205343 	.word	0x73205343
    5238:	74207465 	.word	0x74207465
    523c:	4f4c206f 	.word	0x4f4c206f
    5240:	000a0d57 	.word	0x000a0d57
    5244:	65747441 	.word	0x65747441
    5248:	6974706d 	.word	0x6974706d
    524c:	4320676e 	.word	0x4320676e
    5250:	2030444d 	.word	0x2030444d
    5254:	65736552 	.word	0x65736552
    5258:	61202c74 	.word	0x61202c74
    525c:	6d657474 	.word	0x6d657474
    5260:	203a7470 	.word	0x203a7470
    5264:	00000000 	.word	0x00000000
    5268:	30444d43 	.word	0x30444d43
    526c:	73655220 	.word	0x73655220
    5270:	736e6f70 	.word	0x736e6f70
    5274:	00203a65 	.word	0x00203a65
    5278:	64726143 	.word	0x64726143
    527c:	73655220 	.word	0x73655220
    5280:	53207465 	.word	0x53207465
    5284:	65636375 	.word	0x65636375
    5288:	75667373 	.word	0x75667373
    528c:	000a0d6c 	.word	0x000a0d6c
    5290:	38444d43 	.word	0x38444d43
    5294:	6e655320 	.word	0x6e655320
    5298:	000a0d74 	.word	0x000a0d74
    529c:	38444d43 	.word	0x38444d43
    52a0:	69614620 	.word	0x69614620
    52a4:	3a64656c 	.word	0x3a64656c
    52a8:	72614320 	.word	0x72614320
    52ac:	6f642064 	.word	0x6f642064
    52b0:	6e207365 	.word	0x6e207365
    52b4:	7320746f 	.word	0x7320746f
    52b8:	6f707075 	.word	0x6f707075
    52bc:	72207472 	.word	0x72207472
    52c0:	69757165 	.word	0x69757165
    52c4:	20646572 	.word	0x20646572
    52c8:	746c6f76 	.word	0x746c6f76
    52cc:	0d656761 	.word	0x0d656761
    52d0:	0000000a 	.word	0x0000000a
    52d4:	38444d43 	.word	0x38444d43
    52d8:	73655220 	.word	0x73655220
    52dc:	736e6f70 	.word	0x736e6f70
    52e0:	61562065 	.word	0x61562065
    52e4:	0d64696c 	.word	0x0d64696c
    52e8:	0000000a 	.word	0x0000000a
    52ec:	35444d43 	.word	0x35444d43
    52f0:	65532035 	.word	0x65532035
    52f4:	0a0d746e 	.word	0x0a0d746e
    52f8:	00000000 	.word	0x00000000
    52fc:	444d4341 	.word	0x444d4341
    5300:	53203134 	.word	0x53203134
    5304:	0d746e65 	.word	0x0d746e65
    5308:	0000000a 	.word	0x0000000a
    530c:	444d4341 	.word	0x444d4341
    5310:	54203134 	.word	0x54203134
    5314:	6f656d69 	.word	0x6f656d69
    5318:	0a0d7475 	.word	0x0a0d7475
    531c:	00000000 	.word	0x00000000
    5320:	64726143 	.word	0x64726143
    5324:	696e4920 	.word	0x696e4920
    5328:	6c616974 	.word	0x6c616974
    532c:	74617a69 	.word	0x74617a69
    5330:	206e6f69 	.word	0x206e6f69
    5334:	706d6f43 	.word	0x706d6f43
    5338:	6574656c 	.word	0x6574656c
    533c:	00000a0d 	.word	0x00000a0d
    5340:	35444d43 	.word	0x35444d43
    5344:	65532038 	.word	0x65532038
    5348:	0a0d746e 	.word	0x0a0d746e
    534c:	00000000 	.word	0x00000000
    5350:	626f7250 	.word	0x626f7250
    5354:	206d656c 	.word	0x206d656c
    5358:	64616572 	.word	0x64616572
    535c:	20676e69 	.word	0x20676e69
    5360:	2052434f 	.word	0x2052434f
    5364:	61746164 	.word	0x61746164
    5368:	00000a0d 	.word	0x00000a0d
    536c:	64726143 	.word	0x64726143
    5370:	3256203a 	.word	0x3256203a
    5374:	5320302e 	.word	0x5320302e
    5378:	0d434844 	.word	0x0d434844
    537c:	0000000a 	.word	0x0000000a
    5380:	64726143 	.word	0x64726143
    5384:	70795420 	.word	0x70795420
    5388:	56203a65 	.word	0x56203a65
    538c:	20302e32 	.word	0x20302e32
    5390:	6e617453 	.word	0x6e617453
    5394:	64726164 	.word	0x64726164
    5398:	70614320 	.word	0x70614320
    539c:	74696361 	.word	0x74696361
    53a0:	000a0d79 	.word	0x000a0d79
    53a4:	38444d43 	.word	0x38444d43
    53a8:	69614620 	.word	0x69614620
    53ac:	2c64656c 	.word	0x2c64656c
    53b0:	72614320 	.word	0x72614320
    53b4:	6f4e2064 	.word	0x6f4e2064
    53b8:	75532074 	.word	0x75532074
    53bc:	726f7070 	.word	0x726f7070
    53c0:	0d646574 	.word	0x0d646574
    53c4:	0000000a 	.word	0x0000000a
    53c8:	74696e49 	.word	0x74696e49
    53cc:	696c6169 	.word	0x696c6169
    53d0:	6974617a 	.word	0x6974617a
    53d4:	43206e6f 	.word	0x43206e6f
    53d8:	6c706d6f 	.word	0x6c706d6f
    53dc:	20657465 	.word	0x20657465
    53e0:	00000a0d 	.word	0x00000a0d
    53e4:	74697753 	.word	0x74697753
    53e8:	64656863 	.word	0x64656863
    53ec:	206f7420 	.word	0x206f7420
    53f0:	74736146 	.word	0x74736146
    53f4:	65705320 	.word	0x65705320
    53f8:	0a0d6465 	.word	0x0a0d6465
    53fc:	00000000 	.word	0x00000000
    5400:	20746f4e 	.word	0x20746f4e
    5404:	545f4453 	.word	0x545f4453
    5408:	5f455059 	.word	0x5f455059
    540c:	43483256 	.word	0x43483256
    5410:	00000a0d 	.word	0x00000a0d
    5414:	64616552 	.word	0x64616552
    5418:	6f6c6220 	.word	0x6f6c6220
    541c:	61206b63 	.word	0x61206b63
    5420:	65726464 	.word	0x65726464
    5424:	0a0d7373 	.word	0x0a0d7373
    5428:	00000000 	.word	0x00000000
    542c:	64616552 	.word	0x64616552
    5430:	0d676e69 	.word	0x0d676e69
    5434:	0000000a 	.word	0x0000000a
    5438:	64616552 	.word	0x64616552
    543c:	6d6f6320 	.word	0x6d6f6320
    5440:	74656c70 	.word	0x74656c70
    5444:	000a0d65 	.word	0x000a0d65
    5448:	20435243 	.word	0x20435243
    544c:	74697257 	.word	0x74697257
    5450:	61462065 	.word	0x61462065
    5454:	0a0d6c69 	.word	0x0a0d6c69
    5458:	00000000 	.word	0x00000000
    545c:	74697257 	.word	0x74697257
    5460:	6f432065 	.word	0x6f432065
    5464:	656c706d 	.word	0x656c706d
    5468:	0a0d6574 	.word	0x0a0d6574
    546c:	00000000 	.word	0x00000000
    5470:	74697257 	.word	0x74697257
    5474:	754d2065 	.word	0x754d2065
    5478:	7069746c 	.word	0x7069746c
    547c:	4220656c 	.word	0x4220656c
    5480:	6b636f6c 	.word	0x6b636f6c
    5484:	64644120 	.word	0x64644120
    5488:	73736572 	.word	0x73736572
    548c:	69614620 	.word	0x69614620
    5490:	0d64656c 	.word	0x0d64656c
    5494:	0000000a 	.word	0x0000000a
    5498:	20435243 	.word	0x20435243
    549c:	746c754d 	.word	0x746c754d
    54a0:	656c7069 	.word	0x656c7069
    54a4:	69725720 	.word	0x69725720
    54a8:	46206574 	.word	0x46206574
    54ac:	656c6961 	.word	0x656c6961
    54b0:	000a0d64 	.word	0x000a0d64
    54b4:	74697257 	.word	0x74697257
    54b8:	754d2065 	.word	0x754d2065
    54bc:	7069746c 	.word	0x7069746c
    54c0:	4320656c 	.word	0x4320656c
    54c4:	6c706d6f 	.word	0x6c706d6f
    54c8:	0d657465 	.word	0x0d657465
    54cc:	0000000a 	.word	0x0000000a

000054d0 <_global_impure_ptr>:
    54d0:	20000010                                ... 

000054d4 <_init>:
    54d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    54d6:	46c0      	nop			; (mov r8, r8)
    54d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    54da:	bc08      	pop	{r3}
    54dc:	469e      	mov	lr, r3
    54de:	4770      	bx	lr

000054e0 <__init_array_start>:
    54e0:	00004cd5 	.word	0x00004cd5

000054e4 <__frame_dummy_init_array_entry>:
    54e4:	000020dd                                . ..

000054e8 <_fini>:
    54e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    54ea:	46c0      	nop			; (mov r8, r8)
    54ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
    54ee:	bc08      	pop	{r3}
    54f0:	469e      	mov	lr, r3
    54f2:	4770      	bx	lr

000054f4 <__fini_array_start>:
    54f4:	000020b5 	.word	0x000020b5
